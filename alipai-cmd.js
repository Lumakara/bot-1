// Â© ALIP-AI | WhatsApp: 0812-4970-3469
// âš ï¸ Do not remove this credit

process.on('uncaughtException', console.error)
process.on('unhandledRejection', console.error)
require('./settings')
require('./menu-alipai')
const fs = require('fs');
const path = require('path');
const util = require('util');
const jimp = require('jimp');
const axios = require('axios');
const { ImageUploadService } = require('node-upload-images');
const chalk = require('chalk');
const yts = require('yt-search');
const ytdl = require('@vreden/youtube_scraper');
const speed = require('performance-now');
const moment = require("moment-timezone");
const nou = require("node-os-utils");
const cheerio = require('cheerio');
const ffmpeg = require('fluent-ffmpeg');
const os = require('os');
const { fileTypeFromBuffer } = require("file-type");
const FormData = require('form-data');
const { say } = require("cfonts")
const pino = require('pino');
const log = pino(); 
const { createCanvas, loadImage, registerFont } = require('canvas'); 
const { Client } = require('ssh2');
const QRCode = require('qrcode');
const fetch = require('node-fetch');
const crypto = require('crypto');
const { exec, spawn, execSync } = require('child_process');
const { default: WAalipection, BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, getBinaryNodeChildren, useMultiFileAuthState, generateWAMessageContent, downloadContentFromMessage, generateWAMessage, prepareWAMessageMedia, areJidsSameUser, getContentType } = require('@whiskeysockets/baileys');
const { LoadDataBase } = require('./source/message');
const { handleSambungKata, handleWordSubmission, isWordSubmission } = require('./lib/sambungkata');
const tictactoe = require('./lib/tictactoe');
const depositPath = './library/database/sessions/';
const { imagetools } = require('./lib/hd');
const AutoAiHandler = require('./lib/alip-autoai');
const contacts = JSON.parse(fs.readFileSync("./library/database/contacts.json"))
const owners = JSON.parse(fs.readFileSync("./library/database/owner.json"))
const premium = JSON.parse(fs.readFileSync("./library/database/premium.json"))
const { remini, mediafire, tiktokDl } = require('./library/scraper');
const { unixTimestampSeconds, generateMessageTeg, processTime, webApi, getRandom, getBuffer, fetchJson, runtime, clockString, sleep, isUrl, getTime, formatDate, tanggal, formatp, jsonformat, reSize, toHD, logic, generateProfilePicture, bytesToSize, checkBandwidth, getSizeMedia, parseMention, getGroupAdmins, readFileTxt, readFileJson, getHashedPassword, generateAuthToken, cekMenfes, generateToken, batasiTeks, randomText, isEmoji, getTypeUrlMedia, pickRandom, toIDR, capital } = require('./library/function');

const prefixDBPath = './library/database/prefix.json';
if (!fs.existsSync(prefixDBPath)) {
    fs.writeFileSync(prefixDBPath, JSON.stringify({}, null, 2));
}

function getPrefix(chatId) {
    try {
        const data = JSON.parse(fs.readFileSync(prefixDBPath));
        return data[chatId] || ".";
    } catch (e) {
        return ".";
    }
}

function setPrefix(chatId, prefix) {
    try {
        const data = JSON.parse(fs.readFileSync(prefixDBPath));
        data[chatId] = prefix;
        fs.writeFileSync(prefixDBPath, JSON.stringify(data, null, 2));
        return true;
    } catch (e) {
        return false;
    }
}
const onlyPremPath = './library/database/onlyprem.json'

if (!fs.existsSync(onlyPremPath)) {
fs.writeFileSync(onlyPremPath, JSON.stringify({}, null, 2))
}

function loadOnlyPrem() {
try {
return JSON.parse(fs.readFileSync(onlyPremPath))
} catch {
return {}
}
}

function saveOnlyPrem(data) {
fs.writeFileSync(onlyPremPath, JSON.stringify(data, null, 2))
}

function isOnlyPremGroup(chatId) {
const data = loadOnlyPrem()
return data[chatId] === true
}
const schedulePath = './library/database/schedule.json';
if (!fs.existsSync(schedulePath)) {
    fs.writeFileSync(schedulePath, JSON.stringify({ messages: [] }, null, 2));
}

// ---------- premium helper -----------
const dbPrem = './library/database/premium.json';
if (!fs.existsSync(dbPrem)) fs.writeFileSync(dbPrem, '[]');
let prem = JSON.parse(fs.readFileSync(dbPrem));
const toMs = d => d * 24 * 60 * 60 * 1000;
global.isPrem = jid => {
  prem = JSON.parse(fs.readFileSync(dbPrem));
  const u = prem.find(v => v.jid === jid);
  if (!u) return false;

  if (Date.now() > u.expired) {
    prem = prem.filter(v => v.jid !== jid);
    fs.writeFileSync(dbPrem, JSON.stringify(prem, null, 2));
    return false;
  }
  return true;
};
const premiumAccessPath = './library/database/premium_access.json';
if (!fs.existsSync(premiumAccessPath)) {
    fs.writeFileSync(premiumAccessPath, JSON.stringify({ users: {} }, null, 2));
}

function loadPremiumAccess() {
    try {
        return JSON.parse(fs.readFileSync(premiumAccessPath));
    } catch (e) {
        return { users: {} };
    }
}

function savePremiumAccess(data) {
    fs.writeFileSync(premiumAccessPath, JSON.stringify(data, null, 2));
}

function hasPremiumAccess(jid) {
    const data = loadPremiumAccess();
    let normalizedJid = jid;
    
    if (jid.endsWith('@lid')) {
        normalizedJid = jid.replace('@lid', '@s.whatsapp.net');
    }
    
    const user = data.users[normalizedJid] || data.users[jid];
    if (!user) return false;
    
    if (Date.now() > user.expires) {
        delete data.users[normalizedJid];
        if (jid !== normalizedJid) delete data.users[jid];
        savePremiumAccess(data);
        return false;
    }
    
    return true;
}
function isSameUser(jid1, jid2) {
    if (!jid1 || !jid2) return false;
    const isLid = (jid) => jid.endsWith('@lid');
    const normalizedJid1 = jid1.replace('@lid', '@s.whatsapp.net');
    const normalizedJid2 = jid2.replace('@lid', '@s.whatsapp.net');
    return areJidsSameUser(normalizedJid1, normalizedJid2);
}

const autoMentionAIPath = './library/database/auto_mention_ai.json';
if (!fs.existsSync(autoMentionAIPath)) {
    fs.writeFileSync(autoMentionAIPath, JSON.stringify({ enabled: false }, null, 2));
}
function loadAutoMentionAI() {
    try {
        return JSON.parse(fs.readFileSync(autoMentionAIPath));
    } catch (e) {
        return { enabled: false };
    }
}
function saveAutoMentionAI(data) {
    fs.writeFileSync(autoMentionAIPath, JSON.stringify(data, null, 2));
}
function isAutoMentionAIEnabled() {
    const config = loadAutoMentionAI();
    return config.enabled === true;
}

// === SISTEM PAKASIR WEBHOOK ===
const paymentCheckerInterval = 10000;

function setupPakasirWebhook(alipInstance) {
    if (!global.pakasirWebhookInitialized) {
        startPaymentStatusChecker(alipInstance);
        global.pakasirWebhookInitialized = true;
    }
}

async function checkPaidTransactions(alip) {
    try {
        const depositFiles = fs.readdirSync(depositPath).filter(f => f.startsWith('pakasir_') && f.endsWith('.json'));
        
        for (const file of depositFiles) {
            const filePath = path.join(depositPath, file);
            const sessionData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            
            if (sessionData.status === 'completed' || sessionData.status === 'failed') continue;
            
            try {
                const checkUrl = `https://app.pakasir.com/api/transactiondetail?project=${global.slug}&amount=${sessionData.price}&order_id=${sessionData.sessionId}&api_key=${global.pkasirapikey}`;
                const response = await axios.get(checkUrl);
                
                if (response.data && response.data.transaction && response.data.transaction.status === 'completed') {
                    await processSuccessfulPayment(alip, sessionData, response.data.transaction);
                }
            } catch (e) {}
        }
    } catch (e) {}
}

async function processSuccessfulPayment(alip, sessionData, transactionData) {
    const sessionId = sessionData.sessionId;
    
    sessionData.status = 'completed';
    sessionData.completedAt = transactionData.completed_at;
    sessionData.transactionData = transactionData;
    
    const sessionPath = path.join(depositPath, `pakasir_${sessionId}.json`);
    fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
    
    const userJid = sessionData.userJid;
    const userName = sessionData.userName || userJid.split('@')[0];
    
    let successMessage = `âœ… *PEMBAYARAN BERHASIL!*\n\n`;
    successMessage += `ðŸ†” ID: ${sessionId}\n`;
    successMessage += `ðŸ‘¤ Pembeli: ${userName}\n`;
    successMessage += `ðŸ’° Nominal: Rp${sessionData.price.toLocaleString()}\n`;
    successMessage += `â° Waktu: ${new Date().toLocaleString('id-ID')}\n\n`;
    
    let targetChatId = userJid;
    
    if (sessionData.qrMessageKey && sessionData.qrMessageKey.remoteJid) {
        targetChatId = sessionData.qrMessageKey.remoteJid;
    } else if (sessionData.chatId) {
        targetChatId = sessionData.chatId;
    }
    
    if (sessionData.purpose === 'premium') {
        const premiumPath = './library/database/premium.json';
        let premData = fs.existsSync(premiumPath) ? JSON.parse(fs.readFileSync(premiumPath)) : [];
        
        const existingUser = premData.find(u => u.jid === userJid);
        const expiredDate = Date.now() + (sessionData.days * 24 * 60 * 60 * 1000);
        
        if (existingUser) {
            existingUser.expired = Math.max(existingUser.expired, expiredDate);
        } else {
            premData.push({
                jid: userJid,
                expired: expiredDate,
                purchased: Date.now(),
                plan: '30days'
            });
        }
        
        fs.writeFileSync(premiumPath, JSON.stringify(premData, null, 2));
        
        successMessage += `ðŸŽ‰ *PREMIUM AKTIF!*\n`;
        successMessage += `Durasi: ${sessionData.days} hari\n`;
        successMessage += `Berakhir: ${new Date(expiredDate).toLocaleDateString('id-ID')}\n\n`;
        successMessage += `Sekarang Anda dapat mengakses semua fitur premium!`;
        
    } else if (sessionData.purpose === 'sewagc') {
        const sewaPath = './library/database/sewagrup.json';
        let sewaData = fs.existsSync(sewaPath) ? JSON.parse(fs.readFileSync(sewaPath)) : [];
        
        const expiredDate = Date.now() + (sessionData.days * 24 * 60 * 60 * 1000);
        
        sewaData.push({
            jid: sessionData.inviteCode,
            expired: expiredDate,
            buyer: userJid,
            purchased: Date.now(),
            days: sessionData.days
        });
        
        fs.writeFileSync(sewaPath, JSON.stringify(sewaData, null, 2));
        
        successMessage += `ðŸ‘¥ *SEWA GRUP AKTIF!*\n`;
        successMessage += `Link: ${sessionData.groupLink}\n`;
        successMessage += `Durasi: ${sessionData.days} hari\n`;
        successMessage += `Berakhir: ${new Date(expiredDate).toLocaleDateString('id-ID')}\n\n`;
        successMessage += `Bot akan otomatis join ke grup Anda.`;
        
        try {
            await alip.groupAcceptInvite(sessionData.inviteCode);
        } catch (e) {
            successMessage += `\nâš ï¸ Gagal join otomatis, silakan invite manual.`;
        }
    }
    
    if (sessionData.qrMessageKey) {
        try {
            await alip.sendMessage(targetChatId, { delete: sessionData.qrMessageKey });
        } catch (e) {}
    }
    
    await alip.sendMessage(targetChatId, { text: successMessage });
    
    if (sessionData.qrPath && fs.existsSync(sessionData.qrPath)) {
        fs.unlinkSync(sessionData.qrPath);
    }
}

function startPaymentStatusChecker(alipInstance) {
    setInterval(() => {
        checkPaidTransactions(alipInstance);
    }, paymentCheckerInterval);
}

// PENGINGAT SHOLAT 
const jadwalSholatJakarta = {
    "Subuh": "04:27", 
    "Dzuhur": "12:02",   
    "Ashar": "15:23", 
    "Maghrib": "18:00", 
    "Isya": "19:12"
};
global.isSholatReminderOn = true;
global.isSchedulerRunning = false;
global.lastSholatSent = {};
// ---------- SETMENU SYSTEM ----------
const menuStylePath = './library/database/menu_style.json';
if (!fs.existsSync(menuStylePath)) {
    fs.writeFileSync(menuStylePath, JSON.stringify({ globalVersion: 'v1' }, null, 2));
}

function loadMenuStyle() {
    try {
        return JSON.parse(fs.readFileSync(menuStylePath));
    } catch (e) {
        return { globalVersion: 'v1' };
    }
}

function saveMenuStyle(data) {
    fs.writeFileSync(menuStylePath, JSON.stringify(data, null, 2));
}

function getMenuStyle() {
    const data = loadMenuStyle();
    return data.globalVersion || 'v1';
}

function setMenuStyle(version) {
    const data = loadMenuStyle();
    data.globalVersion = version;
    saveMenuStyle(data);
}
async function kirimPengingatOffline(alip, namaSholat) {
    try {
        const today = new Date().toDateString();
        if (global.lastSholatSent[namaSholat] === today) return;

        const semuaGrup = await alip.groupFetchAllParticipating();
        const idGrup = Object.keys(semuaGrup);

        for (const id of idGrup) {
            try {
                await alip.sendMessage(id, {
                    audio: { url: 'https://cdn.yupra.my.id/yp/isu1q6dq.mp3' },
                    mimetype: 'audio/mpeg',
                    ptt: false,
                    contextInfo: {
                        externalAdReply: {
                            title: `ðŸ”” Waktunya Sholat ${namaSholat}`,
                            body: `Untuk wilayah Jakarta dan sekitarnya.`,
                            thumbnailUrl: 'https://cdn.yupra.my.id/yp/njdmvhdc.jpg',
                            sourceUrl: 'https://www.google.com/search?q=waktu+sholat+jakarta',
                            mediaType: 1,
                            renderLargerThumbnail: true
                        }
                    }
                });
                await sleep(2000);
            } catch (e) {}
        }

        global.lastSholatSent[namaSholat] = today;
    } catch (e) {}
}
function setupPrayerRemindersOffline(alip) {
    checkAndSendPrayerReminders(alip);

    const sholatInterval = setInterval(async () => {
        await checkAndSendPrayerReminders(alip);
    }, 60000);

    global.sholatIntervalId = sholatInterval;
}

async function checkAndSendPrayerReminders(alip) {
    if (!global.isSholatReminderOn) return;

    const now = new Date();
    const wibTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Jakarta' }));
    const hours = String(wibTime.getHours()).padStart(2, '0');
    const minutes = String(wibTime.getMinutes()).padStart(2, '0');
    const currentTime = `${hours}:${minutes}`;

    for (const [namaSholat, waktuSholat] of Object.entries(jadwalSholatJakarta)) {
        if (currentTime === waktuSholat) {
            await kirimPengingatOffline(alip, namaSholat);
            break;
        }
    }
}

const sholatReminderPath = './library/database/pengingat_sholat.json';

function loadSholatSettings() {
    try {
        if (fs.existsSync(sholatReminderPath)) {
            const data = fs.readFileSync(sholatReminderPath, 'utf8');
            const settings = JSON.parse(data);
            global.isSholatReminderOn = settings.isActive !== false;
            return settings;
        } else {
            const defaultSettings = { isActive: true };
            fs.writeFileSync(sholatReminderPath, JSON.stringify(defaultSettings, null, 2));
            global.isSholatReminderOn = true;
            return defaultSettings;
        }
    } catch (e) {
        global.isSholatReminderOn = true;
        const defaultSettings = { isActive: true };
        fs.writeFileSync(sholatReminderPath, JSON.stringify(defaultSettings, null, 2));
        return defaultSettings;
    }
}

let sholatSettings = loadSholatSettings();

function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
  for (let i = 0; i <= a.length; i++) {
    matrix[0][i] = i;
  }
  for (let j = 0; j <= b.length; j++) {
    matrix[j][0] = j;
  }
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1, 
        matrix[j - 1][i] + 1, 
        matrix[j - 1][i - 1] + indicator, 
      );
    }
  }
  return matrix[b.length][a.length];
}

function getAllCommands() {
    let commands = new Set();
    const clutchContent = fs.readFileSync(path.join(__dirname, 'alipai-cmd.js'), 'utf-8');
    const clutchMatches = clutchContent.matchAll(/case\s+['"`](.*?)['"`]:/g);
    for (const match of clutchMatches) {
        commands.add(match[1]);
    }
    const pluginsDir = path.join(__dirname, 'plugins');
    if (fs.existsSync(pluginsDir)) {
        const pluginFiles = fs.readdirSync(pluginsDir).filter(file => file.endsWith('.js'));
        for (const file of pluginFiles) {
            try {
                const plugin = require(path.join(pluginsDir, file));
                if (plugin.command && Array.isArray(plugin.command)) {
                    plugin.command.forEach(cmd => commands.add(cmd));
                }
            } catch (e) {
                console.error(`Gagal memuat plugin ${file} untuk daftar command:`, e);
            }
        }
    }
    
    return Array.from(commands);
}

const allCommands = getAllCommands();

try {
    if (fs.existsSync('./library/database/groups_db.json')) {
        const data = JSON.parse(fs.readFileSync('./library/database/groups_db.json', 'utf8'));
        if (!global.db) global.db = {};
        global.db.groups = data;
    }
} catch (e) {
    if (!global.db) global.db = {};
    global.db.groups = {};
}

const autoBackupConfigPath = './library/database/autobackup_config.json'
if (!global.autoBackup) global.autoBackup = { enabled: false, timer: null }

function initializeAutoBackupOnStart(alipInstance) {
  try {
    if (fs.existsSync(autoBackupConfigPath)) {
      const config = JSON.parse(fs.readFileSync(autoBackupConfigPath, 'utf8'))
      if (config.enabled && config.interval) {
        global.autoBackup.enabled = true
        global.autoBackup.interval = config.interval
        
        const intervalMs = config.interval * 60 * 60 * 1000
        
        setTimeout(() => {
          doBackupDatabase(alipInstance)
        }, 10000)
        
        global.autoBackup.timer = setInterval(() => {
          doBackupDatabase(alipInstance)
        }, intervalMs)
      }
    }
  } catch (e) {
  }
}

async function doBackupDatabase(alipInstance) {
  try {
    const { execSync } = require('child_process')
    const ownerJid = global.owner + '@s.whatsapp.net'

    const stamp = new Date().toLocaleString('id-ID', { 
      timeZone: 'Asia/Jakarta',
      day: '2-digit',
      month: '2-digit', 
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }).replace(/[\/\:\s]/g, '-')
    
    const zipName = `database-backup-${stamp}.zip`
    const dbPath = './library/database'

    if (!fs.existsSync(dbPath)) {
      return
    }

    execSync(`zip -r ${zipName} ./library/database ./library/media`, { stdio: 'ignore' })
    
    await alipInstance.sendMessage(ownerJid, {
      document: fs.readFileSync(zipName),
      fileName: zipName,
      mimetype: 'application/zip',
      caption: `ðŸ“¦ *Database Backup* - ${stamp}`
    })
    
    fs.unlinkSync(zipName)    
  } catch (e) {
  }
}
function generateGeneralQuiz(category, level) {
    const questions = [];
    const totalQuestions = level === 'easy' ? 10 : level === 'normal' ? 15 : 20;

    const questionPools = {
        matematika: {
            easy: [
                { q: "5 + 7 = ?", a: "12" },
                { q: "9 - 4 = ?", a: "5" },
                { q: "6 Ã— 3 = ?", a: "18" },
                { q: "15 Ã· 3 = ?", a: "5" },
                { q: "8 + 12 = ?", a: "20" },
                { q: "25 - 13 = ?", a: "12" },
                { q: "4 Ã— 5 = ?", a: "20" },
                { q: "36 Ã· 6 = ?", a: "6" },
                { q: "11 + 9 = ?", a: "20" },
                { q: "17 - 8 = ?", a: "9" },
                { q: "7 Ã— 8 = ?", a: "56" },
                { q: "45 Ã· 9 = ?", a: "5" },
                { q: "13 + 17 = ?", a: "30" },
                { q: "22 - 14 = ?", a: "8" },
                { q: "9 Ã— 9 = ?", a: "81" }
            ],
            normal: [
                { q: "123 + 456 = ?", a: "579" },
                { q: "789 - 234 = ?", a: "555" },
                { q: "12 Ã— 13 = ?", a: "156" },
                { q: "144 Ã· 12 = ?", a: "12" },
                { q: "25% dari 200 = ?", a: "50" },
                { q: "3/4 + 1/2 = ?", a: "1.25" },
                { q: "15Â² = ?", a: "225" },
                { q: "âˆš169 = ?", a: "13" },
                { q: "5 Ã— (3 + 4) = ?", a: "35" },
                { q: "1000 - 567 = ?", a: "433" }
            ],
            hard: [
                { q: "Jika 3x + 5 = 20, maka x = ?", a: "5" },
                { q: "Luas lingkaran dengan jari-jari 7 cm? (Ï€=22/7)", a: "154" },
                { q: "Sin 30Â° = ?", a: "0.5" },
                { q: "Cos 60Â° = ?", a: "0.5" },
                { q: "Turunan dari 3xÂ² + 2x - 5?", a: "6x + 2" },
                { q: "Integral dari 2x dx?", a: "xÂ²" },
                { q: "Log 100 = ?", a: "2" },
                { q: "2Â³ + 3Â² = ?", a: "17" }
            ]
        },
        bahasa: {
            easy: [
                { q: "Sinonim dari 'cantik'?", a: "indah" },
                { q: "Antonim dari 'besar'?", a: "kecil" },
                { q: "Ibu kota Indonesia?", a: "jakarta" },
                { q: "Penulis novel 'Sang Pemimpi'?", a: "andrea hirata" },
                { q: "Siapa pencipta lagu Indonesia Raya?", a: "wage rudolf supratman" },
                { q: "Bahasa resmi Indonesia?", a: "bahasa indonesia" },
                { q: "Presiden pertama Indonesia?", a: "soekarno" },
                { q: "Mata uang Indonesia?", a: "rupiah" },
                { q: "Lagu kebangsaan Indonesia?", a: "indonesia raya" },
                { q: "Pulau terbesar di Indonesia?", a: "papua" }
            ],
            normal: [
                { q: "Apa arti kata 'filsafat'?", a: "ilmu pengetahuan" },
                { q: "Siapa penulis 'Habis Gelap Terbitlah Terang'?", a: "r.a kartini" },
                { q: "Apa nama pahlawan dari Aceh?", a: "cut nyak dien" },
                { q: "Siapa sastrawan 'Aku'?", a: "chairil anwar" },
                { q: "Penulis 'Bumi Manusia'?", a: "pramoedya ananta toer" }
            ],
            hard: [
                { q: "Apa yang dimaksud dengan metafora?", a: "perumpamaan" },
                { q: "Siapa penulis novel 'Negeri 5 Menara'?", a: "ahmad fuadi" },
                { q: "Apa arti ungkapan 'besar pasak daripada tiang'?", a: "pengeluaran lebih besar dari pemasukan" },
                { q: "Siapa penyair 'Padamu Jua'?", a: "amir hamzah" }
            ]
        },
        geografi: {
            easy: [
                { q: "Ibu kota Amerika Serikat?", a: "washington dc" },
                { q: "Ibu kota Inggris?", a: "london" },
                { q: "Ibu kota Jepang?", a: "tokyo" },
                { q: "Ibu kota Australia?", a: "canberra" },
                { q: "Ibu kota China?", a: "beijing" },
                { q: "Ibu kota Prancis?", a: "paris" },
                { q: "Ibu kota Jerman?", a: "berlin" },
                { q: "Ibu kota Italia?", a: "roma" },
                { q: "Ibu kota Rusia?", a: "moskow" },
                { q: "Ibu kota Brazil?", a: "brasilia" }
            ],
            normal: [
                { q: "Negara terluas di dunia?", a: "rusia" },
                { q: "Samudera terbesar?", a: "pasifik" },
                { q: "Gunung tertinggi di dunia?", a: "everest" },
                { q: "Sungai terpanjang di dunia?", a: "nil" },
                { q: "Gurun terbesar di dunia?", a: "sahara" }
            ],
            hard: [
                { q: "Ibu kota Azerbaijan?", a: "baku" },
                { q: "Ibu kota Kazakhstan?", a: "astana" },
                { q: "Ibu kota Uzbekistan?", a: "tashkent" },
                { q: "Ibu kota Turkmenistan?", a: "ashgabat" }
            ]
        },
        sejarah: {
            easy: [
                { q: "Presiden pertama Indonesia?", a: "soekarno" },
                { q: "Tanggal kemerdekaan Indonesia?", a: "17 agustus 1945" },
                { q: "Siapa penemu bola lampu?", a: "thomas alva edison" },
                { q: "Siapa penemu telepon?", a: "alexander graham bell" },
                { q: "Siapa penemu pesawat terbang?", a: "wright bersaudara" },
                { q: "Perang dunia kedua berakhir tahun?", a: "1945" },
                { q: "Siapa presiden Indonesia sekarang?", a: "joko widodo" },
                { q: "Siapa wakil presiden pertama?", a: "mohammad hatta" },
                { q: "Siapa pahlawan nasional dari Bali?", a: "i gusti ngurah rai" },
                { q: "Siapa pahlawan nasional dari Jawa Barat?", a: "kartini" }
            ],
            normal: [
                { q: "Tahun berapa peristiwa G30S/PKI?", a: "1965" },
                { q: "Siapa proklamator kemerdekaan Indonesia?", a: "soekarno dan hatta" },
                { q: "Kapan BPUPKI dibentuk?", a: "1945" },
                { q: "Siapa ketua PPKI?", a: "soekarno" },
                { q: "Peristiwa Bandung Lautan Api tahun?", a: "1946" }
            ],
            hard: [
                { q: "Siapa perdana menteri pertama Indonesia?", a: "sutan sjahrir" },
                { q: "Tahun berapa Konferensi Asia Afrika?", a: "1955" },
                { q: "Siapa penandatanganan naskah proklamasi selain Soekarno-Hatta?", a: "soekarni" },
                { q: "Kapan Indonesia masuk PBB?", a: "1950" }
            ]
        },
        seni: {
            easy: [
                { q: "Pelukis Mona Lisa?", a: "leonardo da vinci" },
                { q: "Komposer musik 'FÃ¼r Elise'?", a: "beethoven" },
                { q: "Pencipta lagu 'Bengawan Solo'?", a: "gesang" },
                { q: "Tarian tradisional Bali?", a: "kecak" },
                { q: "Alat musik tradisional Jawa?", a: "gamelan" },
                { q: "Pelukis Indonesia terkenal?", a: "raden saleh" },
                { q: "Penyanyi legenda Indonesia?", a: "koes plus" },
                { q: "Wayang kulit berasal dari?", a: "jawa" },
                { q: "Batik berasal dari?", a: "indonesia" },
                { q: "Pencipta lagu 'Halo-halo Bandung'?", a: "ismail marzuki" }
            ],
            normal: [
                { q: "Pelukis 'Potret Diri dengan Topi'?", a: "vincent van gogh" },
                { q: "Komposer 'Swan Lake'?", a: "pyotr ilyich tchaikovsky" },
                { q: "Pencipta lagu 'Indonesia Pusaka'?", a: "ismail marzuki" },
                { q: "Tari Saman dari?", a: "aceh" },
                { q: "Tari Piring dari?", a: "sumatera barat" }
            ],
            hard: [
                { q: "Pelukis 'The Scream'?", a: "edvard munch" },
                { q: "Komposer 'The Four Seasons'?", a: "antonio vivaldi" },
                { q: "Pencipta lagu 'Gugur Bunga'?", a: "ismail marzuki" },
                { q: "Tari Seudati dari?", a: "aceh" }
            ]
        },
        sains: {
            easy: [
                { q: "Planet terdekat dari matahari?", a: "merkuri" },
                { q: "Planet terbesar di tata surya?", a: "jupiter" },
                { q: "Satelit alami bumi?", a: "bulan" },
                { q: "Penemu gravitasi?", a: "isaac newton" },
                { q: "Penemu teori relativitas?", a: "albert einstein" },
                { q: "Unsur kimia O?", a: "oksigen" },
                { q: "Unsur kimia H?", a: "hidrogen" },
                { q: "Jumlah planet di tata surya?", a: "8" },
                { q: "Tumbuhan membuat makanan melalui?", a: "fotosintesis" },
                { q: "Bagian sel yang mengatur aktivitas?", a: "inti sel" }
            ],
            normal: [
                { q: "Rumus kimia air?", a: "h2o" },
                { q: "Rumus kimia garam dapur?", a: "nacl" },
                { q: "Penemu sel?", a: "robert hooke" },
                { q: "Penemu penisilin?", a: "alexander fleming" },
                { q: "Penemu vaksin cacar?", a: "edward jenner" }
            ],
            hard: [
                { q: "Rumus kimia metana?", a: "ch4" },
                { q: "Rumus kimia karbon dioksida?", a: "co2" },
                { q: "Penemu sinar-X?", a: "wilhelm rÃ¶ntgen" },
                { q: "Penemu radioaktivitas?", a: "marie curie" }
            ]
        },
        game: {
            easy: [
                { q: "Karakter utama Minecraft?", a: "steve" },
                { q: "Karakter utama Super Mario?", a: "mario" },
                { q: "Karakter utama Pokemon?", a: "ash ketchum" },
                { q: "Game balapan terkenal?", a: "need for speed" },
                { q: "Game battle royale terkenal?", a: "fortnite" },
                { q: "Karakter dengan pedang besar?", a: "cloud strife" },
                { q: "Game petualangan blok?", a: "minecraft" },
                { q: "Karakter berwarna biru cepat?", a: "sonic" },
                { q: "Karakter ninja di Naruto?", a: "naruto uzumaki" },
                { q: "Karakter bajak laut di One Piece?", a: "monkey d luffy" }
            ],
            normal: [
                { q: "Developer game GTA V?", a: "rockstar games" },
                { q: "Developer game Minecraft?", a: "mojang" },
                { q: "Developer game Fortnite?", a: "epic games" },
                { q: "Karakter dengan Sharingan di Naruto?", a: "sasuke uchiha" },
                { q: "Karakter dengan pedang di One Piece?", a: "roronoa zoro" }
            ],
            hard: [
                { q: "Tahun rilis Minecraft?", a: "2011" },
                { q: "Tahun rilis GTA V?", a: "2013" },
                { q: "Developer game Dark Souls?", a: "fromsoftware" },
                { q: "Karakter dengan Byakugan di Naruto?", a: "neji hyuga" }
            ]
        }
    };

    const pool = questionPools[category]?.[level];
    if (!pool) return { questions: [] };

    for (let i = 0; i < totalQuestions; i++) {
        if (i < pool.length) {
            const q = pool[i];
            questions.push({
                number: i + 1,
                question: q.q,
                answer: q.a.toLowerCase(),
                points: level === 'easy' ? 1 : level === 'normal' ? 2 : 3
            });
        } else {
            const randomQ = pool[Math.floor(Math.random() * pool.length)];
            questions.push({
                number: i + 1,
                question: randomQ.q,
                answer: randomQ.a.toLowerCase(),
                points: level === 'easy' ? 1 : level === 'normal' ? 2 : 3
            });
        }
    }

    return { questions: shuffleArray(questions) };
}

async function sendQuizQuestion(sender, chatId, session, alipInstance) {
    const current = session.currentQuestion;
    const total = session.questions.length;
    const question = session.questions[current];
    
    let questionText = `ðŸ“ *SOAL ${current + 1}/${total}*\n\n`;
    questionText += `Kategori: ${session.category.toUpperCase()}\n`;
    questionText += `Level: ${session.level.toUpperCase()}\n\n`;
    questionText += `â“ ${question.question}\n\n`;
    questionText += `ðŸŽ¯ Poin: ${question.points}\n`;
    questionText += `â±ï¸ Sisa waktu: ${Math.ceil((session.timeLimit - (Date.now() - session.startTime)) / 1000)} detik\n\n`;
    questionText += `ðŸ’¬ *Balas pesan ini dengan jawabanmu!*\n`;
    questionText += `ðŸ”¤ Jawaban bisa dalam huruf kecil\n`;
    questionText += `â¹ï¸ Ketik *stop* untuk berhenti`;

    await alipInstance.sendMessage(chatId, { 
        text: questionText
    });
    
    session.questionStartTime = Date.now();
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

const stickerCommandPath = './library/database/sticker_commands.json';
if (!fs.existsSync(stickerCommandPath)) {
    fs.writeFileSync(stickerCommandPath, JSON.stringify({}, null, 2));
}
function loadStickerCommands() {
    try {
        return JSON.parse(fs.readFileSync(stickerCommandPath));
    } catch (e) {
        return {};
    }
}
function saveStickerCommands(data) {
    fs.writeFileSync(stickerCommandPath, JSON.stringify(data, null, 2));
}
module.exports = alip = async (alip, m, chatUpdate, store) => {
    if (!global.bypassCheck) {
    const { fetchDatabaseList, isNumberInDatabase    } = require('./library/function');
    
    const databaseList = await fetchDatabaseList();
    const botPhone = (alip.user.id.split(':')[0] || '').
    replace('@s.whatsapp.net', '');
    
    if (!isNumberInDatabase(botPhone, databaseList)) {
        return;
    }
    }
    if (!global.autoBackupInitialized) {
    initializeAutoBackupOnStart(alip)
    global.autoBackupInitialized = true
    }
    if (!global.pakasirWebhookInitialized) {
        setupPakasirWebhook(alip);
        global.pakasirWebhookInitialized = true;
    }
    
    if (!global.isSchedulerRunning) {
        setupPrayerRemindersOffline(alip);
        global.isSchedulerRunning = true;
    }
    if (!global.autoAiHandler) {
    global.autoAiHandler = new AutoAiHandler(alip);
    }
    try {
    await LoadDataBase(alip, m)
const botNumber = await alip.decodeJid(alip.user.id)
		const body = ((m.type === 'conversation') ? m.message.conversation :
		(m.type == 'imageMessage') ? m.message.imageMessage.caption :
		(m.type == 'videoMessage') ? m.message.videoMessage.caption :
		(m.type == 'extendedTextMessage') ? m.message.extendedTextMessage.text :
		(m.type == 'reactionMessage') ? m.message.reactionMessage.text :
		(m.type == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId :
		(m.type == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId :
		(m.type == 'templateButtonReplyMessage') ? m.message.templateButtonReplyMessage.selectedId :
		(m.type == 'interactiveResponseMessage'  && m.quoted) ? (m.message.interactiveResponseMessage?.nativeFlowResponseMessage ? JSON.parse(m.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson).id : '') :
		(m.type == 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || '') :
		(m.type == 'editedMessage') ? (m.message.editedMessage?.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text || m.message.editedMessage?.message?.protocolMessage?.editedMessage?.conversation || '') :
		(m.type == 'protocolMessage') ? (m.message.protocolMessage?.editedMessage?.extendedTextMessage?.text || m.message.protocolMessage?.editedMessage?.conversation || m.message.protocolMessage?.editedMessage?.imageMessage?.caption || m.message.protocolMessage?.editedMessage?.videoMessage?.caption || '') : '') || '';
const stickerBody = (m.type == 'stickerMessage') ? 'sticker_command' : '';
const finalBody = body || stickerBody;
let processedText = body;
if (m.type === 'stickerMessage') {
    const stickerCommands = loadStickerCommands();
    const stickerId = m.message.stickerMessage?.fileSha256?.toString('hex') || 
                     m.message.stickerMessage?.stickerSha256?.toString('hex') || 
                     m.message.stickerMessage?.mediaKey?.toString('hex') || 
                     'unknown';
    if (stickerId !== 'unknown' && stickerCommands[stickerId]) {
        processedText = stickerCommands[stickerId].command;
    }
}

const budy = typeof processedText === 'string' ? processedText : '';
const buffer64base = `${global.owner}@s.whatsapp.net`
const prefix = getPrefix(m.chat);
const isCmd = typeof processedText === 'string' && processedText.length > 0 && processedText.startsWith(prefix);
const args = isCmd ? body.slice(prefix.length).trim().split(/ +/).slice(1) : body.trim().split(/ +/).slice(1);
const getQuoted = (m.quoted || m)
const quoted = (getQuoted.type == 'buttonsMessage') ? getQuoted[Object.keys(getQuoted)[1]] : (getQuoted.type == 'templateMessage') ? getQuoted.hydratedTemplate[Object.keys(getQuoted.hydratedTemplate)[1]] : (getQuoted.type == 'product') ? getQuoted[Object.keys(getQuoted)[0]] : m.quoted ? m.quoted : m
const command = isCmd ? processedText.slice(prefix.length).trim().split(/ +/).shift().toLowerCase() : '';
const isPremium = global.isPrem(m.sender);
const ownerList = [botNumber, owner + "@s.whatsapp.net", buffer64base, ...owners];
const isCreator = isOwner = ownerList.some(ownerJid => areJidsSameUser(ownerJid, m.sender)) || m.isDeveloper;
const text = q = args.join(' ');
const mime = (quoted.msg || quoted).mimetype || ''
const qmsg = (quoted.msg || quoted)
const sessionFile = `${depositPath}${m.sender.split("@")[0]}.json`;

if (m.isGroup && m.mentionedJid && m.mentionedJid.length > 0 && isAutoMentionAIEnabled()) {
    const mentionedUsers = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
            if (m.metadata && m.metadata.participants) {
                const participant = m.metadata.participants.find(x => x.lid === id || x.id === id)
                return participant ? participant.jid : id.replace('@lid', '@s.whatsapp.net')
            }
            return id.replace('@lid', '@s.whatsapp.net')
        }
        return id
    })
    
    const isBotMentioned = mentionedUsers.some(jid => areJidsSameUser(jid, botNumber))
    
    if (isBotMentioned && !m.fromMe && !m.isBaileys) {
        if (!isRegistered(m.sender) && !isCreator) return
        
        if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) {
            await m.reply(global.mess.limit)
            return
        }
        
        addLimit(m.sender, global.isPrem(m.sender), isCreator)
        
        let questionText = ''
        let imageBuffer = null
        
        if (m.text) {
            const mentionRegex = new RegExp(`@${botNumber.split('@')[0]}\\b`, 'gi')
            questionText = m.text.replace(mentionRegex, '').trim()
        }
        
        if (!questionText && m.quoted?.text) {
            questionText = m.quoted.text
        }
        
        if (!questionText || questionText.length < 2) {
            questionText = "Hai, ada yang bisa saya bantu?"
        }
        
        const getImageFromMessage = async (msg) => {
            try {
                if (msg.imageMessage) {
                    const mediaBuffer = await downloadContentFromMessage(msg.imageMessage, 'image')
                    let bufferArray = []
                    for await (const chunk of mediaBuffer) {
                        bufferArray.push(chunk)
                    }
                    return Buffer.concat(bufferArray)
                }
            } catch (e) {}
            return null
        }

        if (m.message?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message)
        } else if (m.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message.extendedTextMessage.contextInfo.quotedMessage)
        } else if (m.quoted?.msg?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted.msg)
        } else if (m.quoted?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted)
        }
        
        try {
            await alip.sendMessage(m.chat, { react: { text: "ðŸ¤–", key: m.key } })
            
            const axios = require('axios')
            const FormData = require('form-data')

            async function startSession() {
                const { data } = await axios.post(
                    "https://chatgpt4online.org/wp-json/mwai/v1/start_session",
                    {},
                    {
                        headers: {
                            "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                            "Origin": "https://chatgpt4online.org",
                            "Referer": "https://chatgpt4online.org/",
                            "Accept": "*/*",
                            "Content-Type": "application/json"
                        }
                    }
                )

                if (!data.success) throw new Error("start_session failed")

                return {
                    sessionId: data.sessionId,
                    nonce: data.restNonce
                }
            }

            async function uploadImage(nonce, buffer) {
                if (!buffer) return null

                const form = new FormData()
                form.append("purpose", "vision")
                form.append("file", buffer, { filename: `image_${Date.now()}.png` })

                const { data } = await axios.post(
                    "https://chatgpt4online.org/wp-json/mwai-ui/v1/files/upload",
                    form,
                    {
                        headers: {
                            "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                            "Origin": "https://chatgpt4online.org",
                            "Referer": "https://chatgpt4online.org/",
                            "X-WP-Nonce": nonce,
                            ...form.getHeaders()
                        }
                    }
                )

                return data?.data?.id || null
            }

            const session = await startSession()
            const fileIds = []

            if (imageBuffer) {
                const fileId = await uploadImage(session.nonce, imageBuffer)
                if (fileId) {
                    fileIds.push(fileId)
                }
            }

            if (!questionText && fileIds.length > 0) {
                questionText = "Jelaskan gambar ini"
            }
            
            const userName = m.pushName || "User"
            const systemPrompt = `Kamu adalah ${global.botname}, AI asisten yang friendly di grup. Gunakan bahasa Indonesia yang natural dan ramah. Sapa user dengan nama mereka jika memungkinkan.`
            
            const finalPrompt = `${systemPrompt}\n\nUser ${userName} bertanya: ${questionText}`

            const payload = {
                botId: "chatbot-qm966k",
                customId: null,
                session: session.sessionId,
                chatId: Math.random().toString(36).slice(2),
                contextId: 5410,
                messages: [
                    {
                        id: "start",
                        role: "assistant",
                        content: systemPrompt,
                        who: "AI: ",
                        timestamp: Date.now(),
                        key: "start"
                    }
                ],
                newMessage: finalPrompt,
                newFileId: null,
                newFileIds: fileIds,
                stream: false
            }

            const { data } = await axios.post(
                "https://chatgpt4online.org/wp-json/mwai-ui/v1/chats/submit",
                payload,
                {
                    headers: {
                        "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                        "Origin": "https://chatgpt4online.org",
                        "Referer": "https://chatgpt4online.org/",
                        "X-WP-Nonce": session.nonce,
                        "Accept": "application/json",
                        "Content-Type": "application/json"
                    }
                }
            )

            if (!data.success) throw new Error("AI response failed")

            const replyText = data.reply || "Maaf, saya tidak bisa menjawab saat ini."
            
            await m.reply(`ðŸ¤– *${global.botname} Assistant*\n\n${replyText}`)
            
        } catch (error) {
            console.error('Auto-AI Error:', error)
            await m.reply('âŒ Gagal menghubungi AI, coba lagi nanti.')
        }
        
        return
    }
}
if (!m.isGroup && global.onlyGroupMode && !isCreator && !fs.existsSync(sessionFile)) {
  return; 
}
if (m.isGroup) {
    try {
        if (!global.db) global.db = {};
        if (!global.db.groups) global.db.groups = {};
        if (!global.db.groups[m.chat]) {
            global.db.groups[m.chat] = {
                botJoinTime: Date.now(),
                users: {}
            };
        }
        
        let userJid = m.sender;
        
        if (userJid.endsWith('@lid')) {
            try {
                const groupMetadata = await alip.groupMetadata(m.chat);
                const participant = groupMetadata.participants.find(p => p.id === userJid);
                if (participant && participant.jid) {
                    userJid = participant.jid;
                } else {
                    userJid = userJid.replace('@lid', '@s.whatsapp.net');
                }
            } catch (e) {
                userJid = userJid.replace('@lid', '@s.whatsapp.net');
            }
        }
        
        if (!userJid.endsWith('@s.whatsapp.net')) {
            userJid = userJid + '@s.whatsapp.net';
        }
        
        const currentTime = Date.now();
        const userName = m.pushName || userJid.split('@')[0];
        
        if (!global.db.groups[m.chat].users) {
            global.db.groups[m.chat].users = {};
        }
        
        if (!global.db.groups[m.chat].users[userJid]) {
            global.db.groups[m.chat].users[userJid] = {
                messages: 0,
                lastMessage: currentTime,
                name: userName,
                firstSeen: currentTime
            };
        }
        
        global.db.groups[m.chat].users[userJid].messages += 1;
        global.db.groups[m.chat].users[userJid].lastMessage = currentTime;
        global.db.groups[m.chat].users[userJid].name = userName;
        
    } catch (trackError) {
    }
}
//=========================
const warnDBPath = './library/database/warnings.json';
const warnDir = path.dirname(warnDBPath);

if (!fs.existsSync(warnDir)) {
    fs.mkdirSync(warnDir, { recursive: true });
}

if (!fs.existsSync(warnDBPath)) {
    fs.writeFileSync(warnDBPath, JSON.stringify({}));
}

function loadWarnDB() {
    try {
        const data = fs.readFileSync(warnDBPath, 'utf8');
        return JSON.parse(data);
    } catch (e) {
        return {};
    }
}

function saveWarnDB(data) {
    fs.writeFileSync(warnDBPath, JSON.stringify(data, null, 2));
}
// ================== STREAK FEATURE ==================
const streakDBPath = './library/database/streaks.json';
if (!fs.existsSync(streakDBPath)) {
    fs.writeFileSync(streakDBPath, JSON.stringify({}));
}

function loadStreaks() {
    try {
        return JSON.parse(fs.readFileSync(streakDBPath, 'utf8'));
    } catch (e) {
        console.error("Error membaca streaks.json, mereset file.", e);
        fs.writeFileSync(streakDBPath, JSON.stringify({}));
        return {};
    }
}

function saveStreaks(data) {
    fs.writeFileSync(streakDBPath, JSON.stringify(data, null, 2));
}


function getStreakKey(jid1, jid2) {
    const normalizeJid = (jid) => jid.replace('@lid', '@s.whatsapp.net');
    const users = [normalizeJid(jid1), normalizeJid(jid2)].sort();
    return `${users[0]}:${users[1]}`;
}

function getFinalJid(m, targetId) {
    let finalJid = targetId;
    if (m.isGroup && m.metadata && m.metadata.participants) {
        const participant = m.metadata.participants.find(p => p.id === targetId);
        if (participant) {
            finalJid = participant.jid;
        }
    }
    if (finalJid && finalJid.endsWith('@lid')) {
        finalJid = finalJid.replace('@lid', '@s.whatsapp.net');
    }
    return finalJid || targetId;
}
class AuthGenerator {
    static #PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDa2oPxMZe71V4dw2r8rHWt59gH\nW5INRmlhepe6GUanrHykqKdlIB4kcJiu8dHC/FJeppOXVoKz82pvwZCmSUrF/1yr\nrnmUDjqUefDu8myjhcbio6CnG5TtQfwN2pz3g6yHkLgp8cFfyPSWwyOCMMMsTU9s\nsnOjvdDb4wiZI8x3UwIDAQAB\n-----END PUBLIC KEY-----`;
    static #S = 'NHGNy5YFz7HeFb'
    
    constructor(appId) {
        this.appId = appId;
    }
    
    aesEncrypt(data, key, iv) {
        const keyBuffer = Buffer.from(key, 'utf8');
        const ivBuffer = Buffer.from(iv, 'utf8');
        const cipher = crypto.createCipheriv('aes-128-cbc', keyBuffer, ivBuffer);
        
        let encrypted = cipher.update(data, 'utf8', 'base64');
        encrypted += cipher.final('base64');
        return encrypted;
    }
    
    generateRandomString(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        const randomBytes = crypto.randomBytes(length);
        for (let i = 0; i < length; i++) {
            result += chars.charAt(randomBytes[i] % chars.length);
        }
        return result;
    }
    
    generate() {
        const t = Math.floor(Date.now() / 1000).toString()
        const nonce = crypto.randomUUID();
        const tempAesKey = this.generateRandomString(16);

        const encryptedData = crypto.publicEncrypt({
            key: AuthGenerator.#PUBLIC_KEY,
            padding: crypto.constants.RSA_PKCS1_PADDING,
        }, Buffer.from(tempAesKey));
        const secret_key = encryptedData.toString('base64');

        const dataToSign = `${this.appId}:${AuthGenerator.#S}:${t}:${nonce}:${secret_key}`;
        const sign = this.aesEncrypt(dataToSign, tempAesKey, tempAesKey);
        
        return {
            app_id: this.appId,
            t: t,
            nonce: nonce,
            sign: sign,
            secret_key: secret_key,
        };
    }
}

async function convert(buffer, prompt) {
    try {
        const auth = new AuthGenerator('ai_df');
        const authData = auth.generate();
        const userId = auth.generateRandomString(64).toLowerCase();
        
        const headers = {
            'Access-Control-Allow-Credentials': 'true',
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Android 15; Mobile; SM-F958; rv:130.0) Gecko/130.0 Firefox/130.0',
            'Referer': 'https://deepfakemaker.io/nano-banana-ai/'
        };
        
        const instance = axios.create({
            baseURL: 'https://apiv1.deepfakemaker.io/api',
            params: authData,
            headers
        });
        
        const file = await instance.post('/user/v2/upload-sign', {
            'filename': auth.generateRandomString(32) + '_' + Date.now() + '.jpg',
            'hash': crypto.createHash('sha256').update(buffer).digest('hex'),
            'user_id': userId
        }).then(i => i.data);
        
        await axios.put(file.data.url, buffer, {
            headers: {
                'content-type': 'image/jpeg',
                'content-length': buffer.length
            }
        });
        
        const taskData = await instance.post('/replicate/v1/free/nano/banana/task', {
            'prompt': prompt,
            'platform': 'nano_banana',
            'images': [ 'https://cdn.deepfakemaker.io/' + file.data.object_name ],
            'output_format': 'png',
            'user_id': userId
        }).then(i => i.data);
        
        const progress = await new Promise((resolve, reject) => {
            let retries = 20, c = 1;
            const interval = setInterval(async () => {
                const xz = await instance.get('/replicate/v1/free/nano/banana/task', {
                    params: {
                        user_id: userId,
                        ...taskData.data
                    }
                }).then(i => i.data);
                
                if (xz.msg === 'success') {
                    clearInterval(interval);
                    resolve(xz.data.generate_url);
                }
                if (--retries <= 0) {
                    clearInterval(interval);
                    reject(new Error('Failed to get task.'));
                }
                c++
            }, 2500);
        });
        
        return progress;
    } catch (error) {
        throw new Error(error.message);
    }
}

async function generateAndSendCertificate(recipientName, achievementText) {
    const { createCanvas, loadImage, registerFont } = require("canvas");
    try {
    } catch (error) {
        console.log('Using default fonts');
    }

    const width = 1400;
    const height = 1000;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext("2d");
    const parchmentGradient = ctx.createLinearGradient(0, 0, width, height);
    parchmentGradient.addColorStop(0, '#fbf6e5');
    parchmentGradient.addColorStop(0.3, '#f8f1d8');
    parchmentGradient.addColorStop(0.7, '#f5ebcc');
    parchmentGradient.addColorStop(1, '#f2e4bf');
    ctx.fillStyle = parchmentGradient;
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = 'rgba(200, 180, 140, 0.1)';
    for (let i = 0; i < 500; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const size = Math.random() * 4 + 1;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    const borderWidth = 30;
    const borderColor = '#8B4513';
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 8;
    ctx.strokeRect(borderWidth, borderWidth, width - borderWidth * 2, height - borderWidth * 2);
    ctx.strokeStyle = '#A0522D';
    ctx.lineWidth = 2;
    ctx.strokeRect(borderWidth + 20, borderWidth + 20, width - (borderWidth + 20) * 2, height - (borderWidth + 20) * 2);
    const drawCornerOrnament = (x, y, rotation) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 20);
        ctx.arc(15, 15, 10, Math.PI, Math.PI * 1.5);
        ctx.stroke();
        
        ctx.restore();
    };
    drawCornerOrnament(borderWidth + 25, borderWidth + 25, 0);
    drawCornerOrnament(width - borderWidth - 25, borderWidth + 25, Math.PI / 2);
    drawCornerOrnament(width - borderWidth - 25, height - borderWidth - 25, Math.PI);
    drawCornerOrnament(borderWidth + 25, height - borderWidth - 25, -Math.PI / 2);
    const headerY = 120;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    ctx.font = 'bold 72px "Times New Roman", "Georgia", serif';
    ctx.fillStyle = '#8B4513';
    ctx.textAlign = 'center';
    ctx.fillText('SERTIFIKAT PENGHARGAAN', width / 2, headerY);

    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.font = 'italic 38px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.fillText('Certificate of Achievement', width / 2, headerY + 50);
    const sep1Y = headerY + 90;
    drawDecorativeSeparator(ctx, width / 2 - 150, sep1Y, 300);
    const contentStartY = headerY + 150;
    ctx.font = '32px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.fillText('Dengan ini menyatakan bahwa', width / 2, contentStartY);
    const nameY = contentStartY + 100;
    ctx.strokeStyle = '#D4AF37';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(width / 2 - 250, nameY + 40);
    ctx.lineTo(width / 2 + 250, nameY + 40);
    ctx.stroke();
    ctx.font = 'bold 64px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#8B4513';
    ctx.fillText(recipientName, width / 2, nameY + 30);
    const achievementY = nameY + 100;
    
    ctx.font = '28px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.fillText('Telah menunjukkan prestasi luar biasa dalam', width / 2, achievementY);
    const achievementTextY = achievementY + 60;
    
    ctx.font = 'italic bold 36px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#8B4513';
    
    const words = achievementText.split(' ');
    let line = '';
    let lines = [];
    const maxWidth = 800;
    
    for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && i > 0) {
            lines.push(line);
            line = words[i] + ' ';
        } else {
            line = testLine;
        }
    }
    lines.push(line);
    lines.forEach((line, index) => {
        ctx.fillText(line, width / 2, achievementTextY + (index * 45));
    });
    const sep2Y = achievementTextY + (lines.length * 45) + 40;
    drawDecorativeSeparator(ctx, width / 2 - 120, sep2Y, 240);
    const detailsY = sep2Y + 80;
    const today = new Date();
    const formattedDate = today.toLocaleDateString('id-ID', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });

    ctx.font = '24px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.textAlign = 'left';
    ctx.fillText('Diberikan pada tanggal:', width / 4 - 100, detailsY);

    ctx.font = 'bold 26px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#8B4513';
    ctx.fillText(formattedDate, width / 4 - 100, detailsY + 40);
    const certId = `CERT-${Date.now().toString().slice(-8).toUpperCase()}`;
    
    ctx.font = '24px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.textAlign = 'right';
    ctx.fillText('Nomor Sertifikat:', width * 3/4 + 100, detailsY);

    ctx.font = 'bold 26px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#8B4513';
    ctx.fillText(certId, width * 3/4 + 100, detailsY + 40);
    const signatureY = detailsY + 100;
    const sealX = width / 2;
    const sealY = signatureY + 60;
    drawOfficialSeal(ctx, sealX, sealY, 80);
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width / 2 - 150, signatureY + 120);
    ctx.lineTo(width / 2 + 150, signatureY + 120);
    ctx.stroke();
    ctx.font = 'bold 28px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#8B4513';
    ctx.textAlign = 'center';
    ctx.fillText(global.botname, width / 2, signatureY + 160);

    ctx.font = '20px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#654321';
    ctx.fillText('Direktur Utama', width / 2, signatureY + 190);
    const footerY = height - 80;
    
    ctx.font = 'italic 18px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#888888';
    ctx.textAlign = 'center';
    ctx.fillText('Sertifikat ini diterbitkan secara digital dan dapat diverifikasi keasliannya', width / 2, footerY);
    ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(15, 15, width - 30, height - 30);
    const buffer = canvas.toBuffer("image/png");
    
    const caption = `ðŸ›ï¸ *SERTIFIKAT RESMI* ðŸ›ï¸\n\n` +
                  `Dengan hormat kami persembahkan sertifikat penghargaan kepada:\n\n` +
                  `ðŸ‘¤ *Penerima:* ${recipientName}\n` +
                  `ðŸŽ–ï¸ *Prestasi:* ${achievementText}\n` +
                  `ðŸ“… *Tanggal:* ${formattedDate}\n` +
                  `ðŸ†” *Nomor Sertifikat:* ${certId}\n\n` +
                  `_Sertifikat ini diterbitkan secara resmi oleh ${global.botname}_\n` +
                  `_dan merupakan pengakuan atas prestasi yang membanggakan._`;

    await alip.sendMessage(
        m.chat,
        {
            image: buffer,
            caption: caption
        },
        { quoted: m }
    );
}

function drawDecorativeSeparator(ctx, x, y, length) {
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + length, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.arc(x + length, y, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#8B4513';
    ctx.fill();
}

function drawOfficialSeal(ctx, x, y, size) {
    ctx.strokeStyle = '#DC143C';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.stroke();
    ctx.strokeStyle = '#DC143C';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, size - 10, 0, Math.PI * 2);
    ctx.stroke();
    ctx.save();
    ctx.font = 'bold 16px "Georgia", "Times New Roman", serif';
    ctx.fillStyle = '#DC143C';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('TERVERIFIKASI', x, y - 10);
    ctx.fillText('OFFICIAL', x, y + 5);
    ctx.fillText('SEAL', x, y + 20);
    
    ctx.restore();
    ctx.fillStyle = '#DC143C';
    drawStar(ctx, x, y, 8, 15, 5);
}

function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
}

function setPremium(user, days) {
  if (!db.data.users) db.data.users = {};
  const now = Date.now();
  const expires = now + days * 24 * 60 * 60 * 1000;

  db.data.users[user] = {
    ...(db.data.users[user] || {}),
    premium: true,
    premium_expired: expires
  };
}

//============== [ MESSAGE ] ================================================

if (m.isGroup && global.db.groups[m.chat] && global.db.groups[m.chat].mute == true && !isCreator) return
const isOnlyAdminMode = m.isGroup && global.db.groups[m.chat]?.onlyAdminMode;
if (isCmd && m.isGroup && isOnlyAdminMode && !m.isAdmin && !isCreator) {
    return
}


if (m.isGroup && global.db.groups[m.chat] && global.db.groups[m.chat].mute == true && !isCreator) return
try {
  if (isCmd) {
    console.log(
      chalk.hex('#FF0080').bold('â•”â•â•â•âœ¦ ') +
      chalk.hex('#FF0000').bold('COMMAND TRIGGERED') +

      '\n' + chalk.hex('#FF0080').bold('â•‘') + ' ' + chalk.hex('#FFFFFF').bold(`âŒ¨ï¸  COMMAND: ${prefix}${command}`) +
      '\n' + chalk.hex('#FF0080').bold('â•‘') + ' ' + chalk.hex('#FF80ED').bold(`ðŸ‘¤  USER: ${m.sender.split("@")[0]}`) + ' ' + chalk.hex('#00FFEA').bold(m.isGroup ? '[GROUP]' : '[PRIVATE]') +
      '\n' + chalk.hex('#FF0080').bold('â•‘') + ' ' + chalk.hex('#A5FF90').bold(`ðŸ’¬  MESSAGE: ${m.text || '[NO TEXT]'}`) +
      '\n' + chalk.hex('#FF0080').bold('â•‘') + ' ' + chalk.hex('#FF9E80').bold(`ðŸ†”  MSG ID: ${m.key?.id || 'UNKNOWN'}`) +
      '\n' + chalk.hex('#FF0080').bold('â•‘') + ' ' + chalk.hex('#80B3FF').bold(`ðŸ“±  DEVICE: ${m.device || 'UNKNOWN'}`) +
      '\n' + chalk.hex('#FF0080').bold('â•šâ•â•â•âœ¦')
    );
  }
} catch (err) {
  console.log(chalk.hex('#FF0000').bold('âš¡ [COMMAND LOG FAILED]'), err);
}
//============= [ FAKEQUOTED ] ===============================================

const qtext = {key: {remoteJid: "status@broadcast", participant: "0@s.whatsapp.net"}, message: {"extendedTextMessage": {"text": `${prefix+command}`}}}

const qtext2 = {key: {remoteJid: "status@broadcast", participant: "0@s.whatsapp.net"}, message: {"extendedTextMessage": {"text": `${namaOwner}`}}}

const qlocJpm = {key: {participant: '0@s.whatsapp.net', ...(m.chat ? {remoteJid: `status@broadcast`} : {})}, message: {locationMessage: {name: `${namaOwner}`,jpegThumbnail: ""}}}

const qlocPush = {key: {participant: '0@s.whatsapp.net', ...(m.chat ? {remoteJid: `status@broadcast`} : {})}, message: {locationMessage: {name: `${namaOwner}`,jpegThumbnail: ""}}}

const qpayment = {key: {remoteJid: '0@s.whatsapp.net', fromMe: false, id: `ownername`, participant: '0@s.whatsapp.net'}, message: {requestPaymentMessage: {currencyCodeIso4217: "USD", amount1000: 999999999, requestFrom: '0@s.whatsapp.net', noteMessage: { extendedTextMessage: { text: `${botname2}`}}, expiryTimestamp: 999999999, amount: {value: 91929291929, offset: 1000, currencyCode: "USD"}}}}

const qtoko = {key: {fromMe: false, participant: `0@s.whatsapp.net`, ...(m.chat ? {remoteJid: "status@broadcast"} : {})}, message: {"productMessage": {"product": {"productImage": {"mimetype": "image/jpeg", "jpegThumbnail": ""}, "title": `${namaOwner} - Marketplace`, "description": null, "currencyCode": "IDR", "priceAmount1000": "999999999999999", "retailerId": `Powered By ${namaOwner}`, "productImageCount": 1}, "businessOwnerJid": `0@s.whatsapp.net`}}}

const qlive = {key: {participant: '0@s.whatsapp.net', ...(m.chat ? {remoteJid: `status@broadcast`} : {})}, message: {liveLocationMessage: {caption: `${botname2} by ${namaOwner}`,jpegThumbnail: ""}}}

const Reply = async (teks, mentions = [m.sender]) => {
  return alip.sendMessage(m.chat, {
    text: teks,
    contextInfo: {
      mentionedJid: mentions, 
      isForwarded: true,
      forwardingScore: 9999,
      businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
      forwardedNewsletterMessageInfo: { 
        newsletterName: namaSaluran, 
        newsletterJid: global.idSaluran 
      },
      externalAdReply: {
        title: `ðŸ’¢ â€” ${botname} v${versi}`,
        body: `Â© Powered by ${namaOwner}`,
        thumbnailUrl: global.image?.reply || null,
        sourceUrl: global.linkMenu || null,
        mediaType: 1
      }
    }
  }, { quoted: m });
}

// ================== [ ANTI-BOT ] ==================
if (m.isGroup && global.db.groups[m.chat]?.antibot && !isCreator && !m.key.fromMe) {
    let isBotDetected = false;
    
    if (m.device) {
        const device = m.device.toLowerCase();
        if (device === 'web' || device === 'desktop') {
            isBotDetected = true;
        }
    }
    
    if (isBotDetected) {
        if (!m.isBotAdmin) {
            await alip.sendMessage(m.chat, {
                text: `âš ï¸ Tidak bisa menghapus bot karena saya bukan admin.`
            })
            return
        }
        
        try {
            const teks = `ðŸ¤– @${m.sender.split('@')[0]} Terdeteksi bot dengan device "${m.device}". Pesan dihapus.`;
            
            await alip.sendMessage(m.chat, {
                text: teks,
                contextInfo: {
                    mentionedJid: [m.sender], 
                    isForwarded: true,
                    forwardingScore: 9999,
                    businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                    forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                    externalAdReply: {
                        title: botname,
                        body: `Â© Powered by ${namaOwner}`,
                        thumbnailUrl: global.image?.reply || null,
                        sourceUrl: global.linkMenu || null
                    }
                }
            }, { quoted: m })
            
            await alip.sendMessage(m.chat, { delete: m.key })
            
        } catch (error) {
            await alip.sendMessage(m.chat, {
                text: `âŒ Gagal menghapus bot. Pastikan saya admin dan memiliki izin.`
            })
        }
    }
}

// ================== [ ANTI-BOT KICK ] ==================
if (m.isGroup && global.db.groups[m.chat]?.antibotkick && !isCreator && !m.key.fromMe) {
    let isBotDetected = false;
    
    if (m.device) {
        const device = m.device.toLowerCase();
        if (device === 'web' || device === 'desktop') {
            isBotDetected = true;
        }
    }
    
    if (isBotDetected) {
        if (!m.isBotAdmin) {
            const teks = `âš ï¸ @${m.sender.split('@')[0]} Tidak bisa menghapus/kick bot karena saya bukan admin.`;
            
            await alip.sendMessage(m.chat, {
                text: teks,
                contextInfo: {
                    mentionedJid: [m.sender], 
                    isForwarded: true,
                    forwardingScore: 9999,
                    businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                    forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                    externalAdReply: {
                        title: botname,
                        body: `Â© Powered by ${namaOwner}`,
                        thumbnailUrl: global.image?.reply || null,
                        sourceUrl: global.linkMenu || null
                    }
                }
            }, { quoted: m })
            return
        }
        
        if (!global.warningBotDB) global.warningBotDB = {};
        if (!global.warningBotDB[m.chat]) global.warningBotDB[m.chat] = {};
        
        const userKey = m.sender;
        let userWarnings = global.warningBotDB[m.chat][userKey] || 0;
        userWarnings++;
        global.warningBotDB[m.chat][userKey] = userWarnings;
        
        if (userWarnings < 3) {
            const teks = `ðŸ¤– @${m.sender.split('@')[0]} Terdeteksi bot dengan device "${m.device}"!\nPeringatan: ${userWarnings}/3\nPesan akan dihapus.`;
            
            await alip.sendMessage(m.chat, {
                text: teks,
                contextInfo: {
                    mentionedJid: [m.sender], 
                    isForwarded: true,
                    forwardingScore: 9999,
                    businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                    forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                    externalAdReply: {
                        title: botname,
                        body: `Â© Powered by ${namaOwner}`,
                        thumbnailUrl: global.image?.reply || null,
                        sourceUrl: global.linkMenu || null
                    }
                }
            }, { quoted: m })
            
            await alip.sendMessage(m.chat, { delete: m.key })
            
        } else {
            const teks = `ðŸš¨ @${m.sender.split('@')[0]} Terdeteksi bot dengan device "${m.device}"!\nPeringatan ke-3 tercapai!\nKamu akan dikeluarkan dari grup.`;
            
            await alip.sendMessage(m.chat, {
                text: teks,
                contextInfo: {
                    mentionedJid: [m.sender], 
                    isForwarded: true,
                    forwardingScore: 9999,
                    businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                    forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                    externalAdReply: {
                        title: botname,
                        body: `Â© Powered by ${namaOwner}`,
                        thumbnailUrl: global.image?.reply || null,
                        sourceUrl: global.linkMenu || null
                    }
                }
            }, { quoted: m })
            
            await alip.sendMessage(m.chat, { delete: m.key })
            
            try {
                await alip.groupParticipantsUpdate(m.chat, [m.sender], 'remove')
                delete global.warningBotDB[m.chat][userKey];
                
            } catch (error) {
                const teks = `âŒ Gagal mengeluarkan @${m.sender.split('@')[0]}. Pastikan saya memiliki izin admin.`;
                
                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: [m.sender], 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })
            }
        }
    }
}
//============== ANTI SPAM & ANTI TAG SW & MEDIA ======================
try {
    if (m.isGroup && m.sender && !m.fromMe && !isCreator && !m.isAdmin) {
        const groupDB = global.db.groups[m.chat]
        const user = m.sender
        if (m.isBotAdmin) {
            
if (groupDB?.antispam) {
    const now = Date.now()
    
    if (!global.spamWarnings) global.spamWarnings = {}
    if (!global.lastMessages) global.lastMessages = {}
    if (!global.spamWarnings[m.chat]) global.spamWarnings[m.chat] = {}
    if (!global.lastMessages[m.chat]) global.lastMessages[m.chat] = {}
    
    const userWarnings = global.spamWarnings[m.chat][user] || 0
    const userLastMsg = global.lastMessages[m.chat][user] || { time: 0, count: 0 }
    
    const timeDiff = now - userLastMsg.time
    
    if (timeDiff < 2000) {
        userLastMsg.count++
        
        if (userLastMsg.count >= 3) {
            global.spamWarnings[m.chat][user] = userWarnings + 1
            const totalWarnings = global.spamWarnings[m.chat][user]
            
            if (totalWarnings <= 2) {
                const teks = `âš ï¸ @${user.split('@')[0]} Terdeteksi spam!\nPeringatan: ${totalWarnings}/3\nPesan akan dihapus.`
                const mentions = [user]

                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                try {
                    await alip.sendMessage(m.chat, { delete: m.key })
                } catch (error) {}
                
            } else {
                const teks = `ðŸš¨ @${user.split('@')[0]} Telah mencapai 3 peringatan spam!\nKamu akan dikeluarkan dari grup.`
                const mentions = [user]

                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                try {
                    if (m.isBotAdmin) {
                        await alip.groupParticipantsUpdate(m.chat, [user], 'remove')
                    }
                } catch (error) {}
                
                delete global.spamWarnings[m.chat][user]
                delete global.lastMessages[m.chat][user]
            }
            
            userLastMsg.count = 0
            return
        }
    } else {
        userLastMsg.count = 1
    }
    
    userLastMsg.time = now
    global.lastMessages[m.chat][user] = userLastMsg
}
            if (groupDB?.antitagsw && m.message?.groupStatusMentionMessage) {
                const teks = `âš ï¸ @${user.split('@')[0]} Terdeteksi Menandai Grup ke Status! Pesan akan dihapus.`
                const mentions = [user]

                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                await alip.sendMessage(m.chat, { delete: m.key })
                
            } else if (groupDB?.antitagswkick && m.message?.groupStatusMentionMessage) {
                if (!global.warningDB) global.warningDB = {}
                if (!global.warningDB[m.chat]) global.warningDB[m.chat] = {}
                
                const userKey = user
                let userWarnings = global.warningDB[m.chat][userKey] || 0
                userWarnings++
                global.warningDB[m.chat][userKey] = userWarnings
                
                if (userWarnings < 3) {
                    const teks = `âš ï¸ @${user.split('@')[0]} Terdeteksi Menandai Grup ke Status!\nPeringatan: ${userWarnings}/3\nPesan akan dihapus.`
                    const mentions = [user]

                    await alip.sendMessage(m.chat, {
                        text: teks,
                        contextInfo: {
                            mentionedJid: mentions, 
                            isForwarded: true,
                            forwardingScore: 9999,
                            businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                            forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                            externalAdReply: {
                                title: botname,
                                body: `Â© Powered by ${namaOwner}`,
                                thumbnailUrl: global.image?.reply || null,
                                sourceUrl: global.linkMenu || null
                            }
                        }
                    }, { quoted: m })

                    await alip.sendMessage(m.chat, { delete: m.key })
                } else {
                    const teks = `ðŸš¨ @${user.split('@')[0]} Terdeteksi Menandai Grup ke Status!\nPeringatan ke-3 tercapai!\nKamu akan dikeluarkan dari grup.`
                    const mentions = [user]

                    await alip.sendMessage(m.chat, {
                        text: teks,
                        contextInfo: {
                            mentionedJid: mentions, 
                            isForwarded: true,
                            forwardingScore: 9999,
                            businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                            forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                            externalAdReply: {
                                title: botname,
                                body: `Â© Powered by ${namaOwner}`,
                                thumbnailUrl: global.image?.reply || null,
                                sourceUrl: global.linkMenu || null
                            }
                        }
                    }, { quoted: m })

                    await alip.sendMessage(m.chat, { delete: m.key })
                    
                    try {
                        await alip.groupParticipantsUpdate(m.chat, [user], 'remove')
                        delete global.warningDB[m.chat][userKey]
                    } catch (kickError) {
                        await alip.sendMessage(m.chat, {
                            text: `âŒ Gagal mengeluarkan @${user.split('@')[0]}. Pastikan saya memiliki izin admin.`,
                            mentions: [user]
                        })
                    }
                }
            }

            if (groupDB?.antilinkAll && m.text) {
                const regexAllLinks = /(https?:\/\/[^\s]+)/gi
                const isThisGroupLink = async (text, chatId) => {
                    try {
                        const gclink = `https://chat.whatsapp.com/${await alip.groupInviteCode(chatId)}`
                        const isLinkThisGc = new RegExp(gclink, 'i')
                        return isLinkThisGc.test(text)
                    } catch {
                        return false
                    }
                }
                
                const hasLink = regexAllLinks.test(m.text)
                const isOwnGroupLink = await isThisGroupLink(m.text, m.chat)
                
                if (hasLink && !isOwnGroupLink) {
                    if (!global.warningDB) global.warningDB = {}
                    if (!global.warningDB[m.chat]) global.warningDB[m.chat] = {}
                    
                    const userKey = user
                    let userWarnings = global.warningDB[m.chat][userKey] || 0
                    userWarnings++
                    global.warningDB[m.chat][userKey] = userWarnings
                    
                    if (userWarnings < 3) {
                        const teks = `âš ï¸ @${user.split('@')[0]} Terdeteksi mengirim link!\nPeringatan: ${userWarnings}/3\nPesan akan dihapus.`
                        const mentions = [user]

                        await alip.sendMessage(m.chat, {
                            text: teks,
                            contextInfo: {
                                mentionedJid: mentions, 
                                isForwarded: true,
                                forwardingScore: 9999,
                                businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                                forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                                externalAdReply: {
                                    title: botname,
                                    body: `Â© Powered by ${namaOwner}`,
                                    thumbnailUrl: global.image?.reply || null,
                                    sourceUrl: global.linkMenu || null
                                }
                            }
                        }, { quoted: m })

                        await alip.sendMessage(m.chat, { delete: m.key })
                    } else {
                        const teks = `ðŸš¨ @${user.split('@')[0]} Terdeteksi mengirim link!\nPeringatan ke-3 tercapai!\nKamu akan dikeluarkan dari grup.`
                        const mentions = [user]

                        await alip.sendMessage(m.chat, {
                            text: teks,
                            contextInfo: {
                                mentionedJid: mentions, 
                                isForwarded: true,
                                forwardingScore: 9999,
                                businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                                forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                                externalAdReply: {
                                    title: botname,
                                    body: `Â© Powered by ${namaOwner}`,
                                    thumbnailUrl: global.image?.reply || null,
                                    sourceUrl: global.linkMenu || null
                                }
                            }
                        }, { quoted: m })

                        await alip.sendMessage(m.chat, { delete: m.key })
                        
                        try {
                            await alip.groupParticipantsUpdate(m.chat, [user], 'remove')
                            delete global.warningDB[m.chat][userKey]
                        } catch (kickError) {
                            await alip.sendMessage(m.chat, {
                                text: `âŒ Gagal mengeluarkan @${user.split('@')[0]}. Pastikan saya memiliki izin admin.`,
                                mentions: [user]
                            })
                        }
                    }
                }
            }

            if (groupDB?.antilinkCapcut && m.text) {
                const capcutRegex = /(https?:\/\/)?(www\.)?capcut\.com/i
                if (capcutRegex.test(m.text)) {
                    if (!global.warningDB) global.warningDB = {}
                    if (!global.warningDB[m.chat]) global.warningDB[m.chat] = {}
                    
                    const userKey = user
                    let userWarnings = global.warningDB[m.chat][userKey] || 0
                    userWarnings++
                    global.warningDB[m.chat][userKey] = userWarnings
                    
                    if (userWarnings < 3) {
                        const teks = `âš ï¸ @${user.split('@')[0]} Terdeteksi mengirim link CapCut!\nPeringatan: ${userWarnings}/3\nPesan akan dihapus.`
                        const mentions = [user]

                        await alip.sendMessage(m.chat, {
                            text: teks,
                            contextInfo: {
                                mentionedJid: mentions, 
                                isForwarded: true,
                                forwardingScore: 9999,
                                businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                                forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                                externalAdReply: {
                                    title: botname,
                                    body: `Â© Powered by ${namaOwner}`,
                                    thumbnailUrl: global.image?.reply || null,
                                    sourceUrl: global.linkMenu || null
                                }
                            }
                        }, { quoted: m })

                        await alip.sendMessage(m.chat, { delete: m.key })
                    } else {
                        const teks = `ðŸš¨ @${user.split('@')[0]} Terdeteksi mengirim link CapCut!\nPeringatan ke-3 tercapai!\nKamu akan dikeluarkan dari grup.`
                        const mentions = [user]

                        await alip.sendMessage(m.chat, {
                            text: teks,
                            contextInfo: {
                                mentionedJid: mentions, 
                                isForwarded: true,
                                forwardingScore: 9999,
                                businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                                forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                                externalAdReply: {
                                    title: botname,
                                    body: `Â© Powered by ${namaOwner}`,
                                    thumbnailUrl: global.image?.reply || null,
                                    sourceUrl: global.linkMenu || null
                                }
                            }
                        }, { quoted: m })

                        await alip.sendMessage(m.chat, { delete: m.key })
                        
                        try {
                            await alip.groupParticipantsUpdate(m.chat, [user], 'remove')
                            delete global.warningDB[m.chat][userKey]
                        } catch (kickError) {
                            await alip.sendMessage(m.chat, {
                                text: `âŒ Gagal mengeluarkan @${user.split('@')[0]}. Pastikan saya memiliki izin admin.`,
                                mentions: [user]
                            })
                        }
                    }
                }
            }

            if (groupDB?.antivideo && m.type === 'videoMessage') {
                const teks = `ðŸŽ¥ @${user.split('@')[0]}, dilarang mengirim video di grup ini! Pesan akan dihapus.`
                const mentions = [user]
                
                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                await alip.sendMessage(m.chat, { delete: m.key })
            }

            if (groupDB?.antifoto && m.type === 'imageMessage') {
                const teks = `ðŸ–¼ï¸ @${user.split('@')[0]}, dilarang mengirim foto di grup ini! Pesan akan dihapus.`
                const mentions = [user]

                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })
                
                await alip.sendMessage(m.chat, { delete: m.key })
            }

            if (groupDB?.antiaudio && m.type === 'audioMessage') {
                const teks = `ðŸŽµ @${user.split('@')[0]}, dilarang mengirim audio di grup ini! Pesan akan dihapus.`
                const mentions = [user]
                
                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                await alip.sendMessage(m.chat, { delete: m.key })
            }

            if (groupDB?.antivirtex && m.type === 'stickerMessage') {
                const teks = `ðŸŒ€ @${user.split('@')[0]}, dilarang mengirim virtex/sticker di grup ini! Pesan akan dihapus.`
                const mentions = [user]
                
                await alip.sendMessage(m.chat, {
                    text: teks,
                    contextInfo: {
                        mentionedJid: mentions, 
                        isForwarded: true,
                        forwardingScore: 9999,
                        businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
                        forwardedNewsletterMessageInfo: { newsletterName: botname, newsletterJid: global.idSaluran },
                        externalAdReply: {
                            title: botname,
                            body: `Â© Powered by ${namaOwner}`,
                            thumbnailUrl: global.image?.reply || null,
                            sourceUrl: global.linkMenu || null
                        }
                    }
                }, { quoted: m })

                await alip.sendMessage(m.chat, { delete: m.key })
            }
        }
    }
} catch (err) {
}


// ========= SAMBUNG KATA LOGIC =============
if (m.isGroup && isWordSubmission(m, body, prefix)) {
     await handleWordSubmission(alip, m, body);
     return; 
}
// ============================================



if (isCmd && command && !allCommands.includes(command)) {
    let bestMatch = null;
    let minDistance = Infinity;
    const typoThreshold = 2; 

    for (const cmd of allCommands) {
        const distance = levenshtein(command, cmd);
        if (distance < minDistance) {
            minDistance = distance;
            bestMatch = cmd;
        }
    }

    if (bestMatch && minDistance <= typoThreshold) {
        const similarity = Math.max(0, Math.min(100, Math.round(((command.length - minDistance) / command.length) * 100)));
        const teks = `
ðŸŽ€ á´„á´á´á´á´€É´á´… Éªá´›á´œ á´›Éªá´…á´€á´‹ á´€á´…á´€,\ná´á´œÉ´É¢á´‹ÉªÉ´ Êá´€É´É¢ á´‹á´€á´á´œ á´á´€á´‹êœ±á´œá´…:\n
â”â” âŠ‘ *MUNGKIN INI* âŠ’
â”‚ â¤· Command : .${bestMatch}
â”‚ â¤· Kemiripan : ${similarity}% 
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`;

        await alip.sendMessage(m.chat, {
            footer: '',
            buttons: [
                {
                    buttonId: `.${bestMatch}`,
                    buttonText: { displayText: `${prefix}${bestMatch}` },
                    type: 1
                }
            ],
            headerType: 1,
            viewOnce: true,
            document: fs.readFileSync("./package.json"),
            fileName: `ã…¤`,
            mimetype: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            fileLength: 0,
            caption: teks,
            contextInfo: {
                mentionedJid: [m.sender],
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: idSaluran,
                    newsletterName: botname,
                    serverId: 200
                },
                externalAdReply: {
                    title: `${botname} v${versi}`,
                    body: `${global.namaOwner}`,
                    thumbnailUrl: global.image.menu,
                    sourceUrl: global.namaSaluran,
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        }, { quoted: m })
        return;
    }
}

// Handler untuk TTT 
if (!isCmd && m.isGroup && /^[1-9]$/.test(body.trim())) {
    await tictactoe.handleMove(m, body.trim(), Reply, alip);
    return;
}

if (!isCmd && global.mathQuizSessions && global.mathQuizSessions[m.sender]) {
    const session = global.mathQuizSessions[m.sender];
    if (!session.questions || session.questions.length === 0) {
        delete global.mathQuizSessions[m.sender];
        return Reply('âŒ Sesi kuis rusak, silakan mulai ulang.');
    }
    if (session.currentQuestion >= session.questions.length) {
        delete global.mathQuizSessions[m.sender];
        return Reply('âŒ Sesi kuis sudah selesai.');
    }
    
    const currentQuestion = session.questions[session.currentQuestion];
    
    if (m.text && m.text.toLowerCase() === 'stop') {
        const timeUsed = Math.floor((Date.now() - session.startTime) / 1000);
        const finalScore = session.score || 0;
        const maxScore = session.questions.reduce((sum, q) => sum + (q.points || 1), 0);
        const percentage = maxScore > 0 ? Math.round((finalScore / maxScore) * 100) : 0;
        
        let resultText = `ðŸ *KUIS SELESAI*\n\n`;
        resultText += `ðŸ“Š Hasil akhir:\n`;
        resultText += `â€¢ Skor: ${finalScore}/${maxScore} (${percentage}%)\n`;
        resultText += `â€¢ Waktu: ${Math.floor(timeUsed / 60)}:${(timeUsed % 60).toString().padStart(2, '0')}\n`;
        if (session.level) resultText += `â€¢ Level: ${session.level.toUpperCase()}\n\n`;
        
        if (percentage >= 80 && session.reward) {
            const bonusDB = safeReadJSON(limitBonusPath, {});
            const today = getWIBTime().toISOString().split('T')[0];
            
            if (!bonusDB[m.sender] || bonusDB[m.sender].date !== today) {
                bonusDB[m.sender] = { bonus: 0, date: today };
            }
            
            bonusDB[m.sender].bonus += session.reward;
            fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));
            
            resultText += `ðŸŽ‰ *SELAMAT!* ðŸŽ‰\n\n`;
            resultText += `Kamu mendapatkan hadiah *${session.reward} limit*!\n`;
            resultText += `Keren banget! ðŸ¤©`;
        } else if (percentage >= 60) {
            resultText += `ðŸ‘ *Lumayan!*\n\nCoba lagi untuk dapat hadiah!`;
        } else {
            resultText += `ðŸ˜… *Butuh latihan lagi*\n\nCoba level yang lebih mudah dulu!`;
        }
        
        delete global.mathQuizSessions[m.sender];
        return Reply(resultText);
    }
    
    if (!m.text) return; 
    
    let userAnswer = m.text.trim();
    let isCorrect = false;
    
    if (currentQuestion.choices && currentQuestion.choices.length > 0) {
        const choiceIndex = ['A', 'B', 'C', 'D'].indexOf(userAnswer.toUpperCase());
        if (choiceIndex !== -1 && choiceIndex < currentQuestion.choices.length) {
            userAnswer = currentQuestion.choices[choiceIndex];
        }
    }
    if (currentQuestion.answer) {
        if (userAnswer === currentQuestion.answer || 
            parseFloat(userAnswer) === parseFloat(currentQuestion.answer) ||
            (userAnswer && currentQuestion.answer && 
             userAnswer.replace('/', 'âˆ•') === currentQuestion.answer.replace('/', 'âˆ•'))) {
            
            isCorrect = true;
            session.score = (session.score || 0) + (currentQuestion.points || 1);
            if (!session.answers) session.answers = [];
            session.answers.push({ 
                question: currentQuestion.number || session.currentQuestion + 1, 
                correct: true 
            });
        } else {
            if (!session.answers) session.answers = [];
            session.answers.push({ 
                question: currentQuestion.number || session.currentQuestion + 1, 
                correct: false, 
                userAnswer: userAnswer 
            });
        }
    }
    
    const timeLeft = session.timeLimit ? session.timeLimit - (Date.now() - session.startTime) : 0;
    if (timeLeft <= 0) {
        const finalScore = session.score || 0;
        const maxScore = session.questions.reduce((sum, q) => sum + (q.points || 1), 0);
        
        Reply(`â° *WAKTU HABIS!*\n\nSkor akhir: ${finalScore}/${maxScore}\n${finalScore >= maxScore * 0.8 ? 'Coba lagi untuk dapat hadiah!' : 'Latihan lagi yuk!'}`);
        delete global.mathQuizSessions[m.sender];
        return;
    }
    
    session.currentQuestion = (session.currentQuestion || 0) + 1;
    
    if (session.currentQuestion >= session.questions.length) {
        const timeUsed = Math.floor((Date.now() - session.startTime) / 1000);
        const finalScore = session.score || 0;
        const maxScore = session.questions.reduce((sum, q) => sum + (q.points || 1), 0);
        const percentage = maxScore > 0 ? Math.round((finalScore / maxScore) * 100) : 0;
        
        let resultText = `ðŸŽŠ *SELESAI!*\n\n`;
        if (session.level) resultText += `ðŸ§® Level: ${session.level.toUpperCase()}\n`;
        resultText += `ðŸ“Š Skor: ${finalScore}/${maxScore} (${percentage}%)\n`;
        resultText += `â±ï¸ Waktu: ${Math.floor(timeUsed / 60)}:${(timeUsed % 60).toString().padStart(2, '0')}\n\n`;
        
        const correctAnswers = (session.answers || []).filter(a => a.correct).length;
        resultText += `âœ… Benar: ${correctAnswers}\nâŒ Salah: ${(session.answers || []).length - correctAnswers}\n\n`;
        
        if (percentage >= 80 && session.reward) {
            const bonusDB = safeReadJSON(limitBonusPath, {});
            const today = getWIBTime().toISOString().split('T')[0];
            
            if (!bonusDB[m.sender] || bonusDB[m.sender].date !== today) {
                bonusDB[m.sender] = { bonus: 0, date: today };
            }
            
            bonusDB[m.sender].bonus += session.reward;
            fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));
            
            resultText += `ðŸ† *HADIAH DAPAT!* ðŸ†\n\n`;
            resultText += `Kamu mendapatkan *${session.reward} limit*!\n`;
            resultText += `Kamu jenius! ðŸ§ âœ¨`;
        } else if (percentage >= 60) {
            resultText += `ðŸ‘ *Bagus!*\n\nHampir dapat hadiah, tingkatkan lagi!`;
        } else {
            resultText += `ðŸ’ª *Terus berlatih!*\n\nCoba level yang lebih mudah dulu.`;
        }
        
        delete global.mathQuizSessions[m.sender];
        return Reply(resultText);
    }
    const nextQuestion = session.questions[session.currentQuestion];
    if (!nextQuestion) {
        delete global.mathQuizSessions[m.sender];
        return Reply('âŒ Soal tidak ditemukan, sesi dihentikan.');
    }
    
    let questionText = `ðŸ§® *SOAL ${session.currentQuestion + 1}/${session.questions.length}*\n\n`;
    if (session.level) questionText += `ðŸ“Š Level: ${session.level.toUpperCase()}\n`;
    questionText += `â“ ${nextQuestion.question}\n\n`;
    
    if (nextQuestion.choices && nextQuestion.choices.length > 0) {
        questionText += `Pilihan:\n`;
        nextQuestion.choices.forEach((choice, index) => {
            questionText += `${String.fromCharCode(65 + index)}. ${choice}\n`;
        });
        questionText += `\n`;
    }
    
    questionText += `ðŸŽ¯ Poin: ${nextQuestion.points || 1}\n`;
    questionText += `ðŸ’¬ *Balas dengan jawabanmu!*\n`;
    questionText += `â¹ï¸ Ketik *stop* untuk berhenti`;
    await Reply(questionText);
    return;
}

//================= [ MUTE ] =================//
if (m.isGroup && db.groups[m.chat] && db.groups[m.chat].mute === true && !isCreator) return

//================= [ ANTILINK ] =================//
const regexLink = /(https?:\/\/)?(chat\.whatsapp\.com|wa\.me|whatsapp\.com(\/channel)?|buka\s?tautan\s?ini\s?untuk\s?bergabung\s?ke\s?grup\s?whatsapp)/gi
const isGcLink = async (text, chatId) => {
    try {
        const gclink = `https://chat.whatsapp.com/${await alip.groupInviteCode(chatId)}`
        const isLinkThisGc = new RegExp(gclink, 'i')
        return isLinkThisGc.test(text)
    } catch {
        return false
    }
}

//================= [ ANTILINK KICK ] =================//
if (m.isGroup && db.groups[m.chat]?.antilink === true) {
    if (regexLink.test(m.text) && !isCreator && !m.isAdmin && m.isBotAdmin && !m.fromMe) {
        if (await isGcLink(m.text, m.chat)) return 
await alip.sendMessage(m.chat, {
    text: `ðŸš« *ANTI LINK AKTIF* ðŸš«\n@${m.sender.split("@")[0]} link grup lain terdeteksi!\n\nKamu akan dikeluarkan karena admin sudah mengaktifkan fitur antilink.`,
    mentions: [m.sender]
}, { quoted: m })
        await alip.sendMessage(m.chat, { delete: m.key })
        await sleep(1000)
        await alip.groupParticipantsUpdate(m.chat, [m.sender], "remove")
    }
}

//================= [ ANTILINK DELETE ONLY ] =================//
if (m.isGroup && db.groups[m.chat]?.antilink2 === true) {
    if (regexLink.test(m.text) && !isCreator && !m.isAdmin && m.isBotAdmin && !m.fromMe) {
        if (await isGcLink(m.text, m.chat)) return

await alip.sendMessage(m.chat, {
    text: `âš ï¸ *PERINGATAN LINK TERDETEKSI* âš ï¸\n@${m.sender.split("@")[0]} pesan kamu otomatis dihapus karena antilink aktif di grup ini.`,
    mentions: [m.sender]
}, { quoted: m })
        await alip.sendMessage(m.chat, { delete: m.key })
        // await sleep(1000)
        // await alip.groupParticipantsUpdate(m.chat, [m.sender], "remove")
    }
}

// === BANNED FEATURES CHECK ===
if (isCmd && m.isGroup && global.db.groups && global.db.groups[m.chat] && global.db.groups[m.chat].bannedFeatures) {
    const banned = global.db.groups[m.chat].bannedFeatures;
    if (banned.includes(command) && !isCreator && !m.isAdmin) {
        return Reply(`ðŸš« .${command} diblokir di grup ini!`);
    }
}
//============= [ FUNCTION ] ======================================================
const example = (teks) => {
return `\n *Contoh penggunaan :*\n Ketik *${prefix+command}* ${teks}\n`
}


function generateRandomPassword() {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#%^&*';
  const length = 10;
  let password = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    password += characters[randomIndex];
  }
  return password;
}


function msToTime(ms){
  const d = Math.floor(ms / 864e5);
  const h = Math.floor(ms % 864e5 / 3.6e6);
  const m = Math.floor(ms % 3.6e6 / 6e4);
  const s = Math.floor(ms % 6e4 / 1e3);
  return `${d}d ${h}h ${m}m ${s}s`;
}

function formatDuration(ms) {
    let d = Math.floor(ms / (86400000));
    let h = Math.floor((ms % (86400000)) / (3600000));
    let m = Math.floor((ms % (3600000)) / (60000));
    
    let result = [];
    if (d > 0) result.push(`${d} hari`);
    if (h > 0) result.push(`${h} jam`);
    if (m > 0) result.push(`${m} menit`);
    
    return result.join(' ') || 'kurang dari 1 menit';
}


function generateRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

const pluginsLoader = async (directory) => {
let plugins = []
const folders = fs.readdirSync(directory)
folders.forEach(file => {
const filePath = path.join(directory, file)
if (filePath.endsWith(".js")) {
try {
const resolvedPath = require.resolve(filePath);
if (require.cache[resolvedPath]) {
delete require.cache[resolvedPath]
}
const plugin = require(filePath)
plugins.push(plugin)
} catch (error) {
console.log(`Error loading plugin at ${filePath}:`, error)
}}
})
return plugins
}


//========= [ COMMANDS PLUGINS ] =================================================
let pluginsDisable = true
const plugins = await pluginsLoader(path.resolve(__dirname, "plugins"))
const alipdev = { alip, toIDR, isCreator, Reply, command, isPremium, capital, isCmd, example, text, runtime, qtext, qlocJpm, qmsg, mime, sleep, botNumber }
for (let plugin of plugins) {
    if (plugin.command.find(e => e == command.toLowerCase())) {
const sessionFile = `${depositPath}${m.sender.split("@")[0]}.json`;
if (!m.isGroup && global.onlyGroupMode && !isCreator && !fs.existsSync(sessionFile)) {
  return; 
}
        pluginsDisable = false
        if (typeof plugin !== "function") return
        await plugin(m, alipdev)
    }
}
if (!pluginsDisable) return

//============= [ COMMANDS ] ====================================================
const menureply = async (teks, showCategories = false) => {
    const menuStyle = getMenuStyle();  // Ambil setting GLOBAL
    const readMore = String.fromCharCode(8206).repeat(4001);
    
    let totalCase = 0;
    const caseFile = path.join(__dirname, './alipai-cmd.js');
    if (fs.existsSync(caseFile)) {
        const content = fs.readFileSync(caseFile, 'utf8');
        totalCase = (content.match(/case\s+['"`]/g) || []).length;
    }

    let totalPlugin = 0;
    const pluginsDir = path.join(__dirname, './plugins');
    const countJsFiles = (dir) => {
        let count = 0;
        for (const file of fs.readdirSync(dir)) {
            const fullPath = path.join(dir, file);
            if (fs.statSync(fullPath).isDirectory()) count += countJsFiles(fullPath);
            else if (file.endsWith('.js')) count++;
        }
        return count;
    };
    if (fs.existsSync(pluginsDir)) totalPlugin = countJsFiles(pluginsDir);
    
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usedMem = totalMem - freeMem;
    const formatSize = (size) => (size / 1024 / 1024).toFixed(2) + ' MB';
    const formattedUsedMem = formatSize(usedMem);
    const formattedTotalMem = formatSize(totalMem);
    
    let timestamp = speed();
    let latensi = speed() - timestamp;
    const time = new Date().toLocaleTimeString();
    const hariini = new Date().toLocaleDateString();
    const userName = m.pushName || 'User';
    const isUserPremium = global.isPrem(m.sender);
    const isUserOwner = isCreator || areJidsSameUser(global.owner + '@s.whatsapp.net', m.sender);
    let userStatus = 'ðŸŽ« Free User';
    let limitInfo = '';
    let limitBar = '';
    
    if (isUserOwner) {
        userStatus = 'ðŸ‘‘ Owner';
        limitInfo = 'âˆž Unlimited';
        limitBar = 'â–ˆ'.repeat(10);
    } else if (isUserPremium) {
        const premDB = JSON.parse(fs.readFileSync(dbPrem));
        const userPrem = premDB.find(v => v.jid === m.sender);
        if (userPrem) {
            const daysLeft = Math.ceil((userPrem.expired - Date.now()) / (1000 * 60 * 60 * 24));
            userStatus = `â­ Premium`;
            
            const usageDB = safeReadJSON(limitUsagePath, []);
            const today = getWIBTime().toISOString().split('T')[0];
            const userUsage = usageDB.find(v => v.jid === m.sender);
            const usedToday = userUsage && userUsage.date === today ? userUsage.count : 0;
            const maxLimit = getUserMaxLimit(m.sender);
            const remainingLimit = maxLimit - usedToday;
            
            const limitBarLength = 10;
            const limitFilled = Math.min(Math.round((usedToday / maxLimit) * limitBarLength), limitBarLength);
            const limitEmpty = limitBarLength - limitFilled;
            limitBar = 'â–ˆ'.repeat(limitFilled) + 'â–‘'.repeat(limitEmpty);
            limitInfo = `${usedToday}/${maxLimit} â€¢ Sisa: ${remainingLimit}`;
        }
    } else {
        const usageDB = safeReadJSON(limitUsagePath, []);
        const today = getWIBTime().toISOString().split('T')[0];
        const userUsage = usageDB.find(v => v.jid === m.sender);
        const usedToday = userUsage && userUsage.date === today ? userUsage.count : 0;
        const maxLimit = getUserMaxLimit(m.sender);
        const remainingLimit = maxLimit - usedToday;
        
        const limitBarLength = 10;
        const limitFilled = Math.min(Math.round((usedToday / maxLimit) * limitBarLength), limitBarLength);
        const limitEmpty = limitBarLength - limitFilled;
        limitBar = 'â–ˆ'.repeat(limitFilled) + 'â–‘'.repeat(limitEmpty);
        limitInfo = `${usedToday}/${maxLimit} â€¢ Sisa: ${remainingLimit}`;
    }

    if (menuStyle === 'v1') {
        let menuText = `> Hi *${userName}* welcome! This is *${global.botname}* â€” your smart assistant 2026, ready to help you anytime with fast, simple, and powerful features ðŸš€

â”â” âŠ‘ *USER INFO* âŠ’
â”‚ê†œ *Name* : ${userName}
â”‚ê†œ *Status* : ${userStatus}
â”‚ê†œ *Limit* : ${limitInfo}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”â” âŠ‘ *INFO BOT* âŠ’
â”‚ê†œ *Nama* : ${global.botname2}
â”‚ê†œ *Owner* : ${namaOwner}
â”‚ê†œ *Total Fitur* : ${totalCase + totalPlugin}
â”‚ê†œ *Versi* : ${global.versi}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”â” âŠ‘ *CATATAN* âŠ’
â”‚ ðŸ…Ÿ = Khusus Premium
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${teks}`;

        const sections = [
            {
                title: "Menu Utama",
                highlight_label: "Rekomendasi",
                rows: [
{ title: 'Semua Fitur', description: `âž¥ ${botname}`, id: '.allmenu' },
{ title: 'Store Menu', description: `âž¥ ${botname}`, id: '.menu-store' },
{ title: 'Menu Owner', description: `âž¥ ${botname}`, id: '.menu-owner' },
{ title: 'Owner / Dev', description: `âž¥ ${botname}`, id: '.owner' }
                ]
            },
            {
                title: "Kategori Menu Lain",
                rows: [
{ title: 'Menu Stickers', description: `âž¥ ${botname}`, id: '.menu-stickers' },
{ title: 'Menu Maker', description: `âž¥ ${botname}`, id: '.menu-maker' },
{ title: 'Menu Download', description: `âž¥ ${botname}`, id: '.menu-download' },
{ title: 'Menu Search', description: `âž¥ ${botname}`, id: '.menu-search' },
{ title: 'Menu Game', description: `âž¥ ${botname}`, id: '.menu-game' },
{ title: "Menu AI", description: `âž¥ ${botname}`, id: ".menu-ai" },
{ title: "Menu Enc", description: `âž¥ ${botname}`, id: ".menu-enc" },
{ title: 'Menu Sertifikat', description: `âž¥ ${botname}`, id: '.menu-stk' },
{ title: 'Menu Rpg', description: `âž¥ ${botname}`, id: '.menu-rpg' },
{ title: 'Menu Panel', description: `âž¥ ${botname}`, id: '.menu-panel' },
{ title: 'Menu Owner', description: `âž¥ ${botname}`, id: '.menu-owner' },
{ title: 'Menu Group', description: `âž¥ ${botname}`, id: '.menu-group' },
{ title: 'Menu Potoanime', description: `âž¥ ${botname}`, id: '.menu-potoanime' },
{ title: 'Menu Anime', description: `âž¥ ${botname}`, id: '.menu-anime' },
{ title: 'Menu Nsfw', description: `âž¥ ${botname}`, id: '.menu-nsfw' },
{ title: 'Menu Cecan', description: `âž¥ ${botname}`, id: '.menu-cecan' },
{ title: 'Menu Islami', description: `âž¥ ${botname}`, id: '.menu-islami' },
{ title: 'Menu Ehpoto', description: `âž¥ ${botname}`, id: '.menu-ehpoto' },
{ title: 'Menu Fun', description: `âž¥ ${botname}`, id: '.menu-fun' },
{ title: 'Menu Primbon', description: `âž¥ ${botname}`, id: '.menu-primbon' }
                ]
            }
        ];

        try {
            await alip.sendMessage(m.chat, {
                interactiveMessage: {
                    title: menuText,
                    footer: '',
                    thumbnail: global.image.menu,
                    nativeFlowMessage: {
                        messageParamsJson: JSON.stringify({
                            limited_time_offer: {
                                text: `${botname}`,
                                url: `Bot Whatsapp`,
                                copy_code: `${botname}`,
                                expiration_time: null
                            },
                            bottom_sheet: {
                                in_thread_buttons_limit: 2,
                                divider_indices: [1, 2, 3, 999],
                                list_title: `${botname2}`,
                                button_title: "Buka Menu"
                            },
                            tap_target_configuration: {
                                title: "â–¸ Info â—‚",
                                description: "Klik untuk menu",
                                canonical_url: `${botname2}`,
                                domain: "shop.example.com",
                                button_index: 0
                            }
                        }),
                        buttons: [
                            { name: "single_select", buttonParamsJson: JSON.stringify({ has_multiple_buttons: true }) },
                            { name: "call_permission_request", buttonParamsJson: JSON.stringify({ has_multiple_buttons: true }) },
                            { name: "single_select", buttonParamsJson: JSON.stringify({ title: "MENU", sections: sections, has_multiple_buttons: true }) },
                            { name: "quick_reply", buttonParamsJson: JSON.stringify({ display_text: "Script", id: ".script" }) }
                        ]
                    }
                },
                contextInfo: {
                    mentionedJid: [m.sender],
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: idSaluran,
                        newsletterName: botname,
                        serverId: 200
                    },
                    externalAdReply: {
                        title: `${botname}`,
                        body: `${global.namaOwner}`,
                        thumbnailUrl: global.image.menu,
                        sourceUrl: global.namaSaluran,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            }, { quoted: m });
        } catch (err) {
            console.log('menu error', err);
            await alip.sendMessage(m.chat, {
                text: menuText,
                contextInfo: {
                    mentionedJid: [m.sender],
                    externalAdReply: {
                        title: `${botname}`,
                        body: `${global.namaOwner}`,
                        thumbnailUrl: global.image.menu,
                        sourceUrl: global.namaSaluran,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            }, { quoted: m });
        }
        
    } else {
        let menuText = `Hi *${userName}* welcome! This is *${global.botname}* â€” your smart assistant 2026, ready to help you anytime with fast, simple, and powerful features ðŸš€
        
â”â” âŠ‘ *INFO BOT* âŠ’
â”‚ê†œ *Nama* : ${global.botname2}
â”‚ê†œ *Owner* : ${namaOwner}
â”‚ê†œ *Total Fitur* : ${totalCase + totalPlugin}
â”‚ê†œ *Versi* : ${global.versi}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${teks}`;
        if (showCategories) {
            menuText += `${readMore}
â•­â”€â§‰ ã€Œ KATEGORI MENU ã€â”€â”€
â”‚âœŽ .allmenu
â”‚âœŽ .menu-store
â”‚âœŽ .menu-owner
â”‚âœŽ .menu-stickers
â”‚âœŽ .menu-maker
â”‚âœŽ .menu-ai
â”‚âœŽ .menu-download
â”‚âœŽ .menu-search
â”‚âœŽ .menu-enc
â”‚âœŽ .menu-game
â”‚âœŽ .menu-stk
â”‚âœŽ .menu-rpg
â”‚âœŽ .menu-panel
â”‚âœŽ .menu-owner
â”‚âœŽ .menu-group
â”‚âœŽ .menu-potoanime
â”‚âœŽ .menu-anime
â”‚âœŽ .menu-nsfw
â”‚âœŽ .menu-cecan
â”‚âœŽ .menu-islami
â”‚âœŽ .menu-ehpoto
â”‚âœŽ .menu-fun
â”‚âœŽ .menu-primbon
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        }
            
        try {
            await alip.sendMessage(m.chat, {
                video: fs.readFileSync("./source/media/menuv2.mp4"),
                caption: menuText,
                gifPlayback: true,
                contextInfo: {
                    isForwarded: true,
                    forwardingScore: 9999,
                    businessMessageForwardInfo: {
                        businessOwnerJid: global.owner + "@s.whatsapp.net"
                    },
                    forwardedNewsletterMessageInfo: {
                        newsletterName: global.botname,
                        newsletterJid: global.idSaluran
                    },
                    mentionedJid: [global.owner + "@s.whatsapp.net", m.sender],
                    externalAdReply: {
                        containsAutoReply: true,
                        thumbnailUrl: global.image.menuv2,
                        title: `ðŸŽ€ Menu ${botname}`,
                        renderLargerThumbnail: true,
                        sourceUrl: global.linkSaluran,
                        mediaType: 1
                    }
                }
            }, { quoted: qtext });
        } catch (err) {
            console.log('menu v2 error', err);
            try {
                await alip.sendMessage(m.chat, {
                    text: menuText,
                    contextInfo: {
                        mentionedJid: [m.sender],
                        externalAdReply: {
                            title: `${botname} v${versi}`,
                            body: `${global.namaOwner}`,
                            thumbnailUrl: global.image.menu,
                            sourceUrl: global.namaSaluran,
                            mediaType: 1,
                            renderLargerThumbnail: true
                        }
                    }
                }, { quoted: m });
            } catch (err2) {
                console.log('fallback menu v2 error', err2);
                await alip.sendMessage(m.chat, {
                    text: menuText
                }, { quoted: m });
            }
        }
    }
};
//============= [ COMMANDS ] ====================================================
const readPrem  = () => fs.existsSync(dbPrem) ? JSON.parse(fs.readFileSync(dbPrem)) : []
const writePrem = data => fs.writeFileSync(dbPrem, JSON.stringify(data, null, 2))
const isPrem    = jid  => readPrem().some(v => v.jid === jid)

global.autoBackup = { enabled: false, timer: null }   


// ================ SISTEM LIMIT 
const limitUsagePath = './library/database/limit_usage.json';
const limitBonusPath = './library/database/limit_bonus.json';
const claimDBPath = './library/database/claim.json'; 
if (!fs.existsSync(limitUsagePath)) fs.writeFileSync(limitUsagePath, '[]');
const limitConfigPath = './library/database/limit_config.json';
const desiredDefaultLimit = 15; // limit 
try {
    let config;
    if (fs.existsSync(limitConfigPath)) {
        config = JSON.parse(fs.readFileSync(limitConfigPath));
    } else {
        config = { users: {} };
    }

    if (config.defaultLimit !== desiredDefaultLimit) {
        console.log(`[AUTO-FIX] Nilai defaultLimit terdeteksi salah, memperbaiki ke ${desiredDefaultLimit}...`);
        config.defaultLimit = desiredDefaultLimit;
        fs.writeFileSync(limitConfigPath, JSON.stringify(config, null, 2));
    }
} catch (e) {
    console.error('[AUTO-FIX] File limit_config.json rusak. Membuat file baru...');
    fs.writeFileSync(limitConfigPath, JSON.stringify({ defaultLimit: desiredDefaultLimit, users: {} }, null, 2));
}


if (!fs.existsSync(limitBonusPath)) fs.writeFileSync(limitBonusPath, '{}');
if (!fs.existsSync(claimDBPath)) fs.writeFileSync(claimDBPath, '{}');
function getWIBTime() {
  const now = new Date();
  const utc = now.getTime() + now.getTimezoneOffset() * 60000;
  return new Date(utc + 7 * 60 * 60000);
}

function safeReadJSON(path, fallback) {
  try {
    return JSON.parse(fs.readFileSync(path));
  } catch (e) {
    fs.writeFileSync(path, JSON.stringify(fallback, null, 2));
    return fallback;
  }
}

function getLimitConfig() {
    return safeReadJSON(limitConfigPath, { defaultLimit: 20, users: {} });
}
function getUserMaxLimit(jid) {
    const config = getLimitConfig();
    const today = getWIBTime().toISOString().split('T')[0];
   
    let maxLimit = config.users[jid] ? config.users[jid] : config.defaultLimit;

    const claimDB = safeReadJSON(claimDBPath, {});
    if (claimDB[jid] === today) {
        maxLimit += 5;
    }

    const bonusDB = safeReadJSON(limitBonusPath, {});
    if (bonusDB[jid] && bonusDB[jid].date === today) {
        maxLimit += bonusDB[jid].bonus;
    }

    return maxLimit;
}

global.checkLimit = (jid, isPrem, isCreator) => {
  if (isPrem || isCreator) return false; 

  const maxLimit = getUserMaxLimit(jid);
  const usageDB = safeReadJSON(limitUsagePath, []);
  const today = getWIBTime().toISOString().split('T')[0];
  let user = usageDB.find(v => v.jid === jid);

  if (!user) return false; 

  if (user.date !== today) return false; 

  return user.count >= maxLimit; 
};

global.addLimit = (jid, isPrem, isCreator) => {
  if (isPrem || isCreator) return; 
  const usageDB = safeReadJSON(limitUsagePath, []);
  const today = getWIBTime().toISOString().split('T')[0];
  let user = usageDB.find(v => v.jid === jid);

  if (!user) {
    usageDB.push({ jid, date: today, count: 1 });
  } else {
    if (user.date !== today) {
      user.date = today;
      user.count = 1;
    } else {
      user.count++;
    }
  }
  fs.writeFileSync(limitUsagePath, JSON.stringify(usageDB, null, 2));
};

global.claimLimit = (jid) => {
  const claimDB = safeReadJSON(claimDBPath, {});
  const today = getWIBTime().toISOString().split('T')[0];
  
  if (claimDB[jid] === today) {
    return { success: false, message: "Kamu sudah claim limit hari ini!\n> upgrade ke premium untuk akses tanpa batas" };
  }
  
  claimDB[jid] = today;
  fs.writeFileSync(claimDBPath, JSON.stringify(claimDB, null, 2));
  return { success: true, message: "Berhasil claim 5 limit tambahan!\n> upgrade ke premium untuk akses tanpa batas" };
};


// ===============================================================
// DAFTAR SISTEM
const userDBPath = './library/database/user.json';
const registerSystemPath = './library/database/register_system.json';

if (!fs.existsSync(userDBPath)) fs.writeFileSync(userDBPath, '[]');
if (!fs.existsSync(registerSystemPath)) {
    fs.writeFileSync(registerSystemPath, JSON.stringify({ enabled: true }, null, 2));
}

function loadRegisterSystem() {
    try {
        return JSON.parse(fs.readFileSync(registerSystemPath));
    } catch (e) {
        return { enabled: true };
    }
}

function saveRegisterSystem(data) {
    fs.writeFileSync(registerSystemPath, JSON.stringify(data, null, 2));
}

function isRegisterSystemEnabled() {
    const config = loadRegisterSystem();
    return config.enabled === true;
}
global.isRegistered = (jid) => {
    const config = loadRegisterSystem();
    if (!config.enabled) {
        return true;
    }
    const db = JSON.parse(fs.readFileSync(userDBPath));
    return db.some(v => areJidsSameUser(v.jid, jid)); 
};

global.addRegisteredUser = (jid, name) => {
    const db = JSON.parse(fs.readFileSync(userDBPath));
    db.push({
        jid,
        name,
        date: new Date().toISOString()
    });
    fs.writeFileSync(userDBPath, JSON.stringify(db, null, 2));
};

function toRupiah(number) {
    if (typeof number !== 'string' && typeof number !== 'number') {
        return 'Rp0';
    }
    const num = Number(number);
    if (isNaN(num)) {
        return 'Rp0';
    }
    return 'Rp' + num.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ".");
}

// â”€â”€â”€ SEWA GRUP FIX FINAL â”€â”€â”€
const sewaPath = './library/database/sewagrup.json';

if (!fs.existsSync(sewaPath)) {
    fs.writeFileSync(sewaPath, '[]');
}

let sewaCheckedToday = {};

async function checkSewaGroup() {
    const now = Date.now();
    const today = new Date().toDateString();
    
    if (sewaCheckedToday[today]) return;
    sewaCheckedToday[today] = true;
    
    setTimeout(() => {
        delete sewaCheckedToday[today];
    }, 23 * 60 * 60 * 1000);
    
    try {
        const sewagrup = JSON.parse(fs.readFileSync(sewaPath));
        let updated = false;

        for (let i = sewagrup.length - 1; i >= 0; i--) {
            const data = sewagrup[i];
            const timeLeft = data.expired - now;
            const lockKey = `${data.jid}_${today}`;
            
            if (timeLeft <= 0) {
                try {
                    await alip.sendMessage(data.jid, {
                        text: `ðŸš¨ *MASA SEWA BERAKHIR* ðŸš¨\n\nBot akan keluar.`
                    });
                    
                    setTimeout(async () => {
                        try {
                            await alip.groupLeave(data.jid);
                        } catch (e) {}
                    }, 5000);
                    
                } catch (e) {}
                
                sewagrup.splice(i, 1);
                updated = true;
                
            } else if (timeLeft <= 3 * 24 * 60 * 60 * 1000) {
                const daysLeft = Math.ceil(timeLeft / (1000 * 60 * 60 * 24));
                
                try {
                    await alip.sendMessage(data.jid, {
                        text: `âš ï¸ Sewa Bot Sisa ${daysLeft} hari`
                    });
                } catch (e) {}
            }
        }

        if (updated) {
            fs.writeFileSync(sewaPath, JSON.stringify(sewagrup, null, 2));
        }
        
    } catch (e) {}
}

setInterval(checkSewaGroup, 24 * 60 * 60 * 1000);

if (m.isGroup && isCmd && !isCreator && m.chat !== global.linkGrup) {
    const sewagrup = JSON.parse(fs.readFileSync(sewaPath));
    const isSewa = sewagrup.find(v => v.jid === m.chat && v.expired > Date.now());
    
    if (!isSewa) {
        await alip.sendMessage(m.chat, {
            text: `ðŸš« GRUP BELUM SEWA\n\nOwner: ${global.owner}`
        }, { quoted: m });
        return;
    }
}

const afkFile = './library/database/afk.json'

if (!fs.existsSync(afkFile)) fs.writeFileSync(afkFile, '[]')
let afkData = JSON.parse(fs.readFileSync(afkFile))

let lastAfkNotify = {}

function msToTimeAFK(duration) {
  let seconds = Math.floor((duration / 1000) % 60),
      minutes = Math.floor((duration / (1000 * 60)) % 60),
      hours = Math.floor((duration / (1000 * 60 * 60)) % 24)

  return `${String(hours).padStart(2, '0')}.${String(minutes).padStart(2, '0')}.${String(seconds).padStart(2, '0')}`
}

if (m.isGroup && m.mentionedJid?.length && !m.isBaileys && !m.fromMe) {
  for (let mentionedId of m.mentionedJid) {
    if (mentionedId === m.sender || mentionedId === alip.user.id) continue;

let fullJid = mentionedId;
if (mentionedId.endsWith('@lid')) {
  if (m.metadata && m.metadata.participants && Array.isArray(m.metadata.participants)) {
    const participant = m.metadata.participants.find(p => p.id === mentionedId);
    if (participant) {
      fullJid = participant.jid;
    } else {
      continue;
    }
  } else {
    continue;
  }
}

    let afkUser = afkData.find(v => v.jid === fullJid);
    if (afkUser) {
      const key = `${m.chat}-${fullJid}`;
      const now = Date.now();
      const lastNotify = lastAfkNotify[key] || 0;

      if (now - lastNotify > 60 * 1000) { 
        let waktu = msToTimeAFK(now - afkUser.time);
        
        await Reply(
          `ðŸ’¤ *SEDANG AFK*\n\nðŸ‘¤ User: @${fullJid.split('@')[0]}\nâ° Durasi: ${waktu}\nðŸ“ Alasan: ${afkUser.reason}\n\n_Silakan tunggu hingga user kembali aktif_`,
          [fullJid]
        );
        
        lastAfkNotify[key] = now;
      }
    }
  }
}

const afkNow = afkData.find(v => v.jid === m.sender)
if (afkNow && !m.isBaileys && !m.fromMe) {
  afkData = afkData.filter(v => v.jid !== m.sender)
  fs.writeFileSync(afkFile, JSON.stringify(afkData, null, 2))
  
  const durationMs = Date.now() - afkNow.time;
  const waktu = msToTimeAFK(durationMs);

  await Reply(
    `ðŸŽ‰ *WELCOME BACK!*\n\n@${m.sender.split('@')[0]} telah kembali dari AFK\nâ° Durasi AFK: ${waktu}\n\n_Selamat beraktivitas kembali!_`,
    [m.sender]
  );
}

// Load blacklist
const blacklistPath = './library/database/blacklist.json'
if (!fs.existsSync(blacklistPath)) fs.writeFileSync(blacklistPath, '[]')
let blacklist = JSON.parse(fs.readFileSync(blacklistPath))

if (isCmd && !isCreator && blacklist.some(b => areJidsSameUser(b, m.sender))) {
  return Reply(`ðŸš« *AKSES DITOLAK!*\nKamu masuk daftar blacklist, silakan bujuk owner bot untuk unblacklist.`);
}
//================================================================================
// ONLY GC BOT 
const pathOnlyGroup = './library/database/onlygroup.json'
if (!fs.existsSync(pathOnlyGroup)) {
  fs.writeFileSync(pathOnlyGroup, JSON.stringify({ onlyGroupMode: true }, null, 2)) // default ON
}
const onlyGroupConfig = JSON.parse(fs.readFileSync(pathOnlyGroup))
global.onlyGroupMode = onlyGroupConfig.onlyGroupMode

if (
m.isGroup &&
isCmd &&
isOnlyPremGroup(m.chat) &&
!isCreator &&
!isPremium
) {
return Reply(
"AKSES DITOLAK\n\n" +
"Fitur ini hanya untuk user premium di grup ini.\n\n" +
"Gunakan:\n" +
`${prefix}buyprem\n` +
`${prefix}owner`
)
}

// TRACKING PESAN PER USER DI GRUP
if (m.isGroup && !m.fromMe && !m.isBaileys && m.text && !m.text.startsWith('.') && m.text.trim().length > 0) {
    if (!global.db.groups) global.db.groups = {};
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    if (!global.db.groups[m.chat].users) global.db.groups[m.chat].users = {};
    if (!global.db.groups[m.chat].users[m.sender]) {
        global.db.groups[m.chat].users[m.sender] = {
            messages: 0,
            lastMessage: Date.now(),
            name: m.pushName || m.sender.split('@')[0]
        };
    }
    
    global.db.groups[m.chat].users[m.sender].messages += 1;
    global.db.groups[m.chat].users[m.sender].lastMessage = Date.now();
    global.db.groups[m.chat].users[m.sender].name = m.pushName || m.sender.split('@')[0];
}
//================================================================================
function cleanTikTokUrl(url) {
    if (!url.includes('tiktok.com')) return url;
    return url;
}

if (
  m.body?.match(/(https?:\/\/[^\s]+)/i) &&
  /(tiktok\.com|vm\.tiktok\.com|instagram\.com|ig\.me|pin\.it|pinterest\.com|twitter\.com|x\.com|facebook\.com|fb\.watch)/i.test(m.body) &&
  !m.body.startsWith('.')
) {
  if (m.isGroup && global.db.groups[m.chat]?.autodownload === false) {
    return; 
  }
  
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  const rawLink = m.body.match(/(https?:\/\/[^\s]+)/i)[0];
  const link = rawLink;
  
  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  await alip.sendMessage(m.chat, { react: { text: "ðŸ‘ŒðŸ»", key: m.key } });

  try {
    let apiResult = null;
    const isTiktok = /(tiktok\.com|vm\.tiktok\.com)/i.test(link);
    const isInstagram = /(instagram\.com|ig\.me)/i.test(link);
    const isFacebook = /(facebook\.com|fb\.watch)/i.test(link);
    const isTwitter = /(twitter\.com|x\.com)/i.test(link);
    const isPinterest = /(pinterest\.com|pin\.it)/i.test(link);
    
    if (isTiktok) {
      const apiUrl = `https://api.yupra.my.id/api/downloader/tiktok?url=${encodeURIComponent(link)}`;
      const response = await axios.get(apiUrl, { timeout: 30000 });
      const result = response.data;
      
      if (!result.status || result.status !== 200 || !result.result || !result.result.status) {
        throw new Error("Gagal mengambil data TikTok! Pastikan link valid.");
      }

      const tiktokData = result.result;

      if (tiktokData.data && tiktokData.data.length > 0) {
        let selectedVideo = tiktokData.data.find(e => e.type === "nowatermark");
        
        if (!selectedVideo) {
          selectedVideo = tiktokData.data.find(e => e.type === "nowatermark_hd") ||
                         tiktokData.data.find(e => e.type === "watermark") ||
                         tiktokData.data[0];
        }

        if (!selectedVideo || !selectedVideo.url) {
          throw new Error("Video tidak ditemukan atau link tidak valid.");
        }

        const videoCaption = `
*Tiktok Auto Downloadâœ…*

> â±ï¸ *Durasi:* ${tiktokData.duration || 'Tidak diketahui'}
> ðŸ‘¤ *Uploader:* ${tiktokData.author?.nickname || 'Tidak diketahui'}

> ðŸ“Š *Info:*
> ðŸ“… *Unggahan:* ${tiktokData.taken_at || 'Tidak diketahui'}
> ðŸŒ *Region:* ${tiktokData.region || 'Tidak diketahui'}

> ðŸŽµ *Musik:*
> ${tiktokData.music_info?.title || 'Tidak ada info musik'}
        `.trim();

        await alip.sendMessage(
          m.chat,
          {
            video: { url: selectedVideo.url },
            mimetype: 'video/mp4',
            caption: videoCaption,
            buttons: [
              {
                buttonId: `.ttmp3 ${link}`,
                buttonText: { displayText: "ðŸŽ¸ Ambil Audio" },
                type: 1,
              }
            ],
            headerType: 4
          },
          { quoted: m }
        );
        return;
      } else {
        throw new Error("Video tidak ditemukan atau link tidak valid.");
      }
      
    } else if (isInstagram) {
      const encodedUrl = encodeURIComponent(link);
      const apiUrl = `${global.apialip}/download/instagram?apikey=${global.apikeyalip}&url=${encodedUrl}`;
      
      const { data } = await axios.get(apiUrl, { timeout: 30000 });
      
      if (!data.status || !data.result || !Array.isArray(data.result) || data.result.length === 0) {
        throw new Error('Gagal mengambil media Instagram');
      }

      let successCount = 0;
      
      for (const [index, media] of data.result.entries()) {
        try {
          const mediaCaption = `ðŸ“Œ *Instagram Auto Download*\nðŸŽ¬ ${media.kualitas || 'Media'} ${index + 1}/${data.result.length}`;
          
          if (media.url_download) {
            const url = media.url_download.toLowerCase();
            
            if (url.includes('.jpg') || url.includes('.jpeg') || url.includes('.png') || url.includes('.webp')) {
              await alip.sendMessage(m.chat, {
                image: { url: media.url_download },
                caption: mediaCaption,
                mimetype: 'image/jpeg'
              }, { quoted: index === 0 ? m : undefined });
            } else {
              await alip.sendMessage(m.chat, {
                video: { url: media.url_download },
                caption: mediaCaption,
                mimetype: 'video/mp4'
              }, { quoted: index === 0 ? m : undefined });
            }
            
            successCount++;
            await sleep(1000);
          }
          
        } catch (err) {}
      }

      if (successCount === 0) {
        throw new Error('Gagal mengunduh media Instagram');
      }
      
    } else if (isFacebook) {
      const encodedUrl = encodeURIComponent(link);
      const apiUrl = `${global.btc}/api/download/fbdown?apikey=${global.apikeyalip}&url=${encodedUrl}`;
      const { data } = await axios.get(apiUrl, { timeout: 90000 });
      
      if (!data.status || !data.result?.status === 'success') {
        throw new Error('Gagal download video');
      }
      
      const urls = data.result?.url?.urls || [];
      const videoUrl = urls.find(v => v.hd)?.hd || urls.find(v => v.sd)?.sd;
      
      if (!videoUrl) throw new Error('Video tidak ditemukan');
      
      await alip.sendMessage(m.chat, {
        video: { url: videoUrl },
        mimetype: 'video/mp4',
        caption: `*Facebook Auto Downloadâœ…*`
      }, { quoted: m });
      
    } else if (isTwitter) {
      const axios = require("axios");
      const FormData = require("form-data");
      const cheerio = require("cheerio");

      let form = new FormData();
      form.append("q", link);
      form.append("lang", "en");
      form.append("cftoken", "");

      let { data } = await axios.post(
        "https://savetwitter.net/api/ajaxSearch",
        form,
        { headers: form.getHeaders() }
      );

      if (!data.data) {
        throw new Error("Data kosong / tidak ditemukan");
      }

      const $ = cheerio.load(data.data);
      let result = [];

      $(".dl-action a").each((_, el) => {
        const url = $(el).attr("href");
        const label = $(el).text().trim();
        if (url && label.includes("Download MP4")) {
          result.push({
            quality: label.replace("Download MP4", "").replace(/[()]/g, "").trim(),
            url: url
          });
        }
      });

      if (result.length === 0) {
        throw new Error("Video tidak ditemukan.");
      }

      let high = result.find(v => v.quality.includes("1280")) || result[0];
      
      await alip.sendMessage(
        m.chat,
        {
          video: { url: high.url },
          mimetype: 'video/mp4',
          caption: `*Twitter/X Auto Downloadâœ…*`
        },
        { quoted: m }
      );
      
    } else if (isPinterest) {
      const encodedUrl = encodeURIComponent(link);
      const apiUrl = `${global.btc}/api/download/pinterest?apikey=${global.apikeyalip}&url=${encodedUrl}`;
      const { data } = await axios.get(apiUrl, { timeout: 90000 });
      
      if (!data || !data.result || !data.result.data) {
        throw new Error('Gagal download Pinterest');
      }
      
      const pinterestData = data.result.data;
      
      if (pinterestData.video) {
        await alip.sendMessage(m.chat, {
          video: { url: pinterestData.video },
          mimetype: 'video/mp4',
          caption: `ðŸ“Œ *Pinterest Video Auto Downloadâœ…*`
        }, { quoted: m });
      } else if (pinterestData.image) {
        await alip.sendMessage(m.chat, {
          image: { url: pinterestData.image },
          caption: `ðŸ“Œ *Pinterest Image Auto Downloadâœ…*`
        }, { quoted: m });
      } else {
        throw new Error('Media Pinterest tidak ditemukan');
      }
    }

  } catch (err) {
    let fallbackCommand = null;
    let platformName = getPlatformName(link);
    let errorMessage = `âŒ *Gagal Auto Download*`;

    if (err.response) {
      errorMessage += `\nServer error: ${err.response.status}`;
    } else if (err.code === 'ECONNABORTED') {
      errorMessage += `\nTimeout - coba lagi nanti`;
    } else {
      errorMessage += `\n${err.message}`;
    }
    
    if (/(tiktok\.com|vm\.tiktok\.com)/i.test(link)) {
      fallbackCommand = `.tt ${link}`;
    } else if (/(instagram\.com|ig\.me)/i.test(link)) {
      fallbackCommand = `.ig ${link}`;
    } else if (/(facebook\.com|fb\.watch)/i.test(link)) {
      fallbackCommand = `.facebook ${link}`;
    } else if (/(twitter\.com|x\.com)/i.test(link)) {
      fallbackCommand = `.twitter ${link}`;
    } else if (/(pinterest\.com|pin\.it)/i.test(link)) {
      fallbackCommand = `.pinterest ${link}`;
    }

    if (fallbackCommand) {
      await alip.sendMessage(
        m.chat,
        {
          text: `${errorMessage}\n\nðŸ”§ *Coba download ulang:*`,
          footer: `Auto Downloader â€¢ ${platformName}`,
          buttons: [
            {
              buttonId: fallbackCommand,
              buttonText: { displayText: `ðŸ“¥ Download Ulang` },
              type: 1,
            },
          ],
          headerType: 1,
        },
        { quoted: m }
      );
    } else {
      await Reply(`${errorMessage}\n\nPlatform ini belum didukung untuk auto download.`);
    }
  }
}

function getPlatformName(url) {
  if (/(tiktok\.com|vm\.tiktok\.com)/i.test(url)) return "TikTok";
  if (/(instagram\.com|ig\.me)/i.test(url)) return "Instagram";
  if (/(facebook\.com|fb\.watch)/i.test(url)) return "Facebook";
  if (/(twitter\.com|x\.com)/i.test(url)) return "Twitter/X";
  if (/(pinterest\.com|pin\.it)/i.test(url)) return "Pinterest";
  return "Social Media";
}
const welcomePath = './library/database/welcome.json';
const welcomeDB = fs.existsSync(welcomePath) ? JSON.parse(fs.readFileSync(welcomePath)) : {};
const leftFile = './library/database/left.json'
const leftDB = fs.existsSync(leftFile) ? JSON.parse(fs.readFileSync(leftFile)) : {}

const userId = m.sender;
global.lastCmd = global.lastCmd || {};
global.lastCmd[userId] = global.lastCmd[userId] || { cmd: '', time: 0 };

if (isCmd) {
  const now = Date.now();
  const last = global.lastCmd[userId];

  if (command === last.cmd && now - last.time < 3000) { // 3 detik delay
    return Reply(`â±ï¸ *Tunggu sebentar!* Jangan spam perintah *.${command}*`);
  }

  global.lastCmd[userId] = {
    cmd: command,
    time: now
  };
}


// Fungsi load & save
function loadData() {
    if (!fs.existsSync(dbPath)) return {};
    return JSON.parse(fs.readFileSync(dbPath));
}
function saveData(data) {
    fs.writeFileSync(dbPath, JSON.stringify(data, null, 2));
}

// Generate quest harian random
function generateQuest() {
    let questList = [
        { type: "jelajah", target: 3, reward: { exp: 50, credit: 30 } },
        { type: "battle", target: 2, reward: { exp: 70, credit: 50 } },
        { type: "win_battle", target: 1, reward: { exp: 100, credit: 70 } },
    ];
    return questList[Math.floor(Math.random() * questList.length)];
}

// Thumbnail per command
const thumb = {
    menu: "https://img1.pixhost.to/images/8862/642953847_condemnedforce.jpg",
    status: "https://img1.pixhost.to/images/8862/642953847_condemnedforce.jpg",
    jelajah: "https://img1.pixhost.to/images/8862/642954593_condemnedforce.jpg",
    battle: "https://img1.pixhost.to/images/8861/642930887_condemnedforce.jpg",
    quest: "https://img1.pixhost.to/images/8862/642958889_condemnedforce.jpg",
    inventory: "https://img1.pixhost.to/images/8862/642959818_condemnedforce.jpg",
    shop: "https://img1.pixhost.to/images/8861/642930321_condemnedforce.jpg",
    pvp: "https://img1.pixhost.to/images/8862/642955145_condemnedforce.jpg",
    reset: "https://img1.pixhost.to/images/8862/642955726_condemnedforce.jpg"
};



// Load database RPG
const rpgDBPath = './library/database/rpg.json';

if (!fs.existsSync(rpgDBPath)) {
  const defaultRPG = {
  "players": {},
  "monsters": {
    "1": { "name": "Goblin", "hp": 30, "attack": 5, "defense": 2, "exp": 15, "gold": 10, "level": 1, "drops": { "kulit_goblin": 0.7, "taring_goblin": 0.3 } },
    "2": { "name": "Orc", "hp": 50, "attack": 8, "defense": 4, "exp": 25, "gold": 20, "level": 3, "drops": { "kulit_orc": 0.6, "batu_kekuatan": 0.1 } },
    "3": { "name": "Naga", "hp": 100, "attack": 15, "defense": 8, "exp": 60, "gold": 50, "level": 10, "drops": { "sisik_naga": 0.5, "batu_kekuatan": 0.3 } },
    "4": { "name": "Goblin Jendral", "hp": 80, "attack": 12, "defense": 6, "exp": 70, "gold": 60, "level": 7, "drops": { "batu_kekuatan": 0.5 } }
  },
  "locations": {
    "desa": { "name": "Desa Pemula", "monsters": [1], "minLevel": 1, "maxLevel": 5 },
    "hutan": { "name": "Hutan Gelap", "monsters": [1, 2], "minLevel": 3, "maxLevel": 8 },
    "gua": { "name": "Gua Naga", "monsters": [2, 3], "minLevel": 8, "maxLevel": 15 },
    "tambang": { "name": "Tambang Terbengkalai", "monsters": [], "minLevel": 5, "maxLevel": 20, "ores": { "batu": 0.8, "batu_bara": 0.5, "bijih_besi": 0.2, "permata": 0.05 } },
    "padang_rumput": { "name": "Padang Rumput Liar", "monsters": [], "minLevel": 2, "maxLevel": 20, "herbs": { "rumput_liar": 0.9, "bunga_langka": 0.3, "jamur_ajaib": 0.1 } }
  },
  "items": {
"items": {
    "potion": { "name": "Potion", "type": "heal", "value": 30, "price": 10 },
    "limit_bot_10": { "name": "10 Limit Bot", "type": "bot_feature", "value": 10, "price": 1000 }
},
    "elixir": { "name": "Elixir", "type": "mana", "value": 25, "price": 15 },
    "pedang_besi": { "name": "Pedang Besi", "type": "weapon", "attack": 5, "price": 50 },
    "zirah_kulit": { "name": "Zirah Kulit", "type": "armor", "defense": 3, "price": 40 },
    "pedang_kayu": { "name": "Pedang Kayu", "type": "weapon", "attack": 2, "price": 15 },
    "baju_kain": { "name": "Baju Kain", "type": "armor", "defense": 1, "price": 10 },
    "kulit_goblin": { "name": "Kulit Goblin", "type": "material", "price": 2 },
    "taring_goblin": { "name": "Taring Goblin", "type": "material", "price": 4 },
    "kulit_orc": { "name": "Kulit Orc", "type": "material", "price": 5 },
    "batu_kekuatan": { "name": "Batu Kekuatan", "type": "material", "price": 20 },
    "sisik_naga": { "name": "Sisik Naga", "type": "material", "price": 30 },
    "batu": { "name": "Batu", "type": "material", "price": 1 },
    "batu_bara": { "name": "Batu Bara", "type": "material", "price": 8 },
    "bijih_besi": { "name": "Bijih Besi", "type": "material", "price": 15 },
    "permata": { "name": "Permata", "type": "material", "price": 100 },
    "rumput_liar": { "name": "Rumput Liar", "type": "material", "price": 1 },
    "bunga_langka": { "name": "Bunga Langka", "type": "material", "price": 25 },
"jamur_ajaib": { "name": "Jamur Ajaib", "type": "material", "price": 40 },
"nikel": { "name": "Nikel", "type": "material", "price": 50 },
"emas": { "name": "Emas", "type": "material", "price": 250 },
"berlian": { "name": "Berlian", "type": "material", "price": 500 }
  },
  "craftingRecipes": {
    "potion_kuat": { "name": "Potion Kuat", "result": "potion", "amount": 3, "materials": { "bunga_langka": 2, "jamur_ajaib": 1 } },
    "zirah_kulit_kuat": { "name": "Zirah Kulit Kuat", "result": "zirah_kulit", "amount": 1, "materials": { "kulit_orc": 5, "kulit_goblin": 10 } },
    "pedang_besi_tempa": { "name": "Pedang Besi Tempa", "result": "pedang_besi", "amount": 1, "materials": { "bijih_besi": 10, "batu_bara": 5 } }
  },
  "quests": {
    "pemburu_goblin": { "title": "Pemburu Goblin", "description": "Kalahkan 5 Goblin di Desa Pemula.", "type": "kill", "target": "Goblin", "count": 5, "reward": { "exp": 100, "gold": 50, "item": { "id": "potion", "amount": 3 } } },
    "kolektor_kulit": { "title": "Kolektor Kulit", "description": "Kumpulkan 10 Kulit Goblin.", "type": "collect", "target": "kulit_goblin", "count": 10, "reward": { "exp": 80, "gold": 70 } }
  },
  "dungeons": {
    "goblin_outpost": {
      "name": "Markas Goblin",
      "minLevel": 5,
      "stages": [
        { "monsterId": "1", "count": 2 },
        { "monsterId": "1", "count": 3 }
      ],
      "boss": "4",
      "reward": { "exp": 250, "gold": 200, "item": { "id": "batu_kekuatan", "amount": 2 } }
    }
  },
  "petData": {
    "serigala": { "name": "Serigala", "attack": 5, "cost": 300, "description": "Serigala setia yang menambah kekuatan seranganmu." },
    "kura_kura": { "name": "Kura-kura", "defense": 3, "cost": 250, "description": "Kura-kura dengan tempurung keras yang menambah pertahananmu." }
  }
}


  fs.writeFileSync(rpgDBPath, JSON.stringify(defaultRPG, null, 2));
}

// Load database RPG
const rpgDB = JSON.parse(fs.readFileSync(rpgDBPath));

// ================== [ FUNGSI HELPER RPG - UPGRADED ] ==================

// alipai-cmd.js

function initPlayerRPG(phone, className = "warrior") {
  const classes = {
    "warrior": { hp: 100, mp: 30, attack: 15, defense: 10, agility: 5 },
    "mage": { hp: 60, mp: 100, attack: 20, defense: 5, agility: 8 },
    "archer": { hp: 80, mp: 50, attack: 12, defense: 7, agility: 15 }
  };
  const selectedClass = classes[className] || classes["warrior"];
  return {
    class: className,
    level: 1,
    exp: 0,
    expToNextLevel: 100,
    maxHp: selectedClass.hp,
    hp: selectedClass.hp,
    maxMp: selectedClass.mp,
    mp: selectedClass.mp,
    attack: selectedClass.attack,
    defense: selectedClass.defense,
    agility: selectedClass.agility,
    gold: 50,
    inventory: { "potion": 3, "pedang_kayu": 1, "baju_kain": 1 },
    equipment: {
      weapon: null,
      armor: null
    },
    location: "desa",
    battles: 0,
    monstersDefeated: 0,
    lastBattle: 0,
    activeQuest: null,
    questProgress: 0,
    lastDaily: 0,
    lastPvp: 0,
    pvpWins: 0,
    pvpLosses: 0
  };
}


function getRandomMonster(location) {
  const rpgDB = JSON.parse(fs.readFileSync(rpgDBPath));
  const locationData = rpgDB.locations[location];
  if (!locationData) return null;
  const randomMonsterId = locationData.monsters[Math.floor(Math.random() * locationData.monsters.length)];
  return { ...rpgDB.monsters[randomMonsterId], id: randomMonsterId };
}

// âœ¨ NEW: Helper to get total stats including equipment
function getPlayerTotalStats(player) {
    let totalStats = {
        attack: player.attack,
        defense: player.defense
    };
    const currentDB = JSON.parse(fs.readFileSync(rpgDBPath));
    if (player.equipment.weapon) {
        const weapon = currentDB.items[player.equipment.weapon];
        if (weapon) totalStats.attack += weapon.attack;
    }
    if (player.equipment.armor) {
        const armor = currentDB.items[player.equipment.armor];
        if (armor) totalStats.defense += armor.defense;
    }
    return totalStats;
}

function calculateDamage(attacker, defender) {
    const isPlayerAttacker = !!attacker.maxHp;
    const attackerStats = isPlayerAttacker ? getPlayerTotalStats(attacker) : { attack: attacker.attack, defense: attacker.defense };
    const defenderStats = !isPlayerAttacker ? getPlayerTotalStats(defender) : { attack: defender.attack, defense: defender.defense };

    const damage = Math.max(1, Math.floor(attackerStats.attack - defenderStats.defense));
    const isCritical = Math.random() < (attacker.agility / 100);
    return {
        damage: isCritical ? damage * 2 : damage,
        isCritical: isCritical
    };
}

function gainExp(player, exp) {
  player.exp += exp;
  if (player.exp >= player.expToNextLevel) {
    player.level += 1;
    player.exp -= player.expToNextLevel;
    player.expToNextLevel = Math.floor(player.expToNextLevel * 1.5);
    player.maxHp += 10;
    player.hp = player.maxHp;
    player.maxMp += 5;
    player.mp = player.maxMp;
    player.attack += 2;
    player.defense += 1;
    player.agility += 1;
    return true;
  }
  return false;
}


//============== [ ANTI-FITUR ] ================================================
const daftarKataKunciPromosi = [
    // jual / beli
    "ijin jual", "lagi jual", "jual murah", "jual cepat", "jualan", "jualan online",
    "jual barang", "jual produk", "jual jasa", "jual grosir", "jual eceran",
    "buka lapak", "lapak jualan", "dagang", "dagangan", "dagangan online",
    "beli sekarang", "buruan beli", "mau beli", "siapa mau beli", "open order", 
    
    // promo / diskon
    "promo", "promo spesial", "promo besar", "promo menarik", "promo gila",
    "diskon", "diskon gede", "diskon besar", "diskon spesial", "diskon heboh",
    "harga miring", "harga spesial", "harga murah", "cuci gudang", "clearance sale",
    "gratis ongkir", "free ongkir", "bonus menarik", "bonus spesial", "cashback",
    
    // kata pemicu order
    "order sekarang", "langsung order", "open po", "pre order", "stock terbatas",
    "ready stock", "stok terbatas", "barang ready", "barang ori", "ori 100%",
    "take nih", "buruan", "cepat habis", "sold out soon", "limited edition",
    
    // platform promosi
    "wa.me", "wa.me/", "bit.ly", "linktr.ee", "t.me/", "telegram.me", 
    "shopee", "tokopedia", "bukalapak", "lazada", "blibli", "olshop",
    "toko online", "produk terlaris", "best seller", "official store"
];

const daftarKataKasar = [
    "anjing", "anjink", "babi", "monyet", "asu", "bangsat", "kontol",
    "kont*l", "k0ntol", "memek", "mmk", "meki", "bajingan", "goblok",
    "goblog", "tolol", "idiot", "peler", "pler", "ngentot", "ngntot",
    "ngewe", "jembut", "pepek", "titit", "gila"
];

// Fungsi untuk mengecek kata kunci
const isPromosi = (message) => daftarKataKunciPromosi.some(keyword => message.toLowerCase().includes(keyword));
const isToxic = (message) => {
    if (!message) return false;
    let text = message.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/gi, "");
    return daftarKataKasar.some(keyword => {
        const pattern = keyword
            .replace(/o/g, "[o0]")
            .replace(/i/g, "[i1!]")
            .replace(/e/g, "[e3]")
            .replace(/a/g, "[a4@]")
            .replace(/u/g, "[u]")
            .replace(/s/g, "[s5$]");
        const regex = new RegExp(pattern, "gi");
        return regex.test(text);
    });
};

if (m.isGroup && global.db.groups[m.chat] && !m.isAdmin && m.isBotAdmin && !isCreator) {
    if (global.db.groups[m.chat].antiPromosi === true) {
        if (isPromosi(m.text)) {
            const deleteKey = m.key;
            await alip.sendMessage(m.chat, {
                text: `ðŸ“¢ *Promosi Terdeteksi* ðŸ“¢
@${m.sender.split("@")[0]} maaf, iklan atau promosi tidak diperbolehkan di grup ini. Pesanmu sudah dihapus.`,
                mentions: [m.sender]
            }, { quoted: m });
            await sleep(1000);
            await alip.sendMessage(m.chat, { delete: deleteKey });
        }
    }
    if (global.db.groups[m.chat].antiToxic === true) {
        if (isToxic(m.text)) {
            await alip.sendMessage(m.chat, { delete: m.key });
            await alip.sendMessage(m.chat, {
                text: `ðŸš« *Kata Kasar Terdeteksi* ðŸš«
@${m.sender.split("@")[0]} penggunaan kata tidak sopan dilarang di grup ini!`,
                mentions: [m.sender]
            }, { quoted: m });
        }
    }
}

const autoAbsenDB = './library/database/autoabsen.json';

if (!fs.existsSync('./library/database/')) {
    fs.mkdirSync('./library/database/', { recursive: true });
}
if (!fs.existsSync(autoAbsenDB)) {
    fs.writeFileSync(autoAbsenDB, '{}');
}

function loadAutoAbsen() {
    try {
        const data = fs.readFileSync(autoAbsenDB, 'utf8');
        return JSON.parse(data) || {};
    } catch {
        return {};
    }
}

function saveAutoAbsen(data) {
    fs.writeFileSync(autoAbsenDB, JSON.stringify(data, null, 2));
}

async function checkAndSendAbsen() {
    try {
        const autoAbsenData = loadAutoAbsen();
        if (Object.keys(autoAbsenData).length === 0) return;
        
        const now = new Date();
        const wibTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Jakarta' }));
        const today = wibTime.toDateString();
        const hours = String(wibTime.getHours()).padStart(2, '0');
        const minutes = String(wibTime.getMinutes()).padStart(2, '0');
        const currentTime = `${hours}:${minutes}`;
        
        for (const chatId in autoAbsenData) {
            const groupData = autoAbsenData[chatId];
            if (groupData && groupData.enabled === true) {
                
                if (groupData.lastSent !== today) {
                    const scheduledTime = (groupData.time || "07:00").trim();
                    
                    if (currentTime === scheduledTime) {
                        
                        try {
                            const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
                            const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
                            
                            const day = dayNames[wibTime.getDay()];
                            const date = wibTime.getDate();
                            const month = monthNames[wibTime.getMonth()];
                            const year = wibTime.getFullYear();
                            
                            await alip.sendMessage(chatId, {
                                poll: {
                                    name: `ðŸ“… ABSEN HARIAN ${day}, ${date} ${month} ${year}`,
                                    values: ['HadirðŸ˜™', 'Sakit nihðŸ˜”', 'Selalu hadir bosðŸ¤ª', 'y'],
                                    selectableCount: 1
                                }
                            });
                            
                            await sleep(1000);
                            
                            await alip.sendMessage(chatId, { 
                                text: `ðŸ¢ ABSEN HARIAN GRUP\n\nðŸ“… Tanggal: ${day}, ${date} ${month} ${year}\nâ° Waktu: ${currentTime}\n\nSilakan pilih status kehadiran Anda hari ini.` 
                            });
                            
                            autoAbsenData[chatId].lastSent = today;
                            saveAutoAbsen(autoAbsenData);
                            
                        } catch (e) {}
                    }
                } else {}
            }
        }
    } catch (e) {}
}

if (!global.absenInterval) {
    global.absenInterval = setInterval(() => {
        checkAndSendAbsen();
    }, 10000); 
}

async function checkScheduledMessages() {
    try {
        const data = JSON.parse(fs.readFileSync(schedulePath));
        const now = Date.now();
        
        for (let i = data.messages.length - 1; i >= 0; i--) {
            const msg = data.messages[i];
            
            if (msg.timestamp <= now) {
                try {
                    if (msg.type === 'text') {
                        await alip.sendMessage(msg.chat, { text: msg.content });
                    } else if (msg.type === 'image') {
                        await alip.sendMessage(msg.chat, { 
                            image: { url: msg.content },
                            caption: msg.caption || ''
                        });
                    } else if (msg.type === 'video') {
                        await alip.sendMessage(msg.chat, { 
                            video: { url: msg.content },
                            caption: msg.caption || ''
                        });
                    }
                    
                    data.messages.splice(i, 1);
                } catch (e) {}
            }
        }
        
        fs.writeFileSync(schedulePath, JSON.stringify(data, null, 2));
    } catch (e) {}
}

if (!global.scheduleInterval) {
    global.scheduleInterval = setInterval(checkScheduledMessages, 10000);
}
// ================== [ANTI-DELETE SYSTEM] ==================
async function saveMessageForAntidelete(alip, m) {
    try {
        if (!global.db.groups[m.chat]?.antidelete) return;
        
        if (!global.db.groups[m.chat].antideleteMessages) {
            global.db.groups[m.chat].antideleteMessages = {};
        }

        const messageData = {
            id: m.key.id,
            sender: m.sender,
            pushName: m.pushName || 'User',
            timestamp: m.messageTimestamp || Math.floor(Date.now() / 1000),
            type: m.type,
            text: m.text || '',
            media: null,
            mimetype: ''
        };

        if (m.message?.imageMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
                let buffer = Buffer.from([]);
                for await (const chunk of mediaBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }
                messageData.media = buffer.toString('base64');
                messageData.mimetype = m.message.imageMessage.mimetype;
            } catch (e) {}
        } else if (m.message?.videoMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'video');
                let buffer = Buffer.from([]);
                for await (const chunk of mediaBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }
                messageData.media = buffer.toString('base64');
                messageData.mimetype = m.message.videoMessage.mimetype;
            } catch (e) {}
        } else if (m.message?.audioMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'audio');
                let buffer = Buffer.from([]);
                for await (const chunk of mediaBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }
                messageData.media = buffer.toString('base64');
                messageData.mimetype = m.message.audioMessage.mimetype;
            } catch (e) {}
        } else if (m.message?.documentMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'document');
                let buffer = Buffer.from([]);
                for await (const chunk of mediaBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }
                messageData.media = buffer.toString('base64');
                messageData.mimetype = m.message.documentMessage.mimetype;
            } catch (e) {}
        } else if (m.message?.stickerMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
                let buffer = Buffer.from([]);
                for await (const chunk of mediaBuffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                }
                messageData.media = buffer.toString('base64');
                messageData.mimetype = m.message.stickerMessage.mimetype;
            } catch (e) {}
        }

        global.db.groups[m.chat].antideleteMessages[m.key.id] = messageData;
        
    } catch (e) {}
}

async function handleDeletedMessage(alip, m) {
    try {
        if (!global.db.groups[m.chat]?.antidelete) return;

        let deletedMsgId = null;
        
        if (m.message?.protocolMessage?.type === 0) {
            deletedMsgId = m.message.protocolMessage.key?.id;
        }

        if (!deletedMsgId || !global.db.groups[m.chat].antideleteMessages) return;

        const deletedMessage = global.db.groups[m.chat].antideleteMessages[deletedMsgId];
        if (!deletedMessage) return;

        const senderName = deletedMessage.pushName || deletedMessage.sender.split('@')[0];
        
        let caption = `ðŸ—‘ï¸ *PESAN DIHAPUS*\nðŸ‘¤ *Dari:* @${senderName}\nâ° *Waktu:* ${moment(deletedMessage.timestamp * 1000).format('DD/MM/YYYY HH:mm:ss')}`;

        if (deletedMessage.text) {
            caption += `\nðŸ’¬ *Pesan:* ${deletedMessage.text}`;
        }

        if (deletedMessage.media) {
            const mediaBuffer = Buffer.from(deletedMessage.media, 'base64');
            
            if (deletedMessage.mimetype.includes('image')) {
                await alip.sendMessage(m.chat, { 
                    image: mediaBuffer, 
                    caption: caption,
                    mentions: [deletedMessage.sender]
                });
            } else if (deletedMessage.mimetype.includes('video')) {
                await alip.sendMessage(m.chat, { 
                    video: mediaBuffer, 
                    caption: caption,
                    mentions: [deletedMessage.sender]
                });
            } else if (deletedMessage.mimetype.includes('audio')) {
                await alip.sendMessage(m.chat, { 
                    audio: mediaBuffer, 
                    mimetype: deletedMessage.mimetype,
                    caption: caption,
                    mentions: [deletedMessage.sender]
                });
            } else if (deletedMessage.mimetype.includes('application') || deletedMessage.mimetype.includes('text')) {
                await alip.sendMessage(m.chat, { 
                    document: mediaBuffer,
                    mimetype: deletedMessage.mimetype,
                    fileName: `deleted_message.${deletedMessage.mimetype.split('/')[1] || 'bin'}`,
                    caption: caption,
                    mentions: [deletedMessage.sender]
                });
            }
        } else if (deletedMessage.text) {
            await alip.sendMessage(m.chat, { 
                text: caption,
                mentions: [deletedMessage.sender]
            });
        }

        delete global.db.groups[m.chat].antideleteMessages[deletedMsgId];
        
    } catch (e) {}
}

if (m.message && !m.key.fromMe) {
    saveMessageForAntidelete(alip, m);
}

if (m.message?.protocolMessage?.type === 0) {
    handleDeletedMessage(alip, m);
}

// ================== LEVEL SYSTEM (PER GRUP) ==================
const dbDirectory = './library/database/';
if (!fs.existsSync(dbDirectory)) {
    fs.mkdirSync(dbDirectory, { recursive: true });
}
const levelDBPath = path.join(dbDirectory, 'level.json');
if (!fs.existsSync(levelDBPath)) {
    fs.writeFileSync(levelDBPath, '{}');
}

const xpCooldown = 60000;
const baseXpPerMessage = 15; 
function makeProgressBar(current, total, size = 10) {
    if (total === 0) return `[${'â–‘'.repeat(size)}] 0% (0/0 XP)`;
    const currentClamped = Math.max(0, Math.min(current, total));
    const progress = Math.floor((currentClamped / total) * size);
    const bar = 'â–ˆ'.repeat(progress) + 'â–‘'.repeat(size - progress);
    const percent = Math.floor((currentClamped / total) * 100);
    return `[${bar}] ${percent}% (${currentClamped}/${total} XP)`;
}
function getXPToNextLevel(level) {
    return Math.floor(5 * Math.pow(level, 2) + 50 * level + 100);
}

function addUserXP(groupId, userId) {
    const levelDB = JSON.parse(fs.readFileSync(levelDBPath));
    const now = Date.now();
    if (!levelDB[groupId]) {
        levelDB[groupId] = {};
    }
    if (!levelDB[groupId][userId]) {
        levelDB[groupId][userId] = { level: 1, xp: 0, messages: 0, lastXpTime: 0 };
    }

    const user = levelDB[groupId][userId];
    user.messages += 1;
    if (now - user.lastXpTime < xpCooldown) {
        fs.writeFileSync(levelDBPath, JSON.stringify(levelDB, null, 2));
        return { leveledUp: false }; 
    }

    user.xp += baseXpPerMessage;
    user.lastXpTime = now;

    let hasLeveledUp = false;
    while (user.xp >= getXPToNextLevel(user.level)) {
        user.xp -= getXPToNextLevel(user.level);
        user.level += 1;
        hasLeveledUp = true;
    }
    fs.writeFileSync(levelDBPath, JSON.stringify(levelDB, null, 2));

    return {
        leveledUp: hasLeveledUp,
        newLevel: user.level,
        xp: user.xp,
        xpToNextLevel: getXPToNextLevel(user.level)
    };
}

function getUserLevel(groupId, userId) {
    const levelDB = JSON.parse(fs.readFileSync(levelDBPath));
    if (!levelDB[groupId] || !levelDB[groupId][userId]) {
        return { level: 1, xp: 0, messages: 0 };
    }
    return levelDB[groupId][userId];
}

const panelExpiryDB = './library/database/panel_expiry.json';
const panelLogDB = './library/database/panel_log.json';
const panelResellerDB = './library/database/panel_reseller.json';

function loadPanelDB() {
    try {
        if (!fs.existsSync(panelExpiryDB)) {
            fs.writeFileSync(panelExpiryDB, '[]');
        }
        return JSON.parse(fs.readFileSync(panelExpiryDB, 'utf8'));
    } catch (e) {
        console.error('Panel DB error:', e);
        return [];
    }
}

function savePanelDB(data) {
    fs.writeFileSync(panelExpiryDB, JSON.stringify(data, null, 2));
}

function loadPanelLog() {
    try {
        if (!fs.existsSync(panelLogDB)) {
            fs.writeFileSync(panelLogDB, '{}');
        }
        return JSON.parse(fs.readFileSync(panelLogDB, 'utf8'));
    } catch (e) {
        return {};
    }
}

function savePanelLog(data) {
    fs.writeFileSync(panelLogDB, JSON.stringify(data, null, 2));
}

function loadResellerPanelDB() {
    try {
        if (!fs.existsSync(panelResellerDB)) {
            fs.writeFileSync(panelResellerDB, '{}');
        }
        return JSON.parse(fs.readFileSync(panelResellerDB, 'utf8'));
    } catch (e) {
        return {};
    }
}

function saveResellerPanelDB(data) {
    fs.writeFileSync(panelResellerDB, JSON.stringify(data, null, 2));
}

function addPanelEntry(serverId, data) {
    const db = loadPanelDB();
    const existingIndex = db.findIndex(p => p.serverId === serverId);
    
    if (existingIndex >= 0) {
        db[existingIndex] = { ...db[existingIndex], ...data };
    } else {
        db.push(data);
    }
    
    savePanelDB(db);
    
    const resellerDB = loadResellerPanelDB();
    if (data.reseller) {
        if (!resellerDB[data.reseller]) resellerDB[data.reseller] = [];
        if (!resellerDB[data.reseller].includes(serverId)) {
            resellerDB[data.reseller].push(serverId);
        }
        saveResellerPanelDB(resellerDB);
    }
    
    return db;
}

function getResellerPanels(resellerJid) {
    const db = loadPanelDB();
    return db.filter(p => p.reseller === resellerJid);
}

function getPanelByServerId(serverId) {
    const db = loadPanelDB();
    const searchId = Number(serverId);
    return db.find(p => p.serverId === searchId);
}
async function checkExpiredServersRealTime() {
    const db = loadPanelDB();
    const now = Date.now();
    const logDB = loadPanelLog();
    const today = new Date().toDateString();
    let updated = false;
    for (const server of db) {
        if (server.expiresAt <= now && !server.suspended) {
            try {
                const status = await suspendServer(server.serverId);
                
                if (status === true) {
                    server.suspended = true;
                    server.suspendedAt = now;
                    updated = true;
                }
            } catch (e) {}
        } else if (server.expiresAt - now <= 3 * 24 * 60 * 60 * 1000) {
            if (!logDB[server.serverId] || logDB[server.serverId] !== today) {
                const daysLeft = Math.ceil((server.expiresAt - now) / (24 * 60 * 60 * 1000));
                
                if (daysLeft <= 3 && daysLeft > 0) {
                    logDB[server.serverId] = today;
                    savePanelLog(logDB);
                }
            }
        }
    }
    
    if (updated) {
        savePanelDB(db);
    }
}
setInterval(checkExpiredServersRealTime, 5 * 60 * 1000);

if (!global.isPanelCheckerRunning) {
    checkExpiredServersRealTime();
    global.isPanelCheckerRunning = true;
}
function removePanelEntry(serverId) {
    const db = loadPanelDB();
    const filtered = db.filter(p => p.serverId !== serverId);
    savePanelDB(filtered);
    
    const resellerDB = loadResellerPanelDB();
    for (const reseller in resellerDB) {
        resellerDB[reseller] = resellerDB[reseller].filter(id => id !== serverId);
        if (resellerDB[reseller].length === 0) {
            delete resellerDB[reseller];
        }
    }
    saveResellerPanelDB(resellerDB);
    
    return filtered;
}

async function suspendServer(serverId) {
    if (!global.domain || !global.apikey) {
        return 'not_configured';
    }

    const fetch = require("node-fetch");
    try {
        const response = await fetch(`${global.domain}/api/application/servers/${serverId}/suspend`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${global.apikey}`,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            timeout: 15000
        });
        
        if (response.status === 204) {
            return true;
        } else {
            if (response.status === 404) return 'not_found';
            if (response.status === 401 || response.status === 403) return 'unauthorized';
            return false;
        }
    } catch (error) {
        if (error.name === 'TimeoutError') return 'timeout';
        if (error.code === 'ECONNREFUSED') return 'connection_error';
        return false;
    }
}

// ================== [ FUNGSI RESELLER ] ========
const dbReseller = './library/database/reseller.json';
const loadReseller = () => {
  if (!fs.existsSync(dbReseller)) return [];
  try {
    return JSON.parse(fs.readFileSync(dbReseller));
  } catch {
    return [];
  }
};

const saveReseller = (data) => {
  fs.writeFileSync(dbReseller, JSON.stringify(data, null, 2));
};

const isReseller = (jid) => {
  let reseller = loadReseller();
  return Array.isArray(reseller) && reseller.includes(jid);
};
// =========== [ PENGATURAN AUTO AI ] ==========
try {
    if (!isCmd && m.text && !m.fromMe && !m.isBaileys) {
        await global.autoAiHandler.processMessage(m, isCmd, isCreator, isPremium);
    }
} catch (err) {
}
// ===== PENGELOLA PESAN 'DONE' & 'PROSES' PER GRUP =====
const pathDone = './library/database/setdone.json';
const pathProses = './library/database/setproses.json';

if (!fs.existsSync(pathDone)) {
  fs.writeFileSync(pathDone, JSON.stringify({}));
}
if (!fs.existsSync(pathProses)) {
  fs.writeFileSync(pathProses, JSON.stringify({}));
}

function loadDoneMessages() {
  try {
    return JSON.parse(fs.readFileSync(pathDone));
  } catch (e) {
    fs.writeFileSync(pathDone, JSON.stringify({}));
    return {};
  }
}

function saveDoneMessages(data) {
  fs.writeFileSync(pathDone, JSON.stringify(data, null, 2));
}

function loadProsesMessages() {
  try {
    return JSON.parse(fs.readFileSync(pathProses));
  } catch (e) {
    fs.writeFileSync(pathProses, JSON.stringify({}));
    return {};
  }
}

function saveProsesMessages(data) {
  fs.writeFileSync(pathProses, JSON.stringify(data, null, 2));
}

function generateResponseWithMentions(template, item = "", quotedMessage = null, metadata = null) {
    const now = new Date();
    const wibTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Jakarta' }));
    
    const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
    const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
    
    const tanggal = `${dayNames[wibTime.getDay()]}, ${wibTime.getDate()} ${monthNames[wibTime.getMonth()]} ${wibTime.getFullYear()}`;
    const jam = `${String(wibTime.getHours()).padStart(2, '0')}:${String(wibTime.getMinutes()).padStart(2, '0')}:${String(wibTime.getSeconds()).padStart(2, '0')}`;
    
    let mentions = [];
    let userText = "User";
    let userJid = null;
    
    if (quotedMessage) {
        userJid = quotedMessage.sender;
        if (userJid.endsWith('@lid') && metadata && metadata.participants) {
            const participant = metadata.participants.find(p => p.lid === userJid || p.id === userJid);
            if (participant) {
                userJid = participant.jid;
            } else {
                userJid = userJid.replace('@lid', '@s.whatsapp.net');
            }
        }
        mentions = [userJid];
        userText = `@${userJid.split('@')[0]}`;
    }
    
    let status = template.includes("SELESAI") || template.includes("BERHASIL") || template.includes("âœ…") ? "Selesai" : "Proses";
    
    let response = template
        .replace(/@tanggal/g, tanggal)
        .replace(/@jam/g, jam)
        .replace(/@status/g, status)
        .replace(/@item/g, item || "Produk")
        .replace(/@user/g, userText);
    
    return {
        text: response,
        mentions: mentions
    };
}

// ================== LIST SYSTEM ==================
const pathList = './library/database/lists.json';
if (!fs.existsSync(pathList)) {
  fs.writeFileSync(pathList, JSON.stringify({}));
}
function loadLists() {
  try {
    return JSON.parse(fs.readFileSync(pathList));
  } catch (e) {
    fs.writeFileSync(pathList, JSON.stringify({}));
    return {};
  }
}

function saveLists(data) {
  fs.writeFileSync(pathList, JSON.stringify(data, null, 2));
}

const listSettingsPath = './library/database/list_settings.json';

function loadListSettings() {
    try {
        if (fs.existsSync(listSettingsPath)) {
            return JSON.parse(fs.readFileSync(listSettingsPath, 'utf8'));
        }
        return {};
    } catch (e) {
        return {};
    }
}

function saveListSettings(data) {
    fs.writeFileSync(listSettingsPath, JSON.stringify(data, null, 2));
}

function getListWithTemplate(chatId, userName, groupName, listItems) {
    const settings = loadListSettings();
    const chatSettings = settings[chatId];
    const sortedItems = [...listItems].sort((a, b) => {
        return a.name.localeCompare(b.name, 'id', { sensitivity: 'base' });
    });
    
    if (!chatSettings || !chatSettings.template) {
        let defaultText = `DAFTAR LIST\n\n`;
        sortedItems.forEach((item, index) => {
            defaultText += `${chatSettings?.prefix || ":: Éžâƒ˜ðµËšð“‚‚ðŸŽ "}${item.name}\n`;
        });
        defaultText += `\nKetik nama item untuk melihat detail`;
        return defaultText;
    }
    
    const now = moment().tz('Asia/Jakarta');
    const hour = now.hour();
    let waktuHari = '';
    
    if (hour >= 0 && hour < 5) waktuHari = 'Dini Hari';
    else if (hour >= 5 && hour < 10) waktuHari = 'Pagi';
    else if (hour >= 10 && hour < 15) waktuHari = 'Siang';
    else if (hour >= 15 && hour < 18) waktuHari = 'Sore';
    else if (hour >= 18 && hour < 24) waktuHari = 'Malam';
    
    const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
    const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
    
    const tanggalLengkap = `${dayNames[now.day()]}, ${now.date()} ${monthNames[now.month()]} ${now.year()}`;
    
    let template = chatSettings.template;
    template = template
        .replace(/@name/g, userName || 'User')
        .replace(/@group/g, groupName || 'Grup')
        .replace(/@time/g, now.format('HH:mm:ss'))
        .replace(/@date/g, now.format('DD/MM/YYYY'))
        .replace(/@fulldate/g, tanggalLengkap)
        .replace(/@daytime/g, waktuHari)
        .replace(/@x/g, sortedItems.map((item) => `${chatSettings?.prefix || ":: Éžâƒ˜ðµËšð“‚‚ðŸŽ "}${item.name}`).join('\n'))
        .replace(/@prefix\s+[^\n]+/gi, '');
    
    return template.trim();
}

async function downloadAndSaveMedia(m, type = 'image') {
    try {
        const mediaBuffer = await downloadContentFromMessage(m.message[`${type}Message`], type);
        let buffer = Buffer.from([]);
        for await (const chunk of mediaBuffer) {
            buffer = Buffer.concat([buffer, chunk]);
        }
        const mediaDir = './library/media/list/';
        if (!fs.existsSync(mediaDir)) {
            fs.mkdirSync(mediaDir, { recursive: true });
        }
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(7);
        const filename = `${timestamp}_${random}.jpg`;
        const filepath = path.join(mediaDir, filename);
        fs.writeFileSync(filepath, buffer);
        return filepath;
    } catch (error) {
        throw error;
    }
}
// ================== AUTO RESPON LIST ==================
if (!isCmd && m.isGroup && body && typeof body === 'string' && body.trim().length > 0) {
  const chatId = m.chat;
  let listDb = loadLists();
  let listGrup = listDb[chatId] || [];

  if (listGrup.length > 0) {
    const searchText = body.toLowerCase().trim();
    
    let cari = listGrup.find(item => 
      item.name.toLowerCase() === searchText
    );
    
    if (cari) {
      if (cari.hasImage && cari.image) {
        await alip.sendMessage(m.chat, {
          image: fs.readFileSync(cari.image),
          caption: cari.desc
        }, { quoted: m });
      } else {
        alip.sendMessage(m.chat, {
          text: cari.desc
        }, { quoted: m });
      }
    }
  }
}

// AUTO RESPON PAYMENT 
if (m.isGroup && m.text && !m.text.startsWith('.') && !m.text.startsWith('#') && !m.text.startsWith('!') && !m.text.startsWith('$') && !m.text.startsWith('/')) {
    const paymentDBPath = './library/database/autopay.json';
    
    function loadPayments() {
        try {
            if (!fs.existsSync(paymentDBPath)) return {};
            return JSON.parse(fs.readFileSync(paymentDBPath));
        } catch (e) {
            return {};
        }
    }
    
    const db = loadPayments();
    const groupPayments = db[m.chat]?.payments;
    
    if (groupPayments) {
        const userText = m.text.toLowerCase().trim();
        
        for (const [keyword, data] of Object.entries(groupPayments)) {
            if (userText === keyword.toLowerCase()) {
                if (data.type === 'buttonurl') {
                    const img = data.image && fs.existsSync(data.image) 
                        ? await prepareWAMessageMedia({ 
                            image: fs.readFileSync(data.image) 
                        }, { upload: alip.waUploadToServer })
                        : null;
                    
                    const msgii = await generateWAMessageFromContent(m.chat, {
                        viewOnceMessageV2Extension: {
                            message: {
                                messageContextInfo: {
                                    deviceListMetadata: {},
                                    deviceListMetadataVersion: 2
                                }, 
                                interactiveMessage: {
                                    body: {
                                        text: `ðŸ’° ${keyword.toUpperCase()} PAYMENT`
                                    },
                                    carouselMessage: {
                                        cards: [{
                                            header: img ? {
                                                hasMediaAttachment: true,
                                                ...img
                                            } : undefined,
                                            nativeFlowMessage: {
                                                buttons: [{
                                                    "name": "cta_url",
                                                    "buttonParamsJson": JSON.stringify({
                                                        "display_text": `Bayar ${keyword}`,
                                                        "url": data.value,
                                                        "merchant_url": data.value
                                                    })
                                                }]
                                            }
                                        }]
                                    }
                                }
                            }
                        }
                    }, { userJid: m.sender, quoted: m });
                    
                    await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id });
                    return;
                    
                } else if (data.type === 'text') {
                    if (data.image && fs.existsSync(data.image)) {
                        await alip.sendMessage(m.chat, {
                            image: fs.readFileSync(data.image),
                            caption: data.value
                        }, { quoted: m });
                    } else {
                        await Reply(data.value);
                    }
                    return;
                }
            }
        }
    }
}

// ====== DATABASE GAME ======
const dbPath = "./library/database/dbgame.json";
global.gameSessions = global.gameSessions || {};
if (!isCmd && m.isGroup && global.gameSessions[m.chat]) {
    const session = global.gameSessions[m.chat];
    const quotedMsg = m.quoted ? m.quoted : false;
    if (quotedMsg && quotedMsg.id === session.messageId) {
        if (m.sender === botNumber) return; 
        const jawabanBenar = session.jawaban;
        const teksUser = (m.text || "").toLowerCase().trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        
        let benar = false;
        if (Array.isArray(jawabanBenar)) {
            benar = jawabanBenar.some(j => teksUser.includes(j.toLowerCase()));
        } else {
            benar = teksUser === jawabanBenar.toLowerCase();
        }

        if (benar) {

            clearTimeout(session.timeout); 
            let jawabanTampil = Array.isArray(jawabanBenar) ? jawabanBenar.join(" / ") : jawabanBenar;
            const limitReward = Math.floor(Math.random() * 5) + 1; 
           
            const bonusDB = safeReadJSON(limitBonusPath, {});
            const today = getWIBTime().toISOString().split('T')[0];

            if (!bonusDB[m.sender] || bonusDB[m.sender].date !== today) {
                bonusDB[m.sender] = { bonus: 0, date: today };
            }
            
            bonusDB[m.sender].bonus += limitReward;
            fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));
           
            Reply(`âœ… *Jawaban Benar!* \nJawabannya adalah: *${jawabanTampil}*\n\nSelamat kepada @${m.sender.split('@')[0]}! ðŸŽ‰\nðŸŽ Kamu mendapatkan hadiah *+${limitReward} Limit Bot!*`, [m.sender]);
            
            delete global.gameSessions[m.chat];
            
        } else {
            Reply(`âŒ *Jawaban Salah* untuk soal ini. Coba lagi!`);
        }
        
    } else if (quotedMsg && quotedMsg.id !== session.messageId) {
        return; 
    }
}


// Konfigurasi game
const gameConfig = {
    caklontong: { file: "./game/caklontong.json", type: 'file' },
    family100: { file: "./game/family100.json", type: 'file' },
    tebakgambar: { file: "./game/tebakgambar.json", type: 'file' },
    tebaklogo: { file: "./game/tebaklogo.json", type: 'file' },
    tebakhero: { file: "./game/tebakhero.json", type: 'file' },
    tebakgenshin: { file: "./game/tebakgenshin.json", type: 'file' },
    tebakgame: { file: "./game/tebakgame.json", type: 'file' },
    tebakmakanan: { file: "./game/tebakmakanan.json", type: 'file' },
    tebakbendera: { file: "./game/tebakbendera.json", type: 'file' },
    tebaklagu: { file: "./game/tebaklagu.json", type: 'file' },
    sambungkata: { file: "./game/sambungkata.json", type: 'file' },
    tebakjkt: { api: "https://api.siputzx.my.id/api/games/tebakjkt", type: 'api' },
    tebaklirik: { file: "./game/tebaklirik.json", type: 'file' },
    asahotak: { file: "./game/asahotak.json", type: 'file' },
    lengkapikalimat: { file: "./game/lengkapikalimat.json", type: 'file' },
    siapakahaku: { file: "./game/siapakahaku.json", type: 'file' },
    susunkata: { file: "./game/susunkata.json", type: 'file' },
    tebakkata: { file: "./game/tebakkata.json", type: 'file' },
    tebakanime: { file: "./game/tebakanime.json", type: 'file' },
    tebakkalimat: { file: "./game/tebakkalimat.json", type: 'file' },
    tebakjorok: { file: "./game/tebakjorok.json", type: 'file' },
    tebakinggris: { file: "./game/tebakinggris.json", type: 'file' },
    tebakhewan: { file: "./game/tebakhewan.json", type: 'file' },
};

async function startGame(gameType, m) {
    // 1. Cek Pra-kondisi 
    if (global.gameSessions[m.chat]) {
        return Reply('âš ï¸ Masih ada game yang berlangsung di chat ini! Selesaikan dulu atau ketik *.nyerah*');
    }
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    const config = gameConfig[gameType];
    if (!config) return Reply("âŒ Tipe game tidak valid.");

    try {
        let soalData;

        // 2. Ambil Soal
        if (config.type === 'api') {
            const res = await fetchJson(config.api);
            if (!res || res.status !== true || !res.data) {
                throw new Error(`API response tidak valid atau gagal untuk game ${gameType}.`);
            }
            soalData = res.data;
        } else { // type 'file'
            const fileContent = fs.readFileSync(config.file, 'utf-8');
            const fileData = JSON.parse(fileContent);
            if (!Array.isArray(fileData) || fileData.length === 0) {
                throw new Error(`File ${config.file} kosong atau formatnya bukan array.`);
            }
            soalData = fileData[Math.floor(Math.random() * fileData.length)];
        }

        if (!soalData) {
            throw new Error("Gagal mendapatkan data soal (soalData is null/undefined).");
        }

        const questionText = soalData.soal || soalData.deskripsi || "Tebak apakah ini?";
        const rawAnswer = soalData.jawaban || soalData.name || soalData.judul;
        if (!rawAnswer || (Array.isArray(rawAnswer) && rawAnswer.length === 0)) {
            throw new Error("Data soal yang diambil tidak memiliki jawaban yang valid.");
        }

        const jawaban = Array.isArray(rawAnswer) 
            ? rawAnswer.map(j => String(j).toLowerCase()) 
            : String(rawAnswer).toLowerCase();
       
        const finalCaption = `ðŸŽ® *${gameType.toUpperCase()}*\n\n${questionText}\n\nâ³ Jawab dalam 60 detik!\n*ðŸ“Œ CARA JAWAB: Balas/Reply pesan ini dengan jawabanmu!*\n> gunakan .nyerah untuk menyerah.`;
        const imageUrl = soalData.gambar || soalData.img;
        const audioUrl = soalData.soal;
        
        let sentMsg; 
        if (imageUrl && typeof imageUrl === 'string' && imageUrl.trim() !== '') {
            sentMsg = await alip.sendMessage(m.chat, { 
                image: { url: imageUrl }, 
                caption: finalCaption 
            }, { quoted: m });

        } else if (audioUrl && typeof audioUrl === 'string' && audioUrl.trim() !== '') {
            const thumbnailUrl = soalData.thumbnail || global.image.menu; 
            const title = soalData.title || "Tebak Judul Lagu";
            const body = soalData.body || `Waktu Terbatas! Putar dan Jawab Segera.`; 
            const sourceUrl = soalData.source || "https://www.google.com";

            try {
                await alip.sendMessage(m.chat, {
                    audio: { url: mp3DownloadLink }, 
                    mimetype: 'audio/mpeg',
                    ptt: true 
                }, { quoted: m });

                sentMsg = await Reply(finalCaption); 

            } catch (sendError) {
                console.error("Gagal mengirim audio dengan externalAdReply, mencoba mengirim audio biasa...", sendError);
                await alip.sendMessage(m.chat, { audio: { url: audioUrl }, mimetype: 'audio/mpeg' }, { quoted: m });
                sentMsg = await Reply(finalCaption); 
            }
            
        } else {
            sentMsg = await Reply(finalCaption); 
        }
        global.gameSessions[m.chat] = {
            gameType: gameType,
            soal: questionText,
            jawaban: jawaban,
            messageId: sentMsg.key.id, 
            startTime: Date.now(),
            timeout: setTimeout(() => {
                if (global.gameSessions[m.chat]) {
                    let jawabanTampil = Array.isArray(jawaban) ? jawaban.join(" / ") : jawaban;
                    Reply(`â° Waktu habis! Jawaban yang benar adalah *${jawabanTampil}*`);
                    delete global.gameSessions[m.chat];
                }
            }, 60000) 
        };

    } catch (e) {
        console.error(`[GAME ERROR] Gagal memulai game ${gameType}:`, e.message);
        Reply(`âŒ Terjadi kesalahan saat memulai game *${gameType}*. Coba lagi nanti.`);
    }
}
async function createQuoteSticker(m, backgroundColor) {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!text) return m.reply('âŒ Teksnya mana?');
    m.reply('â³ Sedang membuat stiker...');

    let ppuser;
    try {
        ppuser = await alip.profilePictureUrl(m.sender, 'image');
    } catch (err) {
        ppuser = 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg';
    }

    const json = {
        "type": "quote",
        "format": "png",
        "backgroundColor": backgroundColor,
        "width": 512,
        "height": 768,
        "scale": 2,
        "messages": [{
            "entities": [],
            "avatar": true,
            "from": {
                "id": 1,
                "name": m.pushName,
                "photo": { "url": ppuser }
            },
            "text": text,
            "replyMessage": {}
        }]
    };

    try {
        const response = await axios.post('https://bot.lyo.su/quote/generate', json, {
            headers: { 'Content-Type': 'application/json' }
        });
        const buffer = Buffer.from(response.data.result.image, 'base64');
        await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
    } catch (err) {
        console.error("QC Sticker Error:", err);
        m.reply("âŒ Gagal membuat stiker, coba lagi nanti.");
    }
}

const fullAsmaulHusna = [
  { index: 1, latin: "Ar Rahman", arabic: "Ø§Ù„Ø±Ø­Ù…Ù†", arti: "Yang Maha Pengasih" },
  { index: 2, latin: "Ar Rahiim", arabic: "Ø§Ù„Ø±Ø­ÙŠÙ…", arti: "Yang Maha Penyayang" },
  { index: 3, latin: "Al Malik", arabic: "Ø§Ù„Ù…Ù„Ùƒ", arti: "Yang Maha Merajai" },
  { index: 4, latin: "Al Quddus", arabic: "Ø§Ù„Ù‚Ø¯ÙˆØ³", arti: "Yang Maha Suci" },
  { index: 5, latin: "As Salaam", arabic: "Ø§Ù„Ø³Ù„Ø§Ù…", arti: "Yang Maha Memberi Kesejahteraan" },
  { index: 6, latin: "Al Mu'min", arabic: "Ø§Ù„Ù…Ø¤Ù…Ù†", arti: "Yang Maha Memberi Keamanan" },
  { index: 7, latin: "Al Muhaimin", arabic: "Ø§Ù„Ù…Ù‡ÙŠÙ…Ù†", arti: "Yang Maha Mengatur" },
  { index: 8, latin: "Al 'Aziiz", arabic: "Ø§Ù„Ø¹Ø²ÙŠØ²", arti: "Yang Maha Perkasa" },
  { index: 9, latin: "Al Jabbar", arabic: "Ø§Ù„Ø¬Ø¨Ø§Ø±", arti: "Yang Memiliki Mutlak Kegagahan" },
  { index: 10, latin: "Al Mutakabbir", arabic: "Ø§Ù„Ù…ØªÙƒØ¨Ø±", arti: "Yang Maha Megah" },
  { index: 11, latin: "Al Khaliq", arabic: "Ø§Ù„Ø®Ø§Ù„Ù‚", arti: "Yang Maha Pencipta" },
  { index: 12, latin: "Al Baari'", arabic: "Ø§Ù„Ø¨Ø§Ø±Ø¦", arti: "Yang Maha Melepaskan" },
  { index: 13, latin: "Al Mushawwir", arabic: "Ø§Ù„Ù…ØµÙˆØ±", arti: "Yang Maha Membentuk Rupa" },
  { index: 14, latin: "Al Ghaffaar", arabic: "Ø§Ù„ØºÙØ§Ø±", arti: "Yang Maha Pengampun" },
  { index: 15, latin: "Al Qahhaar", arabic: "Ø§Ù„Ù‚Ù‡Ø§Ø±", arti: "Yang Maha Menundukkan" },
  { index: 16, latin: "Al Wahhaab", arabic: "Ø§Ù„ÙˆÙ‡Ø§Ø¨", arti: "Yang Maha Pemberi Karunia" },
  { index: 17, latin: "Ar Razzaaq", arabic: "Ø§Ù„Ø±Ø²Ø§Ù‚", arti: "Yang Maha Pemberi Rezeki" },
  { index: 18, latin: "Al Fattaah", arabic: "Ø§Ù„ÙØªØ§Ø­", arti: "Yang Maha Pembuka Rahmat" },
  { index: 19, latin: "Al 'Aliim", arabic: "Ø§Ù„Ø¹Ù„ÙŠÙ…", arti: "Yang Maha Mengetahui" },
  { index: 20, latin: "Al Qaabidh", arabic: "Ø§Ù„Ù‚Ø§Ø¨Ø¶", arti: "Yang Maha Menyempitkan" },
  { index: 21, latin: "Al Baasith", arabic: "Ø§Ù„Ø¨Ø§Ø³Ø·", arti: "Yang Maha Melapangkan" },
  { index: 22, latin: "Al Khaafidh", arabic: "Ø§Ù„Ø®Ø§ÙØ¶", arti: "Yang Maha Merendahkan" },
  { index: 23, latin: "Ar Raafi'", arabic: "Ø§Ù„Ø±Ø§ÙØ¹", arti: "Yang Maha Meninggikan" },
  { index: 24, latin: "Al Mu'izz", arabic: "Ø§Ù„Ù…Ø¹Ø²", arti: "Yang Maha Memuliakan" },
  { index: 25, latin: "Al Mudzil", arabic: "Ø§Ù„Ù…Ø°Ù„", arti: "Yang Maha Menghinakan" },
  { index: 26, latin: "As Samii'", arabic: "Ø§Ù„Ø³Ù…ÙŠØ¹", arti: "Yang Maha Mendengar" },
  { index: 27, latin: "Al Bashiir", arabic: "Ø§Ù„Ø¨ØµÙŠØ±", arti: "Yang Maha Melihat" },
  { index: 28, latin: "Al Hakam", arabic: "Ø§Ù„Ø­ÙƒÙ…", arti: "Yang Maha Menetapkan" },
  { index: 29, latin: "Al 'Adl", arabic: "Ø§Ù„Ø¹Ø¯Ù„", arti: "Yang Maha Adil" },
  { index: 30, latin: "Al Lathiif", arabic: "Ø§Ù„Ù„Ø·ÙŠÙ", arti: "Yang Maha Lembut" },
  { index: 31, latin: "Al Khabiir", arabic: "Ø§Ù„Ø®Ø¨ÙŠØ±", arti: "Yang Maha Mengenal" },
  { index: 32, latin: "Al Haliim", arabic: "Ø§Ù„Ø­Ù„ÙŠÙ…", arti: "Yang Maha Penyantun" },
  { index: 33, latin: "Al 'Azhiim", arabic: "Ø§Ù„Ø¹Ø¸ÙŠÙ…", arti: "Yang Maha Agung" },
  { index: 34, latin: "Al Ghafuur", arabic: "Ø§Ù„ØºÙÙˆØ±", arti: "Yang Maha Memberi Pengampunan" },
  { index: 35, latin: "As Syakuur", arabic: "Ø§Ù„Ø´ÙƒÙˆØ±", arti: "Yang Maha Pembalas Budi" },
  { index: 36, latin: "Al 'Aliy", arabic: "Ø§Ù„Ø¹Ù„Ù‰", arti: "Yang Maha Tinggi" },
  { index: 37, latin: "Al Kabiir", arabic: "Ø§Ù„ÙƒØ¨ÙŠØ±", arti: "Yang Maha Besar" },
  { index: 38, latin: "Al Hafizh", arabic: "Ø§Ù„Ø­ÙÙŠØ¸", arti: "Yang Maha Memelihara" },
  { index: 39, latin: "Al Muqiit", arabic: "Ø§Ù„Ù…Ù‚ÙŠØª", arti: "Yang Maha Pemberi Kecukupan" },
  { index: 40, latin: "Al Hasiib", arabic: "Ø§Ù„Ø­Ø³ÙŠØ¨", arti: "Yang Maha Membuat Perhitungan" },
  { index: 41, latin: "Al Jaliil", arabic: "Ø§Ù„Ø¬Ù„ÙŠÙ„", arti: "Yang Maha Luhur" },
  { index: 42, latin: "Al Kariim", arabic: "Ø§Ù„ÙƒØ±ÙŠÙ…", arti: "Yang Maha Pemurah" },
  { index: 43, latin: "Ar Raqiib", arabic: "Ø§Ù„Ø±Ù‚ÙŠØ¨", arti: "Yang Maha Mengawasi" },
  { index: 44, latin: "Al Mujiib", arabic: "Ø§Ù„Ù…Ø¬ÙŠØ¨", arti: "Yang Maha Mengabulkan" },
  { index: 45, latin: "Al Waasi'", arabic: "Ø§Ù„ÙˆØ§Ø³Ø¹", arti: "Yang Maha Luas" },
  { index: 46, latin: "Al Hakiim", arabic: "Ø§Ù„Ø­ÙƒÙŠÙ…", arti: "Yang Maha Maka Bijaksana" },
  { index: 47, latin: "Al Waduud", arabic: "Ø§Ù„ÙˆØ¯ÙˆØ¯", arti: "Yang Maha Mengasihi" },
  { index: 48, latin: "Al Majiid", arabic: "Ø§Ù„Ù…Ø¬ÙŠØ¯", arti: "Yang Maha Mulia" },
  { index: 49, latin: "Al Baa'its", arabic: "Ø§Ù„Ø¨Ø§Ø¹Ø«", arti: "Yang Maha Membangkitkan" },
  { index: 50, latin: "As Syahiid", arabic: "Ø§Ù„Ø´Ù‡ÙŠØ¯", arti: "Yang Maha Menyaksikan" },
  { index: 51, latin: "Al Haqq", arabic: "Ø§Ù„Ø­Ù‚", arti: "Yang Maha Benar" },
  { index: 52, latin: "Al Wakiil", arabic: "Ø§Ù„ÙˆÙƒÙŠÙ„", arti: "Yang Maha Memelihara" },
  { index: 53, latin: "Al Qawiyyu", arabic: "Ø§Ù„Ù‚ÙˆÙ‰", arti: "Yang Maha Kuat" },
  { index: 54, latin: "Al Matiin", arabic: "Ø§Ù„Ù…ØªÙŠÙ†", arti: "Yang Maha Kokoh" },
  { index: 55, latin: "Al Waliyy", arabic: "Ø§Ù„ÙˆÙ„Ù‰", arti: "Yang Maha Melindungi" },
  { index: 56, latin: "Al Hamiid", arabic: "Ø§Ù„Ø­Ù…ÙŠØ¯", arti: "Yang Maha Terpuji" },
  { index: 57, latin: "Al Muhshii", arabic: "Ø§Ù„Ù…Ø­ØµÙ‰", arti: "Yang Maha Menghitung" },
  { index: 58, latin: "Al Mubdi'", arabic: "Ø§Ù„Ù…Ø¨Ø¯Ø¦", arti: "Yang Maha Memulai" },
  { index: 59, latin: "Al Mu'iid", arabic: "Ø§Ù„Ù…Ø¹ÙŠØ¯", arti: "Yang Maha Mengembalikan Kehidupan" },
  { index: 60, latin: "Al Muhyii", arabic: "Ø§Ù„Ù…Ø­ÙŠÙ‰", arti: "Yang Maha Menghidupkan" },
  { index: 61, latin: "Al Mumiitu", arabic: "Ø§Ù„Ù…Ù…ÙŠØª", arti: "Yang Maha Mematikan" },
  { index: 62, latin: "Al Hayyu", arabic: "Ø§Ù„Ø­ÙŠ", arti: "Yang Maha Hidup" },
  { index: 63, latin: "Al Qayyuum", arabic: "Ø§Ù„Ù‚ÙŠÙˆÙ…", arti: "Yang Maha Mandiri" },
  { index: 64, latin: "Al Waajid", arabic: "Ø§Ù„ÙˆØ§Ø¬Ø¯", arti: "Yang Maha Penemu" },
  { index: 65, latin: "Al Maajid", arabic: "Ø§Ù„Ù…Ø§Ø¬Ø¯", arti: "Yang Maha Mulia" },
  { index: 66, latin: "Al Waahid", arabic: "Ø§Ù„ÙˆØ§Ø­Ø¯", arti: "Yang Maha Tunggal" },
  { index: 67, latin: "Al Ahad", arabic: "Ø§Ù„Ø§Ø­Ø¯", arti: "Yang Maha Esa" },
  { index: 68, latin: "As Shamad", arabic: "Ø§Ù„ØµÙ…Ø¯", arti: "Yang Maha Dibutuhkan" },
  { index: 69, latin: "Al Qaadir", arabic: "Ø§Ù„Ù‚Ø§Ø¯Ø±", arti: "Yang Maha Menentukan" },
  { index: 70, latin: "Al Muqtadir", arabic: "Ø§Ù„Ù…Ù‚ØªØ¯Ø±", arti: "Yang Maha Berkuasa" },
  { index: 71, latin: "Al Muqaddim", arabic: "Ø§Ù„Ù…Ù‚Ø¯Ù…", arti: "Yang Maha Mendahulukan" },
  { index: 72, latin: "Al Mu'akkhir", arabic: "Ø§Ù„Ù…Ø¤Ø®Ø±", arti: "Yang Maha Mengakhirkan" },
  { index: 73, latin: "Al Awwal", arabic: "Ø§Ù„Ø£ÙˆÙ„", arti: "Yang Maha Awal" },
  { index: 74, latin: "Al Aakhir", arabic: "Ø§Ù„Ø£Ø®Ø±", arti: "Yang Maha Akhir" },
  { index: 75, latin: "Az Zhaahir", arabic: "Ø§Ù„Ø¸Ø§Ù‡Ø±", arti: "Yang Maha Nyata" },
  { index: 76, latin: "Al Baathin", arabic: "Ø§Ù„Ø¨Ø§Ø·Ù†", arti: "Yang Maha Ghaib" },
  { index: 77, latin: "Al Waali", arabic: "Ø§Ù„ÙˆØ§Ù„ÙŠ", arti: "Yang Maha Memerintah" },
  { index: 78, latin: "Al Muta'aalii", arabic: "Ø§Ù„Ù…ØªØ¹Ø§Ù„ÙŠ", arti: "Yang Maha Tinggi" },
  { index: 79, latin: "Al Barru", arabic: "Ø§Ù„Ø¨Ø±", arti: "Yang Maha Penderma" },
  { index: 80, latin: "At Tawwaab", arabic: "Ø§Ù„ØªÙˆØ§Ø¨", arti: "Yang Maha Penerima Tobat" },
  { index: 81, latin: "Al Muntaqim", arabic: "Ø§Ù„Ù…Ù†ØªÙ‚Ù…", arti: "Yang Maha Pemberi Balasan" },
  { index: 82, latin: "Al Afuww", arabic: "Ø§Ù„Ø¹ÙÙˆ", arti: "Yang Maha Pemaaf" },
  { index: 83, latin: "Ar Ra'uuf", arabic: "Ø§Ù„Ø±Ø¤ÙˆÙ", arti: "Yang Maha Pengasuh" },
  { index: 84, latin: "Malikul Mulk", arabic: "Ù…Ø§Ù„Ùƒ Ø§Ù„Ù…Ù„Ùƒ", arti: "Yang Maha Penguasa Kerajaan" },
  { index: 85, latin: "Dzul Jalaali Wal Ikraam", arabic: "Ø°Ùˆ Ø§Ù„Ø¬Ù„Ø§Ù„ Ùˆ Ø§Ù„Ø¥ÙƒØ±Ø§Ù…", arti: "Yang Maha Pemilik Kebesaran dan Kemuliaan" },
  { index: 86, latin: "Al Muqsith", arabic: "Ø§Ù„Ù…Ù‚Ø³Ø·", arti: "Yang Maha Pemberi Keadilan" },
  { index: 87, latin: "Al Jamii'", arabic: "Ø§Ù„Ø¬Ø§Ù…Ø¹", arti: "Yang Maha Mengumpulkan" },
  { index: 88, latin: "Al Ghaniyy", arabic: "Ø§Ù„ØºÙ†Ù‰", arti: "Yang Maha Kaya" },
  { index: 89, latin: "Al Mughnii", arabic: "Ø§Ù„Ù…ØºÙ†Ù‰", arti: "Yang Maha Pemberi Kekayaan" },
  { index: 90, latin: "Al Maani", arabic: "Ø§Ù„Ù…Ø§Ù†Ø¹", arti: "Yang Maha Mencegah" },
  { index: 91, latin: "Ad Dhaar", arabic: "Ø§Ù„Ø¶Ø§Ø±", arti: "Yang Maha Penimpa Kemudharatan" },
  { index: 92, latin: "An Nafii'", arabic: "Ø§Ù„Ù†Ø§ÙØ¹", arti: "Yang Maha Memberi Manfaat" },
  { index: 93, latin: "An Nuur", arabic: "Ø§Ù„Ù†ÙˆØ±", arti: "Yang Maha Bercahaya" },
  { index: 94, latin: "Al Haadi", arabic: "Ø§Ù„Ù‡Ø§Ø¯Ø¦", arti: "Yang Maha Pemberi Petunjuk" },
  { index: 95, latin: "Al Badii'", arabic: "Ø§Ù„Ø¨Ø¯ÙŠØ¹", arti: "Yang Maha Pencipta Tiada Bandingannya" },
  { index: 96, latin: "Al Baaqii", arabic: "Ø§Ù„Ø¨Ø§Ù‚ÙŠ", arti: "Yang Maha Kekal" },
  { index: 97, latin: "Al Waarits", arabic: "Ø§Ù„ÙˆØ§Ø±Ø«", arti: "Yang Maha Pewaris" },
  { index: 98, latin: "Ar Rasyiid", arabic: "Ø§Ù„Ø±Ø´ÙŠØ¯", arti: "Yang Maha Pandai" },
  { index: 99, latin: "As Shabuur", arabic: "Ø§Ù„ØµØ¨ÙˆØ±", arti: "Yang Maha Sabar" }
];

const dataBacaanSholat = {
  "takbir": { "title": "Takbiratul Ihram", "arabic": "Ø§Ù„Ù„Ù‡Ù Ø£ÙŽÙƒÙ’Ø¨ÙŽØ±Ù", "latin": "Allahu Akbar", "arti": "Allah Maha Besar" },
  "iftitah": { "title": "Doa Iftitah", "arabic": "Ø§Ù„Ù„Ù‡Ù Ø£ÙŽÙƒÙ’Ø¨ÙŽØ±Ù ÙƒÙŽØ¨ÙÙŠØ±Ù‹Ø§ ÙˆÙŽØ§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙŽÙ‡Ù ÙƒÙŽØ«ÙÙŠØ±Ù‹Ø§ ÙˆÙŽØ³ÙØ¨Ù’Ø­ÙŽØ§Ù†ÙŽ Ø§Ù„Ù„Ù‘ÙŽÙ‡Ù Ø¨ÙÙƒÙ’Ø±ÙŽØ©Ù‹ ÙˆÙŽØ£ÙŽØµÙÙŠÙ„Ø§Ù‹", "latin": "Allahu akbar kabiiro, walhamdulillahi katsiiro, wa subhanallahi bukrotaw wa'ashiila", "arti": "Allah Maha Besar dengan sebesar-besarnya, segala puji bagi Allah dengan pujian yang banyak, Maha Suci Allah pada waktu pagi dan petang." },
  "fatihah": { "title": "Al-Fatihah", "arabic": "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„Ù‘ÙŽÙ‡Ù Ø§Ù„Ø±Ù‘ÙŽØ­Ù’Ù…ÙŽÙ°Ù†Ù Ø§Ù„Ø±Ù‘ÙŽØ­ÙÙŠÙ…Ù...", "latin": "Bismillah hirrahman nirrahim...", "arti": "Dengan menyebut nama Allah Yang Maha Pengasih lagi Maha Penyayang..." },
  "ruku": { "title": "Ruku'", "arabic": "Ø³ÙØ¨Ù’Ø­ÙŽØ§Ù†ÙŽ Ø±ÙŽØ¨Ù‘ÙÙŠÙŽ Ø§Ù„Ù’Ø¹ÙŽØ¸ÙÙŠÙ…Ù ÙˆÙŽØ¨ÙØ­ÙŽÙ…Ù’Ø¯ÙÙ‡Ù", "latin": "Subhaana robbiyal 'adziimi wa bihamdih", "arti": "Maha Suci Tuhanku yang Maha Agung dan dengan memuji-Nya." },
  "itidal": { "title": "I'tidal", "arabic": "Ø³ÙŽÙ…ÙØ¹ÙŽ Ø§Ù„Ù„Ù‘ÙŽÙ‡Ù Ù„ÙÙ…ÙŽÙ†Ù’ Ø­ÙŽÙ…ÙØ¯ÙŽÙ‡Ù", "latin": "Sami'allaahu liman hamidah", "arti": "Allah Maha Mendengar orang yang memuji-Nya." },
  "sujud": { "title": "Sujud", "arabic": "Ø³ÙØ¨Ù’Ø­ÙŽØ§Ù†ÙŽ Ø±ÙŽØ¨Ù‘ÙÙŠÙŽ Ø§Ù„Ø£ÙŽØ¹Ù’Ù„ÙŽÙ‰ ÙˆÙŽØ¨ÙØ­ÙŽÙ…Ù’Ø¯ÙÙ‡Ù", "latin": "Subhaana robbiyal a'laa wa bihamdih", "arti": "Maha Suci Tuhanku Yang Maha Tinggi dan dengan memuji-Nya." },
  "tahiyat": { "title": "Tahiyat Akhir", "arabic": "Ø§Ù„ØªÙ‘ÙŽØ­ÙÙŠÙ‘ÙŽØ§ØªÙ Ø§Ù„Ù’Ù…ÙØ¨ÙŽØ§Ø±ÙŽÙƒÙŽØ§ØªÙ Ø§Ù„ØµÙ‘ÙŽÙ„ÙŽÙˆÙŽØ§ØªÙ Ø§Ù„Ø·Ù‘ÙŽÙŠÙ‘ÙØ¨ÙŽØ§ØªÙ Ù„ÙÙ„Ù‘ÙŽÙ‡Ù...", "latin": "Attahiyyaatul mubaarokaatush sholawaatuth thoyyibaatu lillaah...", "arti": "Segala kehormatan, keberkahan, rahmat dan kebaikan adalah milik Allah..." },
  "salam": { "title": "Salam", "arabic": "Ø§Ù„Ø³Ù‘ÙŽÙ„Ø§ÙŽÙ…Ù Ø¹ÙŽÙ„ÙŽÙŠÙ’ÙƒÙÙ…Ù’ ÙˆÙŽØ±ÙŽØ­Ù’Ù…ÙŽØ©Ù Ø§Ù„Ù„Ù‘ÙŽÙ‡Ù", "latin": "Assalaamu 'alaikum wa rohmatullaah", "arti": "Semoga keselamatan dan rahmat Allah dilimpahkan kepadamu." }
};

const dataDoaPilihan = {
    "qunut": {"title": "Doa Qunut", "arabic": "Ø§ÙŽÙ„Ù„Ù‘Ù‡ÙÙ…Ù‘ÙŽ Ø§Ù‡Ù’Ø¯ÙÙ†ÙÙ‰Ù’ ÙÙÙŠÙ’Ù…ÙŽÙ†Ù’ Ù‡ÙŽØ¯ÙŽÙŠÙ’ØªÙŽ...", "latin": "Allahummahdinii fiiman hadait...", "arti": "Ya Allah, berilah aku petunjuk di antara orang-orang yang Engkau beri petunjuk..."},
    "tahajud": {"title": "Doa Setelah Sholat Tahajud", "arabic": "Ø§ÙŽÙ„Ù„Ù‡Ù… Ø±ÙŽØ¨Ù‘ÙŽÙ†ÙŽØ§ Ù„ÙŽÙƒÙŽ Ø§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù...", "latin": "Allahumma robbana lakal hamdu...", "arti": "Ya Allah, Tuhan kami, segala puji bagi-Mu..."},
    "dhuha": {"title": "Doa Setelah Sholat Dhuha", "arabic": "Ø§ÙŽÙ„Ù„Ù‘Ù°Ù‡ÙÙ…Ù‘ÙŽ Ø§ÙÙ†Ù‘ÙŽ Ø§Ù„Ø¶Ù‘ÙØ­ÙŽØ¢Ø¡ÙŽ Ø¶ÙØ­ÙŽØ§Ø¡ÙÙƒÙŽ...", "latin": "Allahumma innad-duhaa'a duhaa'uka...", "arti": "Ya Allah, sesungguhnya waktu Dhuha adalah waktu Dhuha-Mu..."}
};

const dataHadits = [
  { "rawi": "Bukhari", "hadits": "Sesungguhnya setiap amalan bergantung pada niatnya." },
  { "rawi": "Muslim", "hadits": "Barangsiapa yang menunjuki kepada kebaikan maka dia akan mendapatkan pahala seperti pahala orang yang mengerjakannya." },
  { "rawi": "Tirmidzi", "hadits": "Senyummu di hadapan saudaramu adalah sedekah." },
  { "rawi": "Bukhari", "hadits": "Orang yang paling baik di antara kalian adalah yang paling baik akhlaknya." },
  { "rawi": "Muslim", "hadits": "Kebersihan adalah sebagian dari iman." }
];

// Helper function untuk format kotak
function formatBoxes(boxes) {
    let result = '';
    for (let i = 0; i < 10; i++) {
        result += `${i+1}. ${boxes[i]} `;
        if ((i+1) % 5 === 0) result += '\n';
    }
    return result;
}

function capital(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const DB_DIR = path.join(__dirname, 'library', 'database');

if (!fs.existsSync(DB_DIR)) {
    fs.mkdirSync(DB_DIR, { recursive: true });
}

global.ultahdb = global.ultahdb || {};
const ultahPath = path.join(DB_DIR, 'ultah.json');

function saveUltahDb() {
    fs.writeFileSync(ultahPath, JSON.stringify(global.ultahdb, null, 2));
}

function loadUltahDb() {
    if (fs.existsSync(ultahPath)) {
        global.ultahdb = JSON.parse(fs.readFileSync(ultahPath, 'utf-8'));
    }
}
loadUltahDb();

function getDaysUntil(dateStr) {
    const [day, month] = dateStr.split('/').map(Number);
    const now = new Date();
    const currentYear = now.getFullYear();
    let nextBirthday = new Date(currentYear, month - 1, day);
    
    if (now.getDate() === day && now.getMonth() === (month - 1)) {
        return 0;
    }
    
    if (now > nextBirthday) {
        nextBirthday = new Date(currentYear + 1, month - 1, day);
    }
    
    const diffTime = nextBirthday.getTime() - now.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return diffDays;
}

function getBirthdayQuote(userName) {
    const quotes = [
        `Selamat ulang tahun ke *${userName}*! Satu tahun lebih bijaksana, satu tahun lebih keren. Semoga tahun ini penuh kejutan luar biasa dan kebahagiaan tak terhingga. Nikmati hari spesialmu, bintang di langit grup ini!`,
        `Untuk *${userName}* yang sedang merayakan hari kelahirannya, semoga setiap langkah di tahun yang baru ini dipenuhi dengan tawa, cinta, dan pencapaian spektakuler. Dunia adalah panggungmu, tunjukkan yang terbaik!`,
        `Hey, *${userName}*! Hari ini adalah harimu. Semoga semua impianmu lepas landas seperti roket. Terima kasih sudah menjadi bagian dari grup ini. Mari kita buat pesta kenangan yang tak terlupakan!`,
        `Tiup lilinnya! Selamat ulang tahun, *${userName}*. Semoga kamu terus menjadi inspirasi bagi kami semua dan semoga rezekimu mengalir deras seperti air terjun. Rayakan sepuasnya!`,
        `Happy Birthday, *${userName}*! Jangan pernah berhenti mengejar hal-hal yang membuat jiwamu bersinar. Ingatlah bahwa kami semua bangga memilikimu di sini. Nikmati setiap detik hari ini!`,
    ];
    return quotes[Math.floor(Math.random() * quotes.length)];
}

// ========== UPLOADER FUNCTIONS ==========

// Ryzumi Uploader
async function uploadRyzumi(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');
        const filename = generateFilename(mimeType);
        const data = new FormData();
        data.append('file', buffer, { filename });

        const { data: result } = await axios.post('https://api.ryzumi.vip/api/uploader/ryzencdn', data, { 
            headers: { 
                ...data.getHeaders(), 
                referrer: "https://api.ryzumi.vip/" 
            } 
        });
        return result;
    } catch (e) {
        console.error('Ryzumi Upload Error:', e.message);
        return null;
    }
}

// Qu Uploader
async function uploadQu(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');
        const form = new FormData();
        const filename = generateFilename(mimeType);

        form.append('files[]', buffer, { filename });
        form.append('expiry', '-1');

        const { files } = await axios.post("https://qu.ax/upload.php", form, {
            headers: {
                ...form.getHeaders(),
                "referrer": "https://qu.ax/"
            }
        }).then(a => a.data);

        return files[0] || null;
    } catch (e) {
        console.error('Qu Upload Error:', e.message);
        return null;
    }
}

// Top4Top Uploader
async function uploadTop4Top(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');
        const origin = 'https://top4top.io';
        const data = new FormData();
        const filename = generateFilename(mimeType);
        
        // Dapatkan extension dari filename
        const ext = filename.split('.').pop();
        
        data.append('file_1_', buffer, { filename });
        data.append('submitr', '[ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ]');

        const r = await fetch(origin + '/index.php', {
            method: 'POST',
            body: data
        });
        
        if (!r.ok) throw Error(`${r.status} ${r.statusText}\n${await r.text()}`);
        
        const html = await r.text();
        const matches = html.matchAll(/<input readonly="readonly" class="all_boxes" onclick="this.select\(\);" type="text" value="(.+?)" \/>/g);
        const arr = Array.from(matches);
        
        if (!arr.length) throw Error('Failed to upload file');
        
        const downloadUrl = arr.map(v => v[1]).find(v => v.endsWith(ext));
        const deleteUrl = arr.map(v => v[1]).find(v => v.endsWith('html'));
        const qrcodeUrl = origin + '/' + html.match(/<div class="qr_img"><img src="(.+?)"/)?.[1];
        
        return {
            downloadUrl,
            deleteUrl,
            qrcodeUrl
        };
    } catch (e) {
        console.error('Top4Top Upload Error:', e.message);
        return null;
    }
}

// Catbox Uploader
async function uploadCatbox(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');
        const filename = generateFilename(mimeType);
        const data = new FormData();
        
        data.append('reqtype', 'fileupload');
        data.append('userhash', '');
        data.append('fileToUpload', buffer, { filename });

        const result = await axios.post('https://catbox.moe/user/api.php', data, {
            headers: {
                ...data.getHeaders(),
                'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0'
            }
        });

        return result.data;
    } catch (err) {
        console.error('Catbox Upload Error:', err.message);
        return null;
    }
}

// elaina upload
async function uploadElaina(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) return null;
        const filename = generateFilename(mimeType);
        
        const FormData = require('form-data');
        const form = new FormData();
        form.append('cdnFile', buffer, filename);
        
        const { data } = await axios.post('https://elainaacdn.vercel.app/upload', form, {
            headers: form.getHeaders()
        });
        
        return data?.url || null;
    } catch (e) {
        return null;
    }
}

// Pixhost 
async function uploadPixhost(buffer, filename = "file.jpg") {
    try {
        const service = new ImageUploadService('pixhost.to');
        const { directLink } = await service.uploadFromBinary(buffer, filename);
        return directLink;
    } catch (e) {
        console.error('Pixhost Upload Error:', e.message);
        return null;
    }
}

// Uguu Uploader 
async function uploadUguu(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');
        
        const filename = generateFilename(mimeType);
        const formData = new FormData();
        formData.append("files[]", buffer, { filename });

        const response = await fetch("https://uguu.se/upload.php", {
            method: "POST",
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            body: formData
        });

        if (!response.ok) throw new Error(`Upload failed: ${response.status}`);
        
        const json = await response.json();
        if (!json?.files?.[0]?.url) throw new Error('Invalid response format');
        
        return json.files[0].url;
    } catch (e) {
        console.error('Uguu Upload Error:', e.message);
        return null;
    }
}

// Fungsi upload ke GitHub
async function uploadGitHub(buffer, mimeType, generateFilename) {
    const githubToken = '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'; 
    const owner = 'alifalfarel25-commits'; 
    const branch = 'main';
    let repos = ['dat1', 'dat2', 'dat3', 'dat4']; 
    async function ensureRepoExists(repo) {
        try {
            await axios.get(`https://api.github.com/repos/${owner}/${repo}`, {
                headers: { Authorization: `Bearer ${githubToken}` }
            });
            return true;
        } catch (e) {
            if (e.response?.status === 404) {
                await axios.post(`https://api.github.com/user/repos`,
                    { 
                        name: repo, 
                        private: false,
                        auto_init: true
                    },
                    { 
                        headers: { 
                            Authorization: `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github+json'
                        } 
                    }
                );
                if (!repos.includes(repo)) repos.push(repo);
                return true;
            } else {
                console.error('GitHub repo check error:', e.response?.data || e.message);
                throw e;
            }
        }
    }
    
    function getExtension(mimeType) {
        const extensions = {
            'image/jpeg': 'jpg',
            'image/jpg': 'jpg',
            'image/png': 'png',
            'image/gif': 'gif',
            'image/webp': 'webp',
            'video/mp4': 'mp4',
            'video/3gpp': '3gp',
            'video/quicktime': 'mov',
            'video/x-msvideo': 'avi',
            'audio/mpeg': 'mp3',
            'audio/ogg': 'ogg',
            'audio/aac': 'aac',
            'application/pdf': 'pdf',
            'application/zip': 'zip',
            'application/vnd.rar': 'rar',
            'text/plain': 'txt',
            'application/msword': 'doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx'
        };
        return extensions[mimeType] || 'bin';
    }
    
    try {
        if (buffer.length > 25 * 1024 * 1024) {
            throw new Error('File terlalu besar! Maksimal 25MB untuk GitHub.');
        }
        
        const ext = getExtension(mimeType);
        const code = crypto.randomBytes(3).toString('hex');
        const fileName = `alip-clutch-${Date.now()}.${ext}`;
        const filePathGitHub = `uploads/${fileName}`;
        const base64Content = buffer.toString('base64');
        let targetRepo = repos[Math.floor(Math.random() * repos.length)];
        await ensureRepoExists(targetRepo);
        const response = await axios.put(
            `https://api.github.com/repos/${owner}/${targetRepo}/contents/${filePathGitHub}`,
            { 
                message: `Upload file ${fileName} via bot`, 
                content: base64Content, 
                branch: branch 
            },
            { 
                headers: { 
                    Authorization: `Bearer ${githubToken}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github+json'
                },
                timeout: 30000 
            }
        );
        return `https://raw.githubusercontent.com/${owner}/${targetRepo}/${branch}/${filePathGitHub}`;
        
    } catch (error) {
        console.error('GitHub upload error:', error.response?.data || error.message);
        if (error.response?.status === 401) {
            throw new Error('GitHub token invalid! Periksa token Anda.');
        } else if (error.response?.status === 403) {
            throw new Error('Rate limit GitHub terlampaui! Coba lagi nanti.');
        } else if (error.code === 'ECONNABORTED') {
            throw new Error('Timeout menghubungi GitHub. Coba lagi.');
        } else {
            throw new Error(`GitHub upload gagal: ${error.message}`);
        }
    }
}

// Nauval/Yupra Uploader 
async function uploadNauval(buffer, mimeType, generateFilename) {
    try {
        if (!buffer) throw new Error('No buffer provided');

        const filename = generateFilename(mimeType);
        const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        const formData = new FormData();
        formData.append("file", buffer, { filename });
        formData.append("filename", filename.split('.')[0]); 
        formData.append("expire_value", "30");
        formData.append("expire_unit", "minutes");
        formData.append("upload_id", uploadId);

        const response = await fetch("https://nauval.cloud/upload", {
            method: "POST",
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            body: formData
        });

        if (!response.ok) throw new Error(`Upload failed: ${response.status}`);
        
        const json = await response.json();
        if (!json?.file_url) throw new Error('Invalid response format');
        
        return json.file_url.trim();
    } catch (e) {
        console.error('Nauval Upload Error:', e.message);
        return null;
    }
}

function splitLongMessage(text, maxLength = 4000) {
    const parts = [];
    let currentPart = '';
    const lines = text.split('\n');
    
    for (const line of lines) {
        if ((currentPart + line + '\n').length > maxLength) {
            parts.push(currentPart);
            currentPart = line + '\n';
        } else {
            currentPart += line + '\n';
        }
    }
    
    if (currentPart) {
        parts.push(currentPart);
    }
    
    return parts;
}

// ============ COMMAND HANDLER ============
switch (command) {

case 'enccustom':
case 'encryptcustom':
case 'encrypt-custom':
case 'customenc':
case 'custom-encrypt':
case 'enc-custom':
case 'enccustomjs':
case 'encryptcustomjs':
case 'customjsen':
case 'jscustomenc': {
    if (!m.quoted) return Reply('Kutip file .js untuk dienkripsi!')
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        const args = (body || '').trim().split(/\s+/)
        const customName = (args[0] || '').replace(/[^a-zA-Z0-9_]/g, '')
        if (!customName) return Reply(`Format: ${prefix}${command} <nama>\nContoh: ${prefix}${command} myid`)

        const fileName = m.quoted?.msg?.fileName || m.quoted?.fileName || ''
        if (!fileName.endsWith('.js')) return Reply('Kutip file `.js` untuk dienkripsi!')

        const idGen = () => {
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
            let suf = ''
            for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) suf += chars[Math.floor(Math.random() * chars.length)]
            return `${customName}_${suf}`
        }

        const getCustomObf = () => ({
            target: 'node',
            compact: true,
            renameVariables: true,
            renameGlobals: true,
            identifierGenerator: idGen,
            stringEncoding: true,
            stringSplitting: true,
            controlFlowFlattening: 0.75,
            shuffle: true,
            duplicateLiteralsRemoval: true,
            deadCode: true,
            calculator: true,
            opaquePredicates: true,
            lock: {
                selfDefending: true,
                antiDebug: true,
                integrity: true,
                tamperProtection: true
            }
        })

        let mediaBuffer
        if (m.quoted.msg?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.msg.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else if (m.quoted?.message?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.message.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else {
            return Reply('Tidak bisa mendapatkan file dari pesan yang dikutip')
        }

        const raw = mediaBuffer.toString('utf8')

        try {
            new Function(raw)
        } catch (e) {
            return Reply(`âŒ File JS tidak valid:\n${e.message}`)
        }

        await alip.sendMessage(m.chat, { react: { text: "âš™ï¸", key: m.key } })
        
        await Reply('â³ *Memproses custom encrypt...*')

        const JsConfuser = require('js-confuser')
        const obf = await JsConfuser.obfuscate(raw, getCustomObf())
        const code = typeof obf === 'string' ? obf : (obf && obf.code) || String(obf)

        const outName = `custom-encrypted-${customName}-${Date.now()}.js`
        const outPath = path.join(__dirname, outName)
        fs.writeFileSync(outPath, code, 'utf8')

        const fileBuffer = fs.readFileSync(outPath)
        await alip.sendMessage(m.chat, {
            document: fileBuffer,
            mimetype: 'application/javascript',
            fileName: outName,
            caption: `âœ… *Custom encrypted (${customName})!*`
        }, {
            quoted: m
        })

        try {
            fs.unlinkSync(outPath)
        } catch (e) {}
    } catch (err) {
        console.error(err)
        Reply(`âŒ Terjadi kesalahan: ${err && err.message ? err.message : String(err)}`)
    }
}
break;

case 'encinvis':
case 'encryptinvis':
case 'encrypt-invis':
case 'invisenc':
case 'invis-encrypt':
case 'enc-invis':
case 'encinvisible':
case 'encryptinvisible':
case 'encrypt-invisible':
case 'invisibleenc':
case 'invisible-encrypt':
case 'enc-invisible':
case 'eninvisiblejs':
case 'jsinvisenc':
case 'encjsinvis': {
    if (!m.quoted) return Reply('Kutip pesan dokumen!')
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        const fileName = m.quoted?.msg?.fileName || m.quoted?.fileName || ''
        if (!fileName.endsWith('.js')) return Reply('Kutip file `.js` untuk dienkripsi!')

        const genInvis = () => '_'.repeat(Math.floor(Math.random() * 4) + 3) + Math.random().toString(36).slice(2, 5)
        const getInvisObf = () => ({
            target: 'node',
            compact: true,
            renameVariables: true,
            renameGlobals: true,
            identifierGenerator: genInvis,
            stringEncoding: true,
            stringSplitting: true,
            controlFlowFlattening: 0.95,
            shuffle: true,
            duplicateLiteralsRemoval: true,
            deadCode: true,
            calculator: true,
            opaquePredicates: true,
            lock: {
                selfDefending: true,
                antiDebug: true,
                integrity: true,
                tamperProtection: true
            }
        })

        let mediaBuffer
        if (m.quoted.msg?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.msg.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else if (m.quoted?.message?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.message.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else {
            return Reply('Tidak bisa mendapatkan file dari pesan yang dikutip')
        }

        const raw = mediaBuffer.toString('utf8')

        try {
            new Function(raw)
        } catch (e) {
            return Reply(`âŒ File JS tidak valid:\n${e.message}`)
        }

        await alip.sendMessage(m.chat, { react: { text: "ðŸ‘»", key: m.key } })
        
        await Reply('â³ *Memproses invisible encrypt...*')

        const JsConfuser = require('js-confuser')
        const obf = await JsConfuser.obfuscate(raw, getInvisObf())
        const code = typeof obf === 'string' ? obf : (obf && obf.code) || String(obf)

        const outName = `invis-encrypted-${Date.now()}.js`
        const outPath = path.join(__dirname, outName)
        fs.writeFileSync(outPath, code, 'utf8')

        const fileBuffer = fs.readFileSync(outPath)
        await alip.sendMessage(m.chat, {
            document: fileBuffer,
            mimetype: 'application/javascript',
            fileName: outName,
            caption: 'âœ… *Invisible encrypted siap!*'
        }, {
            quoted: m
        })

        try {
            fs.unlinkSync(outPath)
        } catch (e) {}
    } catch (err) {
        console.error(err)
        Reply(`âŒ Terjadi kesalahan: ${err && err.message ? err.message : String(err)}`)
    }
}
break;

case 'encsiu':
case 'encryptsiu':
case 'encrypt-siu':
case 'siuenc':
case 'siu-encrypt':
case 'enc-siu':
case 'encsiujs':
case 'jssiuenc':
case 'siujsen': {
    if (!m.quoted) return Reply('Kutip pesan dokumen!')
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        const fileName = m.quoted?.msg?.fileName || m.quoted?.fileName || ''
        if (!fileName.endsWith('.js')) return Reply('Kutip file `.js` untuk dienkripsi!')

        const genSiu = () => {
            const abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
            let r = ''
            for (let i = 0; i < 6; i++) r += abc[Math.floor(Math.random() * abc.length)]
            return `CalceKarikå’ŒSiuSiu${r}`
        }

        const getSiuObf = () => ({
            target: 'node',
            compact: true,
            renameVariables: true,
            renameGlobals: true,
            identifierGenerator: genSiu,
            stringCompression: true,
            stringEncoding: true,
            stringSplitting: true,
            controlFlowFlattening: 0.95,
            flatten: true,
            shuffle: true,
            duplicateLiteralsRemoval: true,
            deadCode: true,
            calculator: true,
            opaquePredicates: true,
            lock: {
                selfDefending: true,
                antiDebug: true,
                integrity: true,
                tamperProtection: true
            }
        })

        let mediaBuffer
        if (m.quoted.msg?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.msg.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else if (m.quoted?.message?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.message.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else {
            return Reply('Tidak bisa mendapatkan file dari pesan yang dikutip')
        }

        const raw = mediaBuffer.toString('utf8')

        try {
            new Function(raw)
        } catch (e) {
            return Reply(`âŒ File JS tidak valid:\n${e.message}`)
        }

        await alip.sendMessage(m.chat, { react: { text: "ðŸ”¥", key: m.key } })
        
        await Reply('â³ *Memproses SIU encrypt...*')

        const JsConfuser = require('js-confuser')
        const obf = await JsConfuser.obfuscate(raw, getSiuObf())
        const code = typeof obf === 'string' ? obf : (obf && obf.code) || String(obf)

        const outName = `siu-encrypted-${Date.now()}.js`
        const outPath = path.join(__dirname, outName)
        fs.writeFileSync(outPath, code, 'utf8')

        const fileBuffer = fs.readFileSync(outPath)
        await alip.sendMessage(m.chat, {
            document: fileBuffer,
            mimetype: 'application/javascript',
            fileName: outName,
            caption: 'âœ… *Calcrick Chaos Core encrypted!*'
        }, {
            quoted: m
        })

        try {
            fs.unlinkSync(outPath)
        } catch (e) {}
    } catch (err) {
        console.error(err)
        Reply(`âŒ Terjadi kesalahan: ${err && err.message ? err.message : String(err)}`)
    }
}
break;

case 'encstrong':
case 'encryptstrong':
case 'encrypt-strong':
case 'strongenc':
case 'strong-encrypt':
case 'enc-strong':
case 'encstrongjs':
case 'jsstrongenc':
case 'strongjsen': {
    if (!m.quoted) return Reply('Kutip pesan dokumen!')
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        const fileName = m.quoted?.msg?.fileName || m.quoted?.fileName || ''
        if (!fileName.endsWith('.js')) return Reply('Kutip file `.js` untuk dienkripsi!')

        const getStrongObf = () => ({
            target: 'node',
            compact: true,
            renameVariables: true,
            renameGlobals: true,
            identifierGenerator: 'randomized',
            stringEncoding: true,
            stringSplitting: true,
            controlFlowFlattening: 0.75,
            shuffle: true,
            duplicateLiteralsRemoval: true,
            calculator: true,
            dispatcher: true,
            deadCode: true,
            opaquePredicates: true,
            lock: {
                selfDefending: true,
                antiDebug: true,
                integrity: true,
                tamperProtection: true
            }
        })

        let mediaBuffer
        if (m.quoted.msg?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.msg.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else if (m.quoted?.message?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.message.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else {
            return Reply('Tidak bisa mendapatkan file dari pesan yang dikutip')
        }

        const raw = mediaBuffer.toString('utf8')

        try {
            new Function(raw)
        } catch (e) {
            return Reply(`âŒ File JS tidak valid:\n${e.message}`)
        }

        await alip.sendMessage(m.chat, { react: { text: "ðŸ›¡ï¸", key: m.key } })
        
        await Reply('â³ *Memproses strong encrypt...*')

        const JsConfuser = require('js-confuser')
        const obf = await JsConfuser.obfuscate(raw, getStrongObf())
        const code = typeof obf === 'string' ? obf : (obf && obf.code) || String(obf)

        const outName = `strong-encrypted-${Date.now()}.js`
        const outPath = path.join(__dirname, outName)
        fs.writeFileSync(outPath, code, 'utf8')

        const fileBuffer = fs.readFileSync(outPath)
        await alip.sendMessage(m.chat, {
            document: fileBuffer,
            mimetype: 'application/javascript',
            fileName: outName,
            caption: 'âœ… *Hardened Strong encrypted!* â€” SATURN ðŸ”¥'
        }, {
            quoted: m
        })

        try {
            fs.unlinkSync(outPath)
        } catch (e) {}
    } catch (err) {
        console.error(err)
        Reply(`âŒ Terjadi kesalahan: ${err && err.message ? err.message : String(err)}`)
    }
}
break;

case 'encultra':
case 'encryptultra':
case 'encrypt-ultra':
case 'ultraenc':
case 'ultra-encrypt':
case 'enc-ultra':
case 'encultrajs':
case 'jsultraenc':
case 'ultrajsen': {
    if (!m.quoted) return Reply('Kutip pesan dokumen!')
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        const fileName = m.quoted?.msg?.fileName || m.quoted?.fileName || ''
        if (!fileName.endsWith('.js')) return Reply('Kutip file `.js` untuk dienkripsi!')

        const genUltra = () => {
            const chars = 'abcdefghijklmnopqrstuvwxyz'
            const nums = '0123456789'
            return 'z' + nums[Math.floor(Math.random() * nums.length)] + chars[Math.floor(Math.random() * chars.length)] + Math.random().toString(36).slice(2, 6)
        }

        const getUltraObf = () => ({
            target: 'node',
            compact: true,
            renameVariables: true,
            renameGlobals: true,
            identifierGenerator: genUltra,
            stringCompression: true,
            stringEncoding: true,
            stringSplitting: true,
            controlFlowFlattening: 0.9,
            flatten: true,
            shuffle: true,
            rgf: true,
            deadCode: true,
            opaquePredicates: true,
            dispatcher: true,
            lock: {
                selfDefending: true,
                antiDebug: true,
                integrity: true,
                tamperProtection: true
            }
        })

        let mediaBuffer
        if (m.quoted.msg?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.msg.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else if (m.quoted?.message?.documentMessage) {
            const media = await downloadContentFromMessage(m.quoted.message.documentMessage, 'document')
            let buffer = Buffer.from([])
            for await (const chunk of media) buffer = Buffer.concat([buffer, chunk])
            mediaBuffer = buffer
        } else {
            return Reply('Tidak bisa mendapatkan file dari pesan yang dikutip')
        }

        const raw = mediaBuffer.toString('utf8')

        try {
            new Function(raw)
        } catch (e) {
            return Reply(`âŒ File JS tidak valid:\n${e.message}`)
        }

        await alip.sendMessage(m.chat, { react: { text: "ðŸš€", key: m.key } })
        
        await Reply('â³ *Memproses ultra encrypt...*')

        const JsConfuser = require('js-confuser')
        const obf = await JsConfuser.obfuscate(raw, getUltraObf())
        const code = typeof obf === 'string' ? obf : (obf && obf.code) || String(obf)

        const outName = `ultra-encrypted-${Date.now()}.js`
        const outPath = path.join(__dirname, outName)
        fs.writeFileSync(outPath, code, 'utf8')

        const fileBuffer = fs.readFileSync(outPath)
        await alip.sendMessage(m.chat, {
            document: fileBuffer,
            mimetype: 'application/javascript',
            fileName: outName,
            caption: 'âœ… *Hardened Ultra encrypted!* â€” SATURN ðŸ”¥'
        }, {
            quoted: m
        })

        try {
            fs.unlinkSync(outPath)
        } catch (e) {}
    } catch (err) {
        console.error(err)
        Reply(`âŒ Terjadi kesalahan: ${err && err.message ? err.message : String(err)}`)
    }
}
break;
case 'toproblox': {
    await m.reply(`â³ *Top 10 Roblox Game Trending...*`);

    try {
        const hit = async (url, options, type = "json") => {
            const response = await fetch(url, options);
            if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
            const ab = await response.arrayBuffer();
            return type === "json" ? JSON.parse(Buffer.from(ab).toString()) : Buffer.from(ab);
        };

        const customMappingNumber = (input) => {
            const char = ['ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ§', 'ðŸ¨', 'ðŸ©', 'ðŸª', 'ðŸ©', 'ðŸª', 'ðŸ«'];
            return String(input).split("").map(v => isNaN(v) ? v : char[v]).join("");
        };

        const api1 = `https://apis.roblox.com/explore-api/v1/get-sort-content?sessionId=17996246-1290-440d-b789-d49484115b9a&sortId=top-playing-now&cpuCores=8&maxResolution=1920x1080&maxMemory=8192&networkType=4g`;
        const json1 = await hit(api1, { method: 'GET' }, 'json');
        const gameList = json1?.games?.slice(0, 10);
        
        if (!gameList || gameList.length === 0) return Reply("âŒ Gagal mendapatkan list game.");

        let caption = `*TOP 10 PLAYING NOW GAMES ON ROBLOX 2026*\n\n`;
        
        for (let i = 0; i < gameList.length; i++) {
            const v = gameList[i];
            const likes = v.totalUpVotes + v.totalDownVotes > 0 
                ? ((v.totalUpVotes / (v.totalUpVotes + v.totalDownVotes)) * 100).toFixed(0)
                : "0";
            
            caption += `${i + 1}. ${v.name}\n`;
            caption += `   ðŸ‘¥ Player: ${customMappingNumber(v.playerCount.toLocaleString("id-ID"))}\n`;
            caption += `   ðŸ‘ Likes: ${customMappingNumber(likes)}%\n`;
            caption += `   ðŸŽ® Play: .https://www.roblox.com/games/${v.rootPlaceId}\n\n`;
        }
        
        caption += `Â© ${botname2}`;

        await alip.sendMessage(m.chat, { 
            text: caption 
        }, { quoted: m });

    } catch (err) {
        console.error(err);
        Reply(`âŒ Terjadi kesalahan: ${err.message}`);
    }
}
break;
case 'renamebot': {
    if (!isCreator) return Reply(global.mess.owner);
    
    const args = text.split(' ');
    const settingName = args[0];
    const newValue = args.slice(1).join(' ');
    
    if (!settingName || !newValue) {
        const availableSettings = `1. owner - Nomor WhatsApp owner\n2. namaOwner - Nama owner\n3. packname - Packname sticker\n4. botname - Nama bot\n5. botname2 - Nama bot alternatif\n6. linkOwner - Link WhatsApp owner\n7. linkGrup - Link grup bot\n8. linkSaluran - Link channel\n9. idSaluran - ID channel\n10. namaSaluran - Nama channel\n\nContoh:\n${prefix}renamebot botname Alip Bot MD\n${prefix}renamebot owner 6281234567890\n\n> *gunakan .idch untuk cek id saluran*`;
        return Reply(availableSettings);
    }
    
    const validSettings = {
        'owner': 'owner',
        'namaowner': 'namaOwner',
        'packname': 'packname',
        'botname': 'botname',
        'botname2': 'botname2',
        'linkowner': 'linkOwner',
        'linkgrup': 'linkGrup',
        'linksaluran': 'linkSaluran',
        'idsaluran': 'idSaluran',
        'namasaluran': 'namaSaluran'
    };
    
    const normalizedSetting = settingName.toLowerCase();
    if (!validSettings[normalizedSetting]) {
        return Reply(`Setting "${settingName}" tidak valid!`);
    }
    
    const actualSettingName = validSettings[normalizedSetting];
    
    try {
        const fs = require('fs');
        const path = './settings.js';
        
        if (!fs.existsSync(path)) {
            return Reply('File settings.js tidak ditemukan');
        }
        
        let settingContent = fs.readFileSync(path, 'utf8');
        
        let regex;
        if (actualSettingName === 'owner') {
            regex = new RegExp(`global\\.${actualSettingName}\\s*=\\s*['"][^'"]*['"]`, 'g');
        } else {
            regex = new RegExp(`${actualSettingName}\\s*=\\s*['"][^'"]*['"]`, 'g');
        }
        
        if (regex.test(settingContent)) {
            let newContent;
            if (actualSettingName === 'owner') {
                newContent = settingContent.replace(regex, `global.${actualSettingName} = "${newValue}"`);
            } else {
                newContent = settingContent.replace(regex, `${actualSettingName} = "${newValue}"`);
            }
            
            fs.writeFileSync(path, newContent);
            
            if (global[actualSettingName] !== undefined) {
                global[actualSettingName] = newValue;
            }
            
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
            Reply(`Berhasil rename ${actualSettingName} ke:\n"${newValue}"`);
            
            delete require.cache[require.resolve('./settings.js')];
            require('./settings.js');
            
        } else {
            Reply(`Setting "${actualSettingName}" tidak ditemukan di settings.js`);
        }
        
    } catch (error) {
        console.error('Renamebot error:', error);
        Reply('Terjadi error saat mengedit file settings.js');
    }
}
break;

case 'setpanel': {
    if (!isCreator) return Reply(global.mess.owner);
    
    const args = text.split(' ');
    const settingName = args[0];
    const newValue = args.slice(1).join(' ');
    
    if (!settingName || !newValue) {
        const availableSettings = `1. egg - Egg ID\n2. nestid - Nest ID\n3. loc - Location ID\n4. domain - Domain panel\n5. apikey - API Key (ptla)\n6. capikey - Client API Key (ptlc)\n\nContoh:\n${prefix}setpanel domain https://panel.example.com`;
        return Reply(availableSettings);
    }
    
    const validSettings = {
        'egg': 'egg',
        'nestid': 'nestid',
        'loc': 'loc',
        'domain': 'domain',
        'apikey': 'apikey',
        'capikey': 'capikey'
    };
    
    const normalizedSetting = settingName.toLowerCase();
    if (!validSettings[normalizedSetting]) {
        return Reply(`Panel setting "${settingName}" tidak valid!`);
    }
    
    const actualSettingName = validSettings[normalizedSetting];
    
    try {
        const fs = require('fs');
        const path = './settings.js';
        
        if (!fs.existsSync(path)) {
            return Reply('File settings.js tidak ditemukan');
        }
        
        let settingContent = fs.readFileSync(path, 'utf8');
        
        let regex;
        if (actualSettingName === 'domain') {
            regex = new RegExp(`${actualSettingName}\\s*=\\s*['"][^'"]*['"]`, 'g');
        } else {
            regex = new RegExp(`${actualSettingName}\\s*=\\s*['"][^'"]*['"]`, 'g');
        }
        
        if (regex.test(settingContent)) {
            const newContent = settingContent.replace(regex, `${actualSettingName} = "${newValue}"`);
            fs.writeFileSync(path, newContent);
            
            if (global[actualSettingName] !== undefined) {
                global[actualSettingName] = newValue;
            }
            
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
            Reply(`Berhasil mengubah ${actualSettingName} ke:\n"${newValue}"`);
        } else {
            Reply(`Panel setting "${actualSettingName}" tidak ditemukan di settings.js`);
        }
        
    } catch (error) {
        console.error('Setpanel error:', error);
        Reply('Terjadi error saat mengedit file settings.js');
    }
}
break;
case 'setaudiomenu': {
    if (!isCreator) return Reply('âŒ Owner only!');
    
    if (!m.quoted || !(m.quoted.audioMessage || m.quoted.msg?.audioMessage)) {
        return Reply(`âŒ Reply audio dengan caption: ${prefix}setaudiomenu`);
    }
    
    try {
        await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
        
        const mediaBuffer = await downloadContentFromMessage(m.quoted.msg?.audioMessage || m.quoted.audioMessage, 'audio');
        let bufferArray = [];
        for await (const chunk of mediaBuffer) {
            bufferArray.push(chunk);
        }
        const buffer = Buffer.concat(bufferArray);
        
        const audioPath = './source/media/alip.mp3';
        
        fs.writeFileSync(audioPath, buffer);
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        Reply('âœ… Berhasil mengganti audio menu (alip.mp3)');
        
    } catch (error) {
        console.error('Setaudiomenu error:', error);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal mengganti audio menu');
    }
}
break;
case 'setimg':
case 'setimage': {
    if (!isCreator) return Reply(global.mess.owner);
    
    const args = text.split(' ');
    const type = args[0]?.toLowerCase();
    
    const validTypes = ['menu', 'reply', 'menuv2', 'menuvideo'];
    
    if (!type || !validTypes.includes(type)) {
        return Reply(`Contoh:\n${prefix}setimg menu\n${prefix}setimg reply\n${prefix}setimg menuv2\n${prefix}setimg menuvideo\n\nReply gambar/video dengan caption tersebut`);
    }
    
    if (type === 'menuvideo') {
        if (!m.quoted || !(m.quoted.videoMessage || m.quoted.msg?.videoMessage)) {
            return Reply(`Reply video (max 10 detik) dengan caption: ${prefix}setimg menuvideo`);
        }
        
        try {
            await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
            
            const mediaBuffer = await downloadContentFromMessage(m.quoted.msg?.videoMessage || m.quoted.videoMessage, 'video');
            let bufferArray = [];
            for await (const chunk of mediaBuffer) {
                bufferArray.push(chunk);
            }
            const buffer = Buffer.concat(bufferArray);
            
            const videoPath = './source/media/menuv2.mp4';
            
            fs.writeFileSync(videoPath, buffer);
            
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
            Reply('âœ… Berhasil mengganti video menu (menuv2.mp4)');
            
        } catch (error) {
            console.error('Setimg menuvideo error:', error);
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            Reply('âŒ Gagal mengganti video menu');
        }
        
    } else {
        if (!m.quoted || !(m.quoted.imageMessage || m.quoted.msg?.imageMessage)) {
            return Reply(`Reply gambar dengan caption: ${prefix}setimg ${type}`);
        }
        
        try {
            await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
            
            const mediaBuffer = await downloadContentFromMessage(m.quoted.msg?.imageMessage || m.quoted.imageMessage, 'image');
            let bufferArray = [];
            for await (const chunk of mediaBuffer) {
                bufferArray.push(chunk);
            }
            const buffer = Buffer.concat(bufferArray);
            
            const uploadResult = await uploadPixhost(buffer, `alip-${Date.now()}.jpg`);
            
            if (!uploadResult) {
                await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
                return Reply('Gagal upload gambar ke Pixhost');
            }
            
            const fs = require('fs');
            const path = './settings.js';
            
            if (!fs.existsSync(path)) {
                await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
                return Reply('File settings.js tidak ditemukan');
            }
            
            let settingContent = fs.readFileSync(path, 'utf8');
            
            let regexPattern;
            let propertyName;
            
            if (type === 'menu') {
                regexPattern = /menu:\s*['"][^'"]*['"]/g;
                propertyName = 'menu';
            } else if (type === 'reply') {
                regexPattern = /reply:\s*['"][^'"]*['"]/g;
                propertyName = 'reply';
            } else if (type === 'menuv2') {
                regexPattern = /menuv2:\s*['"][^'"]*['"]/g;
                propertyName = 'menuv2';
            }
            
            const newContent = settingContent.replace(regexPattern, `${propertyName}: "${uploadResult}"`);
            fs.writeFileSync(path, newContent);
            
            if (global.image) {
                global.image[propertyName] = uploadResult;
            }
            
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
            Reply(`Berhasil memperbarui image ${type} di settings.js:\n${uploadResult}`);
            
        } catch (error) {
            console.error('Setimg error:', error);
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            Reply('Terjadi error saat mengedit file settings.js');
        }
    }
}
break;

case 'culikmember': {
    if (!isCreator) return Reply('Hanya owner');
    
    const args = text.split(' ');
    if (args.length < 2) {
        return Reply(`${prefix}culikmember <source_grup> <target_grup> <jumlah>
${prefix}culikmember 120363406101776578@g.us 120363282320433902@g.us 3`);
    }

    const sourceGroupId = args[0];
    const targetGroupId = args[1];
    let jumlah = parseInt(args[2]) || 1;
    
    if (sourceGroupId === targetGroupId) {
        return Reply('Tidak bisa culik ke grup yang sama');
    }
    
    if (jumlah > 50) jumlah = 50;

    try {
        const sourceGroup = await alip.groupMetadata(sourceGroupId);
        const targetGroup = await alip.groupMetadata(targetGroupId);
        
        const targetMembers = targetGroup.participants || [];
        const sourceMembers = sourceGroup.participants || [];
        
        const targetJids = targetMembers.map(p => p.jid).filter(jid => jid);
        
        const available = [];
        for (const member of sourceMembers) {
            if (available.length >= jumlah) break;
            
            const jid = member.jid;
            if (!jid) continue;
            
            const alreadyInTarget = targetJids.includes(jid);
            if (!alreadyInTarget) {
                available.push(jid);
            }
        }

        if (available.length === 0) {
            return Reply('Semua member sudah ada di grup target');
        }

        let attempted = 0;
        const results = [];

        for (const jid of available) {
            attempted++;
            
            try {
                await alip.groupParticipantsUpdate(targetGroupId, [jid], 'add');
                results.push({ jid, status: 'success' });
                await sleep(3000);
            } catch (error) {
                const errorMsg = error.message.toLowerCase();
                
                if (errorMsg.includes('already in') || 
                    errorMsg.includes('participant') || 
                    errorMsg.includes('409')) {
                    results.push({ jid, status: 'already' });
                } else {
                    results.push({ jid, status: 'failed', error: error.message });
                }
            }
        }

        const successCount = results.filter(r => r.status === 'success').length;
        const alreadyCount = results.filter(r => r.status === 'already').length;
        const failedCount = results.filter(r => r.status === 'failed').length;
        
        const result = `Result:
From: ${sourceGroup.subject || sourceGroupId}
To: ${targetGroup.subject || targetGroupId}
Attempted: ${attempted}
âœ… Success added: ${successCount}
â„¹ï¸ Already in group: ${alreadyCount}
âŒ Failed: ${failedCount}`;

        await Reply(result);

    } catch (error) {
        console.error('Culik error:', error);
        return Reply('Error: ' + error.message);
    }
}
break;

case "animediff": {
  if (!isPremium && !isCreator) return Reply("fitur premium")

  if (!text) return Reply("prompt nya mana?")

  await alip.sendMessage(m.chat, {
    react: { text: "â³", key: m.key }
  })

  const url = `${global.termai}/api/text2img/animediff?prompt=${encodeURIComponent(text)}&key=${global.apitermai}`
  const res = await fetch(url)
  const buffer = await res.arrayBuffer()

  await alip.sendMessage(m.chat, {
    image: Buffer.from(buffer),
    caption: "animediff result"
  }, { quoted: m })

  await alip.sendMessage(m.chat, {
    react: { text: "âœ…", key: m.key }
  })
}
break

case 'setdaftar':
case 'setregister': {
    if (!isCreator) return Reply('âŒ Owner only!')
    
    if (!text) {
        const status = isRegisterSystemEnabled() ? 'âœ… AKTIF' : 'âŒ NONAKTIF';
        return Reply(`ðŸ“ *SISTEM DAFTAR*\nStatus: ${status}\n\n${prefix}setdaftar on - Aktifkan (harus daftar)\n${prefix}setdaftar off - Nonaktifkan (bebas akses)`);
    }
    
    const config = loadRegisterSystem();
    
    if (text === 'on') {
        config.enabled = true;
        saveRegisterSystem(config);
        return Reply('âœ… Sistem daftar AKTIF\nUser baru harus daftar');
    }
    
    if (text === 'off') {
        config.enabled = false;
        saveRegisterSystem(config);
        return Reply('âœ… Sistem daftar NONAKTIF\nSemua user otomatis terdaftar');
    }
    
    return Reply(`Pakai: ${prefix}setdaftar [on/off]`);
}
break;

case "aimention":
case "amai": {
    if (!isOwner) return Reply(mess.owner)
    if (!text) {
        const status = isAutoMentionAIEnabled() ? 'âœ… AKTIF' : 'âŒ NONAKTIF';
        return Reply(`ðŸ¤– *Auto-Mention AI*\nStatus: ${status}\nDefault: OFF\n\n${prefix}aimention on - Aktifkan\n${prefix}aimention off - Nonaktifkan`);
    }
    
    const config = loadAutoMentionAI();
    
    if (text === 'on' || text === '1' || text === 'aktifkan') {
        config.enabled = true;
        saveAutoMentionAI(config);
        return Reply('âœ… Auto-Mention AI diaktifkan!');
    }
    
    if (text === 'off' || text === '0' || text === 'nonaktifkan') {
        config.enabled = false;
        saveAutoMentionAI(config);
        return Reply('âŒ Auto-Mention AI dinonaktifkan!');
    }
    
    if (text === 'reset') {
        config.enabled = false;
        saveAutoMentionAI(config);
        return Reply('ðŸ”„ Auto-Mention AI direset ke default (OFF)');
    }
    
    return Reply(`Penggunaan:\n${prefix}amai on\n${prefix}amai off\n${prefix}amai reset`);
}
break;

case "banfitur": {
    if (!isCreator && !m.isAdmin) return Reply('âŒ Admin only!')
    if (!m.isGroup) return Reply('âŒ Group only!')
    
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {}
    const group = global.db.groups[m.chat]
    
    if (!group.bannedFeatures) group.bannedFeatures = []
    
    if (!text) {
        let listText = `ðŸš« *BANNED FEATURES*\n\n`
        
        if (group.bannedFeatures.length === 0) {
            listText += `âŒ No features banned\n\n`
        } else {
            listText += `ðŸ“‹ *Banned:*\n`
            group.bannedFeatures.forEach((feature, index) => {
                listText += `${index + 1}. ${feature}\n`
            })
            listText += `\n`
        }
        
        listText += `ðŸ“Œ *Usage:*\n`
        listText += `.banfitur menu\n`
        listText += `.banfitur menu,tt,ig\n`
        listText += `.banfitur list\n`
        listText += `.banfitur unban menu\n`
        listText += `.banfitur unban all`
        
        return Reply(listText)
    }
    
    if (text === 'list') {
        if (group.bannedFeatures.length === 0) return Reply('âŒ No features banned')
        
        let listText = `ðŸš« *BANNED (${group.bannedFeatures.length})*\n\n`
        group.bannedFeatures.forEach((feature, index) => {
            listText += `${index + 1}. ${feature}\n`
        })
        return Reply(listText)
    }
    
    if (text.startsWith('unban ')) {
        const feature = text.replace('unban ', '').trim()
        
        if (feature === 'all') {
            const count = group.bannedFeatures.length
            group.bannedFeatures = []
            return Reply(`âœ… Unbanned all (${count} features)`)
        }
        
        const features = feature.split(',').map(f => f.trim())
        let unbanned = 0
        
        features.forEach(f => {
            const index = group.bannedFeatures.indexOf(f)
            if (index !== -1) {
                group.bannedFeatures.splice(index, 1)
                unbanned++
            }
        })
        
        if (unbanned === 0) return Reply('âŒ Feature not in banned list')
        return Reply(`âœ… Unbanned ${unbanned} feature(s)`)
    }
    
    const features = text.split(',').map(f => f.trim())
    let banned = 0
    
    features.forEach(feature => {
        if (!group.bannedFeatures.includes(feature)) {
            group.bannedFeatures.push(feature)
            banned++
        }
    })
    
    if (banned === 0) return Reply('âŒ Features already banned')
    return Reply(`âœ… Banned ${banned} feature(s)`)
}
break

case "cadp":
case "createadp": {
  const owner = global.owner + '@s.whatsapp.net';
  if (!areJidsSameUser(m.sender, owner)) return Reply(`âŒ Hanya ${global.namaOwner} yang bisa akses command ini.`);
  
  if (!args[0]) return Reply(`Masukkan Username!\nContoh: ${prefix + command} alip`);

  try {
    let username = args[0].toLowerCase();
    let email = (args[1] && args[1].includes('@')) ? args[1] : `${username}@gmail.com`;
    let firstName = capital(username);
    let lastName = "Admin";
    let password = username + crypto.randomBytes(2).toString('hex');

    const domain = global.domain;
    const apikey = global.apikey;

    if (domain === "https://" || apikey === "-") {
      return Reply('âŒ Config panel belum diatur di settings.js');
    }

    let f = await fetch(domain + "/api/application/users", {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "Authorization": "Bearer " + apikey
      },
      body: JSON.stringify({
        email: email,
        username: username,
        first_name: firstName,
        last_name: lastName,
        language: "en",
        password: password.toString(),
        root_admin: true
      })
    });

    let data = await f.json();
    if (data.errors) return Reply("âŒ Gagal membuat admin:\n" + JSON.stringify(data.errors[0], null, 2));

    let user = data.attributes;
    let teks = `
ðŸ‘‘ *Role:* Super Administrator
ðŸ”‘ *Username:* ${user.username}
ðŸ“§ *Email:* ${user.email}
ðŸ” *Password:* ${password.toString()}
ðŸŒ *Panel URL:* ${domain}

ðŸš€ *Support:* Hubungi developer jika ada kendala`;

    let msgii = await generateWAMessageFromContent(m.sender, {
      viewOnceMessage: { 
        message: { 
          "messageContextInfo": { 
            "deviceListMetadata": {}, 
            "deviceListMetadataVersion": 2
          }, 
          interactiveMessage: {
            body: { text: teks },
            footer: { text: `ðŸ”§ Powered by ${global.namaOwner}` },
            nativeFlowMessage: {
              buttons: [
                {
                  "name": "cta_url",
                  "buttonParamsJson": `{"display_text":"ðŸ”— Login ke Panel","url":"${domain}","merchant_url":"${domain}"}`
                },
                {
                  "name": "cta_copy",
                  "buttonParamsJson": `{"display_text":"ðŸ“‹ Copy Username","id":"copy_user","copy_code":"${user.username}"}`
                },
                {
                  "name": "cta_copy",
                  "buttonParamsJson": `{"display_text":"ðŸ”’ Copy Password","id":"copy_pass","copy_code":"${password.toString()}"}`
                }
              ]
            }
          }
        }
      }
    }, { userJid: m.sender, quoted: null });

    await alip.relayMessage(msgii.key.remoteJid, msgii.message, { messageId: msgii.key.id });

    if (m.isGroup) {
      Reply(`âœ… *Akun Admin Panel berhasil dibuat!*\nðŸ“¨ Detail login telah dikirim ke chat pribadi @${m.sender.split('@')[0]}`, [m.sender]);
    } else {
      Reply(`âœ… *Akun Admin Panel sukses dibuat!*\nðŸ“‹ Data login sudah dikirim ke chat ini.`);
    }

  } catch (e) {
    console.error(e);
    Reply('âŒ *Gagal membuat admin panel*\n' + (e?.message || e));
  }
}
break;

case "saveweb": {
if (!text) return Reply("Format: .saveweb <url>")

let url
try {
url = new URL(text.trim())
} catch {
return Reply("URL tidak valid.")
}

if (!/^https?:$/.test(url.protocol)) {
return Reply("URL harus http atau https.")
}

try {
const axios = require("axios")
const fs = require("fs")
const path = require("path")

const res = await axios.get(url.href, {
headers: {
"User-Agent": "Mozilla/5.0",
"Accept": "text/html"
},
timeout: 30000
})

if (!res.data || typeof res.data !== "string") {
return Reply("Gagal mengambil HTML.")
}

const hostname = url.hostname.replace(/\./g, "_")
const filename = `saveweb_${hostname}.html`
const filepath = path.join(__dirname, filename)

fs.writeFileSync(filepath, res.data)

await alip.sendMessage(m.chat, {
document: fs.readFileSync(filepath),
fileName: filename,
mimetype: "text/html",
caption: `HTML berhasil disimpan dari:\n${url.href}`
}, { quoted: m })

fs.unlinkSync(filepath)

} catch (e) {
if (e.code === "ECONNABORTED") return Reply("Request timeout.")
if (e.response?.status) return Reply("Gagal mengambil halaman. Status: " + e.response.status)
Reply("Terjadi kesalahan saat mengambil HTML.")
}
}
break

case 'setmenu': {
    if (!isCreator) return Reply('âŒ Hanya owner bot yang bisa mengubah menu style!');
    
    if (!text) return Reply('Format: .setmenu <v1/v2>\nContoh: .setmenu v2\n\nv1 = Dengan tombol interaktif\nv2 = Tanpa tombol (teks saja)');
    
    const version = text.toLowerCase().trim();
    if (version !== 'v1' && version !== 'v2') {
        return Reply('âŒ Versi tidak valid!\nGunakan: .setmenu v1 (dengan tombol) atau .setmenu v2 (tanpa tombol)');
    }
    
    setMenuStyle(version);
    
    if (version === 'v1') {
        return Reply(`âœ… Menu style GLOBAL berhasil diubah ke *V1 (Interactive)*\nSekarang SEMUA user akan melihat menu dengan tombol interaktif.`);
    } else {
        return Reply(`âœ… Menu style GLOBAL berhasil diubah ke *V2 (Text Only)*\nSekarang SEMUA user akan melihat menu sebagai teks biasa.`);
    }
}
break;

case "alipai":
case "menu": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    await alip.sendMessage(m.chat, { 
        react: { text: 'ðŸ•–', key: m.key } 
    });
    await menureply(``, true); 
    await alip.sendMessage(m.chat, {
        audio: fs.readFileSync('source/media/alip.mp3'),
        mimetype: 'audio/mp4',
        ptt: false
    }, { quoted: m }); 
}
break;
case "allmenu": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
let me = m.sender
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.allmenu}`, false)
}
break
case "menu-ai": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
let me = m.sender
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuai}`, false)
}
break
case "menu-stk": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
let me = m.sender
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menustk}`, false)
}
break
case "menu-enc": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
let me = m.sender
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuenc}`, false)
}
break
case "menu-owner": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
let me = m.sender
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuowner}`, false)
}
break
case "menu-maker": {
  if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
  let me = m.sender
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key }})
  menureply(`${global.menumaker}`, false)
}
break
case "menu-potoanime": {
  if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
  let me = m.sender
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key }})
  menureply(`${global.potoanime}`, false)
}
break
case "menu-shop": {
  if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
  let me = m.sender
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key }})
  menureply(`${global.menushop}`, false)
}
break
case "menu-group": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menugroup}`, false)
}
break
case "menu-store": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menustore}`, false)
}
break
case "menu-anime": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuanime}`, false)
}
break
case "menu-nsfw": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menunsfw}`, false)
}
break
case "menu-panel": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menupanel}`, false)
}
break
case "menu-cecan": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menucecan}`, false)
}
break
case "menu-islami": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuislam}`, false)
}
break
case "menu-ehpoto": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuehpoto}`, false)
}
break
case "menu-rpg": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menurpg}`, false)
}
break
case "menu-game": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menugame}`, false)
}
break
case "menu-search": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menusearch}`, false)
}
break
case "menu-download": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menudownlod}`, false)
}
break
case "menu-fun": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menufun}`, false)
}
break
case "menu-tools": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menutolls}`, false)
}
break
case "menu-primbon": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);  
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menuprimbon}`, false)
}
break
case "menu-stickers": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);
await alip.sendMessage(m.chat, {react: {text: 'ðŸ•–', key: m.key}})
menureply(`${global.menusticker}`, false)
}
break

case "qc": {
 if (!isRegistered(m.sender)) return Reply(mess.verifikasi);
 if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} Hai kak`);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (text.length > 100)
    return Reply(`âš ï¸ Maksimal 100 karakter.`);

  try {
    await alip.sendMessage(m.chat, {
      image: { url: global.image.menu },
      caption: `ðŸŽ¨ *Pilih Warna qc*\nSilakan pilih warna efek qc yang ingin kamu gunakan.`,
      buttons: [
        {
          buttonId: 'bratpilih',
          buttonText: { displayText: 'ðŸ–Œï¸ Pilih Warna' },
          type: 4,
          nativeFlowInfo: {
            name: 'single_select',
            paramsJson: JSON.stringify({
              title: 'Pilih Warna',
              sections: [
                {
                  title: 'Daftar Warna',
                  rows: [
                    { title: 'pink', id: `.alipqc pink ${text}` },
                    { title: 'biru', id: `.alipqc biru ${text}` },
                    { title: 'merah', id: `.alipqc merah ${text}` },
                    { title: 'hijau', id: `.alipqc hijau ${text}` },
                    { title: 'kuning', id: `.alipqc kuning ${text}` },
                    { title: 'ungu', id: `.alipqc ungu ${text}` },
                    { title: 'biru tua', id: `.alipqc birutua ${text}` },
                    { title: 'biru muda', id: `.alipqc birumuda ${text}` },
                    { title: 'abu', id: `.alipqc abu ${text}` },
                    { title: 'oranye', id: `.alipqc oranye ${text}` },
                    { title: 'hitam', id: `.alipqc hitam ${text}` },
                    { title: 'putih', id: `.alipqc putih ${text}` },
                    { title: 'teal', id: `.alipqc teal ${text}` },
                    { title: 'merah muda', id: `.alipqc merahmuda ${text}` },
                    { title: 'cokelat', id: `.alipqc cokelat ${text}` },
                    { title: 'salmon', id: `.alipqc salmon ${text}` },
                    { title: 'magenta', id: `.alipqc magenta ${text}` },
                    { title: 'tan', id: `.alipqc tan ${text}` },
                    { title: 'wheat', id: `.alipqc wheat ${text}` },
                    { title: 'deep pink', id: `.alipqc deeppink ${text}` },
                    { title: 'api', id: `.alipqc api ${text}` },
                    { title: 'biru langit', id: `.alipqc birulangit ${text}` },
                    { title: 'jingga', id: `.alipqc jingga ${text}` },
                    { title: 'biru langit cerah', id: `.alipqc birulangitcerah ${text}` },
                    { title: 'hot pink', id: `.alipqc hotpink ${text}` },
                    { title: 'biru muda langit', id: `.alipqc birumudalangit ${text}` },
                    { title: 'hijau laut', id: `.alipqc hijaulaut ${text}` },
                    { title: 'merah tua', id: `.alipqc merahtua ${text}` },
                    { title: 'oranye merah', id: `.alipqc oranyemerah ${text}` },
                    { title: 'cyan', id: `.alipqc cyan ${text}` },
                    { title: 'ungu tua', id: `.alipqc ungutua ${text}` },
                    { title: 'hijau lumut', id: `.alipqc hijaulumut ${text}` },
                    { title: 'hijau gelap', id: `.alipqc hijaugelap ${text}` },
                    { title: 'biru laut', id: `.alipqc birulaut ${text}` }
                  ]
                }
              ]
            })
          }
        }
      ],
      headerType: 4,
      viewOnce: true,
      contextInfo: {
        mentionedJid: [m.sender]
      }
    }, { quoted: m });

  } catch (error) {
    console.error('[BRAT ERROR]', error);
    Reply('âŒ Gagal memproses perintah brat.');
  }
}
break;

		case 'alipqc': {
    if (!text) return Reply(
        `*Masukan Input Query!*\n\nContoh:\n${prefix + command} pink hallo\n\n*List Warna*:\n` +
        `pink\nbiru\nmerah\nhijau\nkuning\nungu\nbirutua\nbirumuda\nabu\norange\nhitam\nputih\nteal\nmerahmuda\ncokelat\nsalmon\nmagenta\n` +
        `tan\nwheat\ndeeppink\napi\nbirulangit\njingga\nbirulangitcerah\nhotpink\nbirumudalangit\nhijaulaut\nmerahtua\noranyemerah\ncyan\n` +
        `ungutua\nhijaulumut\nhijaugelap\nbirulaut\noranyetua\nungukehitaman\nfuchsia\nmagentagelap\nabu-abutua\npeachpuff\nhijautua\n` +
        `merahgelap\ngoldenrod\nabu-abutua\nungugelap\nemas\nperak`
    );

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key } });

    let [color, ...message] = text.split(' ');
    message = message.join(' ');
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    let backgroundColor;
    switch (color) {
        case 'pink': backgroundColor = '#f68ac9'; break;
        case 'biru': backgroundColor = '#6cace4'; break;
        case 'merah': backgroundColor = '#f44336'; break;
        case 'hijau': backgroundColor = '#4caf50'; break;
        case 'kuning': backgroundColor = '#ffeb3b'; break;
        case 'ungu': backgroundColor = '#9c27b0'; break;
        case 'birutua': backgroundColor = '#0d47a1'; break;
        case 'birumuda': backgroundColor = '#03a9f4'; break;
        case 'abu': backgroundColor = '#9e9e9e'; break;
        case 'orange': backgroundColor = '#ff9800'; break;
        case 'hitam': backgroundColor = '#000000'; break;
        case 'putih': backgroundColor = '#ffffff'; break;
        case 'teal': backgroundColor = '#008080'; break;
        case 'merahmuda': backgroundColor = '#FFC0CB'; break;
        case 'cokelat': backgroundColor = '#A52A2A'; break;
        case 'salmon': backgroundColor = '#FFA07A'; break;
        case 'magenta': backgroundColor = '#FF00FF'; break;
        case 'tan': backgroundColor = '#D2B48C'; break;
        case 'wheat': backgroundColor = '#F5DEB3'; break;
        case 'deeppink': backgroundColor = '#FF1493'; break;
        case 'api': backgroundColor = '#B22222'; break;
        case 'birulangit': backgroundColor = '#00BFFF'; break;
        case 'jingga': backgroundColor = '#FF7F50'; break;
        case 'birulangitcerah': backgroundColor = '#1E90FF'; break;
        case 'hotpink': backgroundColor = '#FF69B4'; break;
        case 'birumudalangit': backgroundColor = '#87CEEB'; break;
        case 'hijaulaut': backgroundColor = '#20B2AA'; break;
        case 'merahtua': backgroundColor = '#8B0000'; break;
        case 'oranyemerah': backgroundColor = '#FF4500'; break;
        case 'cyan': backgroundColor = '#48D1CC'; break;
        case 'ungutua': backgroundColor = '#BA55D3'; break;
        case 'hijaulumut': backgroundColor = '#00FF7F'; break;
        case 'hijaugelap': backgroundColor = '#008000'; break;
        case 'birulaut': backgroundColor = '#191970'; break;
        case 'oranyetua': backgroundColor = '#FF8C00'; break;
        case 'ungukehitaman': backgroundColor = '#9400D3'; break;
        case 'fuchsia': backgroundColor = '#FF00FF'; break;
        case 'magentagelap': backgroundColor = '#8B008B'; break;
        case 'abu-abutua': backgroundColor = '#696969'; break;
        case 'peachpuff': backgroundColor = '#FFDAB9'; break;
        case 'hijautua': backgroundColor = '#BDB76B'; break;
        case 'merahgelap': backgroundColor = '#DC143C'; break;
        case 'goldenrod': backgroundColor = '#DAA520'; break;
        case 'emas': backgroundColor = '#FFD700'; break;
        case 'perak': backgroundColor = '#C0C0C0'; break;
        default:
            backgroundColor = '#ffffff';
            message = text;
    }

    try {
        avatar = await alip.profilePictureUrl(m.sender, "image");
    } catch {
        avatar = 'https://telegra.ph/file/c3f3d2c2548cbefef1604.jpg';
    }

    const json = {
        type: "quote",
        format: "png",
        backgroundColor,
        width: 700,
        height: 580,
        scale: 2,
        messages: [{
            entities: [],
            avatar: true,
            from: {
                id: 1,
                name: m.pushName,
                photo: { url: avatar }
            },
            text: message,
            "m.replyMessage": {}
        }],
    };

    try {
        const res = await axios.post("https://bot.lyo.su/quote/generate", json, {
            headers: { "Content-Type": "application/json" },
        });
        const qc = Buffer.from(res.data.result.image, "base64");
        await alip.sendAsSticker(m.chat, qc, m, {
            packname: `Sticker Maker\nNomor Bot :`,
            author: `${global.botname}\n${global.namaOwner}`
        });
    } catch (error) {
        console.error("Error generating QC v1:", error);
        try {
            const data = await axios.post("https://bot.lyo.su/quote/generate", json, {
                headers: { "Content-Type": "application/json" },
            });
            const qc = Buffer.from(data.data.result.image, "base64");
            await alip.sendAsSticker(m.chat, qc, m, {
                packname: `Sticker Maker\nNomor Bot :`,
                author: `${global.botname}\n${global.namaOwner}`
            });
        } catch (e) {
            m.reply('Server Create Sedang Offline!');
        }
    }
}
break;

case 'closetime': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin grup!');
    if (!m.isBotAdmin) return Reply('âŒ Bot harus menjadi admin!');
    
    if (!text) return Reply('Format: .closetime <waktu> <detik/menit/jam/hari>\nContoh: .closetime 10 menit');
    
    const args = text.split(' ');
    if (args.length < 2) return Reply('Format: .closetime <waktu> <detik/menit/jam/hari>\nContoh: .closetime 10 menit');
    
    const waktu = parseInt(args[0]);
    const unit = args[1].toLowerCase();
    
    if (isNaN(waktu) || waktu <= 0) return Reply('âŒ Waktu harus berupa angka positif!');
    
    let timer;
    if (unit === 'detik') {
        timer = waktu * 1000;
    } else if (unit === 'menit') {
        timer = waktu * 60000;
    } else if (unit === 'jam') {
        timer = waktu * 3600000;
    } else if (unit === 'hari') {
        timer = waktu * 86400000;
    } else {
        return Reply('âŒ Pilih unit waktu: detik/menit/jam/hari\nContoh: .closetime 10 menit');
    }
    
    Reply(`â° *Close Time ${waktu} ${unit}* dimulai dari sekarang\nGrup akan ditutup otomatis setelah waktu habis.`);
    
    setTimeout(async () => {
        try {
            await alip.groupSettingUpdate(m.chat, 'announcement');
            await Reply(`ðŸ”’ *TEPAT WAKTU*\nGrup telah ditutup oleh sistem.\nSekarang hanya admin yang dapat mengirim pesan.`);
        } catch (error) {
            await Reply('âŒ Gagal menutup grup. Pastikan bot masih admin.');
        }
    }, timer);
}
break;

case 'opentime': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin grup!');
    if (!m.isBotAdmin) return Reply('âŒ Bot harus menjadi admin!');
    
    if (!text) return Reply('Format: .opentime <waktu> <detik/menit/jam/hari>\nContoh: .opentime 10 menit');
    
    const args = text.split(' ');
    if (args.length < 2) return Reply('Format: .opentime <waktu> <detik/menit/jam/hari>\nContoh: .opentime 10 menit');
    
    const waktu = parseInt(args[0]);
    const unit = args[1].toLowerCase();
    
    if (isNaN(waktu) || waktu <= 0) return Reply('âŒ Waktu harus berupa angka positif!');
    
    let timer;
    if (unit === 'detik') {
        timer = waktu * 1000;
    } else if (unit === 'menit') {
        timer = waktu * 60000;
    } else if (unit === 'jam') {
        timer = waktu * 3600000;
    } else if (unit === 'hari') {
        timer = waktu * 86400000;
    } else {
        return Reply('âŒ Pilih unit waktu: detik/menit/jam/hari\nContoh: .opentime 10 menit');
    }
    
    Reply(`â° *Open Time ${waktu} ${unit}* dimulai dari sekarang\nGrup akan dibuka otomatis setelah waktu habis.`);
    
    setTimeout(async () => {
        try {
            await alip.groupSettingUpdate(m.chat, 'not_announcement');
            await Reply(`ðŸ”“ *TEPAT WAKTU*\nGrup telah dibuka oleh sistem.\nSekarang semua member dapat mengirim pesan.`);
        } catch (error) {
            await Reply('âŒ Gagal membuka grup. Pastikan bot masih admin.');
        }
    }, timer);
}
break;

case 'buyprem': {
    if (!global.slug || !global.pkasirapikey) return Reply('âŒ PAKASIR BELUM DIKONFIGURASI');
    
    const userJid = m.sender;
    const premiumPath = './library/database/premium.json';
    const premData = fs.existsSync(premiumPath) ? JSON.parse(fs.readFileSync(premiumPath)) : [];
    const userPrem = premData.find(u => u.jid === userJid);
    
    if (userPrem && userPrem.expired > Date.now()) {
        const hariTersisa = Math.ceil((userPrem.expired - Date.now()) / (1000 * 60 * 60 * 24));
        return Reply(`âŒ Kamu sudah premium!\nðŸ“… Sisa waktu: ${hariTersisa} hari\nâ³ Berakhir: ${new Date(userPrem.expired).toLocaleDateString('id-ID')}`);
    }
    
    const harga = parseInt(global.harga?.prem || 5000);
    const productName = 'Premium Bot 30 Hari';
    const days = 30;
    const sessionId = Date.now().toString();
    
    try {
        const payload = { project: global.slug, order_id: sessionId, amount: harga, api_key: global.pkasirapikey };
        const response = await axios.post('https://app.pakasir.com/api/transactioncreate/qris', payload, { headers: { 'Content-Type': 'application/json' } });
        
        if (response.data && response.data.payment) {
            const qrisPath = `${depositPath}qris_${sessionId}.png`;
            await QRCode.toFile(qrisPath, response.data.payment.payment_number, { margin: 2, scale: 10 });

const sessionData = {
    purpose: 'premium',
    userJid: userJid,
    userName: m.pushName || userJid.split('@')[0],
    price: harga,
    productName: productName,
    days: days,
    sessionId: sessionId,
    timestamp: Date.now(),
    status: 'pending',
    pakasirData: response.data.payment,
    qrPath: qrisPath,
    chatId: m.chat
};
            
            const sessionPath = path.join(depositPath, `pakasir_${sessionId}.json`);
            fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));

const qrCaption = `*${productName}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â•­â”€ã€Œ ðŸ“‹ DETAIL TRANSAKSI ã€
â”‚ ðŸ†” ID: ${sessionId}
â”‚ ðŸ‘¤ Pembeli: ${sessionData.userName}
â”‚ ðŸ’Ž Produk: ${productName}
â”‚ â° Durasi: ${days} Hari
â”‚
â”‚ ðŸ’° Harga: Rp${harga.toLocaleString()}
â”‚ ðŸ’¸ Biaya Admin: Rp${response.data.payment.fee?.toLocaleString() || '0'}
â”‚ ðŸ’³ Total Bayar: Rp${response.data.payment.total_payment?.toLocaleString() || harga.toLocaleString()}
â”‚ â° Batas Waktu: 5 Menit
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ðŸ“± *Scan qris di atas untuk pembayaran*`;
            
            const qrMessage = await alip.sendMessage(m.chat, {
                image: fs.readFileSync(qrisPath),
                caption: qrCaption,
                footer: "Pakasir Payment Gateway",
                buttons: [{ buttonId: `.batalpakasir ${sessionId}`, buttonText: { displayText: "âŒ Batalkan" }, type: 1 }],
                headerType: 1
            }, { quoted: m });
            
            sessionData.qrMessageKey = qrMessage.key;
            fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
            
            setTimeout(async () => {
                try {
                    if (fs.existsSync(sessionPath)) {
                        const currentData = JSON.parse(fs.readFileSync(sessionPath));
                        if (currentData.status === 'pending') {
                            const cancelPayload = { project: global.slug, order_id: sessionId, amount: harga, api_key: global.pkasirapikey };
                            try { await axios.post('https://app.pakasir.com/api/transactioncancel', cancelPayload, { headers: { 'Content-Type': 'application/json' } }); } catch (e) {}
                            if (currentData.qrMessageKey) try { await alip.sendMessage(m.chat, { delete: currentData.qrMessageKey }); } catch (e) {}
                            if (fs.existsSync(currentData.qrPath)) fs.unlinkSync(currentData.qrPath);
                            fs.unlinkSync(sessionPath);
                        }
                    }
                } catch (e) {}
            }, 5 * 60 * 1000);
            
        } else throw new Error(response.data.message || 'Gagal membuat transaksi');
        
    } catch (error) {
        Reply(`âŒ Gagal membuat pembayaran: ${error.message}`);
    }
    break;
}
case 'buysewagc': {
    if (!global.slug || !global.pkasirapikey) return Reply('âŒ PAKASIR BELUM DIKONFIGURASI');
    if (!text) return Reply('Format: .buysewagc <link_grup>');
    
    const harga = parseInt(global.harga?.sewa || 10000);
    const productName = 'Sewa Grup 30 Hari';
    const days = 30;
    const sessionId = Date.now().toString();
    
    let match = text.match(/chat\.whatsapp\.com\/([0-9A-Za-z]+)/);
    if (!match) return Reply("âŒ Link tidak valid!");
    
    const inviteCode = match[1];
    
    try {
        const groupInfo = await alip.groupGetInviteInfo(inviteCode);
        const groupId = groupInfo.id;
        
        const sewaPath = './library/database/sewagrup.json';
        const sewagrup = fs.existsSync(sewaPath) ? JSON.parse(fs.readFileSync(sewaPath)) : [];
        const now = Date.now();
        
        const existingSewa = sewagrup.find(v => v.jid === groupId && now < v.expired);
        
        if (existingSewa) {
            const waktuTersisa = existingSewa.expired - now;
            const hariTersisa = Math.ceil(waktuTersisa / (1000 * 60 * 60 * 24));
            return Reply(`âŒ Grup ini sudah terdaftar sewa!\nðŸ¢ Nama: ${groupInfo.subject}\nðŸ“… Sisa waktu: ${hariTersisa} hari\nâ³ Berakhir: ${new Date(existingSewa.expired).toLocaleDateString('id-ID')}`);
        }
    } catch (e) {}
    
    try {
        const payload = { project: global.slug, order_id: sessionId, amount: harga, api_key: global.pkasirapikey };
        const response = await axios.post('https://app.pakasir.com/api/transactioncreate/qris', payload, { headers: { 'Content-Type': 'application/json' } });
        
        if (response.data && response.data.payment) {
            const qrisPath = `${depositPath}qris_${sessionId}.png`;
            await QRCode.toFile(qrisPath, response.data.payment.payment_number, { margin: 2, scale: 10 });

const sessionData = {
    purpose: 'sewagc',
    userJid: m.sender,
    userName: m.pushName || m.sender.split('@')[0],
    price: harga,
    productName: productName,
    days: days,
    inviteCode: inviteCode,
    groupLink: text,
    sessionId: sessionId,
    timestamp: Date.now(),
    status: 'pending',
    pakasirData: response.data.payment,
    qrPath: qrisPath,
    chatId: m.chat
};
            
            const sessionPath = path.join(depositPath, `pakasir_${sessionId}.json`);
            fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));

const qrCaption = `*${productName}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â•­â”€ã€Œ ðŸ“‹ DETAIL TRANSAKSI ã€
â”‚ ðŸ†” ID: ${sessionId}
â”‚ ðŸ‘¤ Pembeli: ${sessionData.userName}
â”‚ ðŸ’Ž Produk: ${productName}
â”‚ â° Durasi: ${days} Hari
â”‚
â”‚ ðŸ’° Harga: Rp${harga.toLocaleString()}
â”‚ ðŸ’¸ Biaya Admin: Rp${response.data.payment.fee?.toLocaleString() || '0'}
â”‚ ðŸ’³ Total Bayar: Rp${response.data.payment.total_payment?.toLocaleString() || harga.toLocaleString()}
â”‚ â° Batas Waktu: 5 Menit
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ðŸ“± *Scan qris di atas untuk pembayaran*`;
            
            const qrMessage = await alip.sendMessage(m.chat, {
                image: fs.readFileSync(qrisPath),
                caption: qrCaption,
                footer: "Pakasir Payment Gateway",
                buttons: [{ buttonId: `.batalpakasir ${sessionId}`, buttonText: { displayText: "âŒ Batalkan" }, type: 1 }],
                headerType: 1
            }, { quoted: m });
            
            sessionData.qrMessageKey = qrMessage.key;
            fs.writeFileSync(sessionPath, JSON.stringify(sessionData, null, 2));
            
            setTimeout(async () => {
                try {
                    if (fs.existsSync(sessionPath)) {
                        const currentData = JSON.parse(fs.readFileSync(sessionPath));
                        if (currentData.status === 'pending') {
                            const cancelPayload = { project: global.slug, order_id: sessionId, amount: harga, api_key: global.pkasirapikey };
                            try { await axios.post('https://app.pakasir.com/api/transactioncancel', cancelPayload, { headers: { 'Content-Type': 'application/json' } }); } catch (e) {}
                            if (currentData.qrMessageKey) try { await alip.sendMessage(m.chat, { delete: currentData.qrMessageKey }); } catch (e) {}
                            if (fs.existsSync(currentData.qrPath)) fs.unlinkSync(currentData.qrPath);
                            fs.unlinkSync(sessionPath);
                        }
                    }
                } catch (e) {}
            }, 5 * 60 * 1000);
            
        } else throw new Error(response.data.message || 'Gagal membuat transaksi');
        
    } catch (error) {
        Reply(`âŒ Gagal membuat pembayaran: ${error.message}`);
    }
    break;
}
case 'batalpakasir': {
    if (!text) return Reply('Format: .batalpakasir <id_transaksi>');
    
    const sessionPath = path.join(depositPath, `pakasir_${text}.json`);
    const qrPath = path.join(depositPath, `qris_pakasir_${text}.png`);
    
    if (fs.existsSync(sessionPath)) {
        const sessionData = JSON.parse(fs.readFileSync(sessionPath));
        
        if (sessionData.userJid === m.sender || isCreator) {
            try {
                const cancelPayload = { project: global.slug, order_id: text, amount: sessionData.price, api_key: global.pkasirapikey };
                await axios.post('https://app.pakasir.com/api/transactioncancel', cancelPayload, { headers: { 'Content-Type': 'application/json' } });
            } catch (e) {}
            
            if (sessionData.qrMessageKey) try { await alip.sendMessage(m.chat, { delete: sessionData.qrMessageKey }); } catch (e) {}
            
            fs.unlinkSync(sessionPath);
            if (fs.existsSync(qrPath)) fs.unlinkSync(qrPath);
            if (fs.existsSync(sessionData.qrPath)) fs.unlinkSync(sessionData.qrPath);
            Reply(`âœ… Transaksi Pakasir ${text} berhasil dibatalkan.`);
        } else Reply('âŒ Anda tidak memiliki izin untuk membatalkan transaksi ini.');
    } else Reply('âŒ Transaksi tidak ditemukan.');
    break;
}
case "setpay": {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin grup!');
    
if (!text) return Reply(
`ðŸ”¹ *Payment biasa*
Perintah:
.setpay <keyword>|<nomor>
Contoh:
.setpay dana|08123456789
ðŸ“· Reply foto â†’ jadi thumbnail

ðŸ”¹ *Payment tombol URL*
Perintah:
.setpay tbuttonurl <keyword>|<url>
Contoh:
.setpay tbuttonurl dana|https://link.dana.id
ðŸ“· Tidak perlu reply foto`
);
    
    const paymentDBPath = './library/database/autopay.json';
    
    function loadPayments() {
        try {
            if (!fs.existsSync(paymentDBPath)) return {};
            return JSON.parse(fs.readFileSync(paymentDBPath));
        } catch (e) {
            return {};
        }
    }
    
    function savePayments(data) {
        fs.writeFileSync(paymentDBPath, JSON.stringify(data, null, 2));
    }
    
    if (text.startsWith('tbuttonurl ')) {
        const rest = text.substring(11).trim();
        if (!rest.includes('|')) return Reply('âŒ Format: .setpay tbuttonurl <keyword>|<url>\nContoh: .setpay tbuttonurl dana|https://link.dana.id');
        
        const [keyword, url] = rest.split('|').map(s => s.trim());
        if (!keyword || !url) return Reply('âŒ Format: .setpay tbuttonurl <keyword>|<url>');
        
        const db = loadPayments();
        const existingPayment = db[m.chat]?.payments?.[keyword];
        
        if (!existingPayment) {
            return Reply(`âŒ Payment "${keyword}" belum ada!\n\nBuat dulu dengan:\n.setpay ${keyword}|<nomor>\nâ†ªï¸ Wajib reply foto sebagai thumbnail`);
        }
        
        const finalUrl = url.startsWith('http') ? url : 'https://' + url;
        db[m.chat].payments[keyword].type = 'buttonurl';
        db[m.chat].payments[keyword].buttonUrl = finalUrl; 
        db[m.chat].payments[keyword].updatedAt = Date.now();
        
        savePayments(db);
        
        return Reply(`âœ… Berhasil upgrade "${keyword}" ke button URL!\n\nðŸ’³ Nomor: ${existingPayment.value}\nðŸ”— URL: ${finalUrl}\nðŸ“± Button: Buka Link`);
    } else {
        if (!text.includes('|')) return Reply('âŒ Format: .setpay <keyword>|<nomor>\nContoh: .setpay dana|08123456789\nâ†ªï¸ Wajib reply foto sebagai thumbnail');
        
        const [keyword, nomor] = text.split('|').map(s => s.trim());
        if (!keyword || !nomor) return Reply('âŒ Format: .setpay <keyword>|<nomor>');
        
        if (!m.quoted || !(m.quoted.type === 'imageMessage' || m.quoted.msg?.imageMessage)) {
            return Reply('âŒ Wajib reply foto sebagai thumbnail!');
        }
        
        try {
            const mediaDir = './library/media/payments/';
            if (!fs.existsSync(mediaDir)) fs.mkdirSync(mediaDir, { recursive: true });
            
            const quotedMsg = m.quoted.msg || m.quoted;
            const mediaBuffer = await downloadContentFromMessage(quotedMsg, 'image');
            
            let buffer = Buffer.from([]);
            for await (const chunk of mediaBuffer) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            const timestamp = Date.now();
            const random = Math.random().toString(36).substring(7);
            const imagePath = `${mediaDir}${m.chat.replace('@g.us', '')}_${keyword}_${timestamp}_${random}.jpg`;
            fs.writeFileSync(imagePath, buffer);
            
            const db = loadPayments();
            if (!db[m.chat]) db[m.chat] = { payments: {} };
            
            db[m.chat].payments[keyword] = {
                type: 'text',
                value: nomor, 
                buttonUrl: null, 
                image: imagePath,
                setBy: m.sender,
                setAt: Date.now()
            };
            
            savePayments(db);
            
            return Reply(`âœ… Payment "${keyword}" berhasil dibuat!\n\nðŸ“± Nomor: ${nomor}\nðŸ“‹ Button: Salin Text\n\nðŸ’¡ Upgrade ke button URL:\n.setpay tbuttonurl ${keyword}|<url>`);
            
        } catch (e) {
            return Reply('âŒ Gagal menyimpan foto QR!');
        }
    }
}
break;

case "pay": case "payment": {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    
    const paymentDBPath = './library/database/autopay.json';
    
    function loadPayments() {
        try {
            if (!fs.existsSync(paymentDBPath)) return {};
            return JSON.parse(fs.readFileSync(paymentDBPath));
        } catch (e) {
            return {};
        }
    }
    
    const db = loadPayments();
    const groupPayments = db[m.chat]?.payments;
    
    const cards = [];
    
    if (!groupPayments || Object.keys(groupPayments).length === 0) {
        if (global.dana && global.gopay && global.image.qris) {
            const qrImage = await prepareWAMessageMedia({ 
                image: { url: global.image.qris } 
            }, { upload: alip.waUploadToServer });
            
            const danaCard = {
                header: {
                    hasMediaAttachment: true,
                    ...qrImage
                },
                body: { text: `ðŸ’³ *DANA*\nðŸ“± ${global.dana}` },
                nativeFlowMessage: {
                    buttons: [{
                        "name": "cta_url",
                        "buttonParamsJson": JSON.stringify({
                            "display_text": "Download qris",
                            "url": global.image.qris,
                            "merchant_url": global.image.qris
                        })
                    }]
                }
            };
            
            cards.push(danaCard);
            
            const gopayCard = {
                header: {
                    hasMediaAttachment: true,
                    ...qrImage
                },
                body: { text: `ðŸ’³ *GOPAY*\nðŸ“± ${global.gopay}` },
                nativeFlowMessage: {
                    buttons: [{
                        "name": "cta_url",
                        "buttonParamsJson": JSON.stringify({
                            "display_text": "Download qris",
                            "url": global.image.qris,
                            "merchant_url": global.image.qris
                        })
                    }]
                }
            };
            
            cards.push(gopayCard);
        }
    } else {
        for (const [keyword, data] of Object.entries(groupPayments)) {
            let img = null;
            
            if (data.image && fs.existsSync(data.image)) {
                img = await prepareWAMessageMedia({ 
                    image: fs.readFileSync(data.image) 
                }, { upload: alip.waUploadToServer });
            }
            
            if (data.type === 'buttonurl') {
                const card = {
                    header: img ? {
                        hasMediaAttachment: true,
                        ...img
                    } : undefined,
                    body: { text: data.value },
                    nativeFlowMessage: {
                        buttons: [{
                            "name": "cta_url",
                            "buttonParamsJson": JSON.stringify({
                                "display_text": `${keyword.toUpperCase()} Payment`,
                                "url": data.buttonUrl,
                                "merchant_url": data.buttonUrl
                            })
                        }]
                    }
                };
                
                cards.push(card);
            } else {
                const card = {
                    header: img ? {
                        hasMediaAttachment: true,
                        ...img
                    } : undefined,
                    body: { text: data.value },
                    nativeFlowMessage: {
                        buttons: [{
                            "name": "cta_copy",
                            "buttonParamsJson": JSON.stringify({
                                "display_text": `${keyword.toUpperCase()} Payment`,
                                "id": `${keyword}_payment`,
                                "copy_code": data.value
                            })
                        }]
                    }
                };
                
                cards.push(card);
            }
        }
    }
    
    if (cards.length === 0) {
        return Reply('âŒ Belum ada payment di grup ini.\nAdmin set: .setpay dana|081234');
    }
    
    const msgii = await generateWAMessageFromContent(m.chat, {
        viewOnceMessageV2Extension: {
            message: {
                messageContextInfo: {
                    deviceListMetadata: {},
                    deviceListMetadataVersion: 2
                }, 
                interactiveMessage: {
                    body: {
                        text: `Pilih salah satu metode pembayaran`
                    },
                    carouselMessage: {
                        cards: cards
                    }
                }
            }
        }
    }, { userJid: m.sender, quoted: m });
    
    await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id });
}
break;

case 'testimoni': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply('Format: .testimoni nama|produk|harga\nContoh: .testimoni Budi|Panel Pterodactyl|Rp5.000');
    
    let parts = text.split('|');
    if (parts.length < 3) return Reply('Format salah! Gunakan: nama|produk|harga');
    
    const namaPembeli = parts[0].trim();
    const produk = parts[1].trim();
    const harga = parts[2].trim();
    
    const tanggal = new Date().toLocaleDateString('id-ID', { 
        weekday: 'long',
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
    });
    
    const { createCanvas, registerFont } = require('canvas');
    const fs = require('fs');
    const path = require('path');
    
    const width = 1080;
    const height = 1350;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    
    const bgGradient = ctx.createLinearGradient(0, 0, width, height);
    bgGradient.addColorStop(0, '#0f0c29');
    bgGradient.addColorStop(0.5, '#302b63');
    bgGradient.addColorStop(1, '#24243e');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);
    
    for(let i = 0; i < 20; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const radius = Math.random() * 100;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, 0.03)`;
        ctx.fill();
    }
    
    const cardX = 80;
    const cardY = 150;
    const cardW = width - 160;
    const cardH = height - 300;
    const radius = 40;
    
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(cardX, cardY, cardW, cardH, radius);
    ctx.fillStyle = 'rgba(20, 20, 20, 0.6)';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 30;
    ctx.shadowOffsetY = 15;
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
    
    ctx.beginPath();
    ctx.arc(width/2, cardY, 60, 0, Math.PI * 2);
    ctx.fillStyle = '#00f260';
    ctx.fill();
    ctx.lineWidth = 5;
    ctx.strokeStyle = '#1e1e1e';
    ctx.stroke();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(width/2 - 15, cardY + 5);
    ctx.lineTo(width/2 - 5, cardY + 15);
    ctx.lineTo(width/2 + 20, cardY - 15);
    ctx.stroke();
    
    const centerX = width / 2;
    
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 50px sans-serif';
    ctx.fillText('PAYMENT SUCCESS', centerX, cardY + 100);
    
    ctx.fillStyle = '#a0a0a0';
    ctx.font = '30px sans-serif';
    ctx.fillText('Terima kasih atas pembelian Anda', centerX, cardY + 150);
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.setLineDash([15, 15]);
    ctx.moveTo(cardX + 40, cardY + 200);
    ctx.lineTo(cardX + cardW - 40, cardY + 200);
    ctx.stroke();
    ctx.setLineDash([]);
    
    const contentStart = cardY + 280;
    const labelColor = '#888888';
    const valueColor = '#ffffff';
    
    ctx.textAlign = 'left';
    
    ctx.fillStyle = labelColor;
    ctx.font = '30px sans-serif';
    ctx.fillText('NAMA PEMBELI', cardX + 60, contentStart);
    
    ctx.fillStyle = valueColor;
    ctx.font = 'bold 45px sans-serif';
    ctx.fillText(namaPembeli, cardX + 60, contentStart + 50);
    
    ctx.fillStyle = labelColor;
    ctx.font = '30px sans-serif';
    ctx.fillText('ITEM PRODUK', cardX + 60, contentStart + 140);
    
    ctx.fillStyle = valueColor;
    ctx.font = 'bold 45px sans-serif';
    ctx.fillText(produk, cardX + 60, contentStart + 190);
    
    ctx.fillStyle = labelColor;
    ctx.font = '30px sans-serif';
    ctx.fillText('TANGGAL', cardX + 60, contentStart + 280);
    
    ctx.fillStyle = valueColor;
    ctx.font = 'bold 35px sans-serif';
    ctx.fillText(tanggal, cardX + 60, contentStart + 330);
    
    const priceBoxY = contentStart + 400;
    
    ctx.fillStyle = 'rgba(0, 242, 96, 0.1)';
    ctx.beginPath();
    ctx.roundRect(cardX + 40, priceBoxY, cardW - 80, 120, 20);
    ctx.fill();
    ctx.strokeStyle = '#00f260';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.textAlign = 'center';
    ctx.fillStyle = '#00f260';
    ctx.font = 'bold 60px sans-serif';
    ctx.fillText(harga, centerX, priceBoxY + 80);
    
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = '24px sans-serif';
    ctx.fillText(`Verified by ${global.namaOwner} System`, centerX, cardY + cardH - 40);
    
    const tmpDir = './tmp';
    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
    const filePath = path.join(tmpDir, `testi_${Date.now()}.png`);
    
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(filePath, buffer);
    
    await alip.sendMessage(m.chat, {
        image: { url: filePath },
        caption: `âœ… *TRANSAKSI BERHASIL*\n\nðŸ‘¤ Buyer: ${namaPembeli}\nðŸ“¦ Item: ${produk}\nðŸ’¸ Total: ${harga}\n\nTerima kasih telah order!`
    }, { quoted: m });
    
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
}
break;


case 'gsmarena': {
    if (!text) return Reply('Masukkan nama perangkat. Contoh: .gsmarena samsung a15');
    await alip.sendMessage(m.chat, { react: { text: "ðŸ”", key: m.key } });
    try {
        const response = await axios.get(`https://gsmarena.com/results.php3?sQuickSearch=yes&sName=${encodeURIComponent(text)}`);
        const $ = cheerio.load(response.data);
        const devices = [];
        
        $(".makers li").each((i, e) => {
            const link = $(e).find("a").attr("href");
            const name = $(e).find("span").html().split("<br>").join(" ");
            const imgTitle = $(e).find("img").attr("title");
            
            if (link && name) {
                devices.push({
                    id: link.replace('.php', ''),
                    name: name,
                    desc: imgTitle || 'No description'
                });
            }
        });
        
        if (devices.length === 0) {
            return Reply('Tidak ditemukan perangkat dengan nama tersebut.');
        }
        
        let resultText = `ðŸ“± *Hasil Pencarian*\n\n`;
        devices.slice(0, 10).forEach((device, i) => {
            resultText += `${i+1}. *${device.name}*\n`;
            resultText += `   ðŸ“ ${device.desc}\n`;
            resultText += `   ðŸ”— https://gsmarena.com/${device.id}.php\n\n`;
        });
        
        if (devices.length > 10) {
            resultText += `*+${devices.length - 10} hasil lainnya...*`;
        }
        
        Reply(resultText);
        
    } catch (error) {
        console.error('GSM Arena Error:', error);
        Reply('Gagal mencari perangkat. Coba lagi nanti.');
    }
}
break;

case 'ttsbrando': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    if (!text) return Reply(`Contoh: ${prefix}${command} halo sayang`);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        await m.reply('Sedang membuat audio TTS...');
        
        const encodedText = encodeURIComponent(text);
        const apiUrl = `https://api-faa.my.id/faa/tts-brando?text=${encodedText}`;
        
        const response = await fetchJson(apiUrl);
        
        if (!response || !response.status || !response.url) {
            return Reply('Gagal membuat audio TTS');
        }
        
        await alip.sendMessage(m.chat, {
            audio: { url: response.url },
            mimetype: 'audio/mpeg',
            fileName: 'tts-brando.mp3',
            ptt: false,
            caption: `ðŸ“¢ *TTS Brando*\n\nText: ${response.text}\n\nCreator: ${response.creator}`
        }, { quoted: m });
        
    } catch (error) {
        console.error('TTS Error:', error);
        Reply('Terjadi kesalahan saat membuat TTS');
    }
    break;
}

case 'tictactoe':
case 'ttt':
case 'tttplay': {
    const result = await tictactoe.handleNewGame(m, args, Reply, alip, isCreator, global.checkLimit, global.addLimit, global.isRegistered, global.isPrem, global.mess);
    if (result) Reply(result);
    break;
}

case 'tttmove':
case 'ttt': {
    const result = await tictactoe.handleMove(m, text, Reply, alip);
    if (result) Reply(result);
    break;
}

case 'tttresign':
case 'tttsurrender': {
    const result = await tictactoe.handleResign(m, Reply);
    if (result) Reply(result);
    break;
}

case 'tttboard':
case 'tttstatus': {
    const result = await tictactoe.handleBoard(m, Reply);
    if (result) Reply(result);
    break;
}

case 'tttclean':
case 'tttcleanup': {
    if (!isCreator) return Reply('Command owner only');
    const result = await tictactoe.handleCleanup(Reply);
    if (result) Reply(result);
    break;
}
case 'voicecover': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    if (!text && !m.quoted) {
        return Reply(`ðŸŽ­ *VOICE COVER*\n\nGunakan:\n${prefix}voicecover <nama_model>\natau\n${prefix}voicecover <nama_model> (reply audio)\n\nContoh:\n${prefix}voicecover Miku\n${prefix}voicecover jokowi\n${prefix}voicecover naruto`);
    }
    
    let modelName = text.trim();
    
    if (!modelName && m.quoted) {
        return Reply(`âŒ *BUTUH NAMA MODEL*\n\nContoh:\n${prefix}voicecover Miku (reply audio)\n${prefix}voicecover jokowi (reply audio)`);
    }
    
    const isAudioMessage = m.quoted && (m.quoted.type === 'audioMessage' || m.quoted.type === 'videoMessage' || (m.quoted.msg && /audio/.test(m.quoted.mimetype || "")));
    
    if (!isAudioMessage) {
        return Reply(`âŒ *BUTUH AUDIO*\n\nReply audio dengan perintah:\n${prefix}voicecover ${modelName}`);
    }
    
    const processMsg = await Reply(`ðŸ”„ *Memproses Voice Cover...*\n\nModel: ${modelName}\nâ±ï¸ Estimasi: 1-2 menit\n\nMohon tunggu sebentar...`);
    
    try {
        let buffer;
        
        if (m.quoted.msg?.audioMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.quoted.msg, 'audio');
                let chunks = [];
                for await (const chunk of mediaBuffer) {
                    chunks.push(chunk);
                }
                buffer = Buffer.concat(chunks);
            } catch (e) {
                if (m.quoted.download) {
                    buffer = await m.quoted.download();
                } else {
                    throw new Error('Gagal mendownload audio');
                }
            }
        } else if (m.quoted.msg?.videoMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.quoted.msg, 'video');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else if (m.quoted.download) {
            buffer = await m.quoted.download();
        } else {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply('âŒ Gagal mengambil audio! Pastikan Anda membalas pesan audio/mp3 yang valid.');
        }
        
        if (!buffer || buffer.length === 0) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            throw new Error('Buffer audio kosong atau tidak valid!');
        }
        
        if (buffer.length > 10 * 1024 * 1024) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply('âŒ Audio terlalu besar! Maksimal 10MB.\nCoba dengan audio yang lebih pendek.');
        }
        
        const tempDir = path.join(os.tmpdir(), 'voice_cover');
        if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
        }
        
        const tempFile = path.join(tempDir, `${Date.now()}_${m.sender.split('@')[0]}.mp3`);
        fs.writeFileSync(tempFile, buffer);
        
        const api = {
            xterm: {
                url: `${global.termai}`,
                key: `${global.apitermai}`
            }
        };
        
        await alip.sendMessage(m.chat, { 
            react: { text: "â³", key: m.key } 
        });
        
        const audioData = fs.readFileSync(tempFile);
        
        try {
            const response = await axios.post(`${api.xterm.url}/api/audioProcessing/voice-covers`, audioData, {
                params: {
                    model: modelName,
                    key: api.xterm.key
                },
                headers: {
                    'Content-Type': 'application/octet-stream'
                },
                responseType: 'stream',
                timeout: 120000
            });
            
            let resultUrl = null;
            let isProcessing = true;
            
            await new Promise((resolve, reject) => {
                response.data.on('data', chunk => {
                    const eventString = chunk.toString();
                    const eventData = eventString.match(/data: (.+)/);
                    if (eventData) {
                        try {
                            const data = JSON.parse(eventData[1]);
                            console.log(data);
                            
                            switch (data.status) {
                                case 'success':
                                    resultUrl = data.result;
                                    isProcessing = false;
                                    response.data.destroy();
                                    resolve();
                                    break;
                                case 'failed':
                                    isProcessing = false;
                                    response.data.destroy();
                                    reject(new Error(data.msg || 'Voice cover failed'));
                                    break;
                                case 'searching':
                                case 'separating':
                                case 'starting':
                                case 'processing':
                                case 'mixing':
                                    break;
                            }
                        } catch (e) {}
                    }
                });
                
                response.data.on('end', () => {
                    if (isProcessing) {
                        reject(new Error('Processing timeout'));
                    }
                });
                
                response.data.on('error', (err) => {
                    reject(err);
                });
                
                setTimeout(() => {
                    if (isProcessing) {
                        response.data.destroy();
                        reject(new Error('Processing timeout after 2 minutes'));
                    }
                }, 120000);
            });
            
            if (resultUrl) {
                await alip.sendMessage(m.chat, { delete: processMsg.key });
                await alip.sendMessage(m.chat, { 
                    react: { text: "âœ…", key: m.key } 
                });
                
                await alip.sendMessage(m.chat, {
                    audio: { url: resultUrl },
                    mimetype: 'audio/mpeg',
                    fileName: `voice_cover_${modelName}.mp3`,
                    caption: `ðŸŽ­ *VOICE COVER BERHASIL!*\n\nSuara telah diubah menjadi: ${modelName}`,
                    ptt: false
                }, { quoted: m });
                
            } else {
                throw new Error('No result URL received');
            }
            
        } catch (error) {
            throw error;
        } finally {
            if (fs.existsSync(tempFile)) {
                fs.unlinkSync(tempFile);
            }
        }
        
    } catch (error) {
        console.error('Voice Cover Error:', error);
        
        try {
            if (processMsg?.key) {
                await alip.sendMessage(m.chat, { delete: processMsg.key });
            }
        } catch (e) {}
        
        let errorMessage = 'âŒ *GAGAL MEMPROSES VOICE COVER*';
        
        if (error.code === 'ECONNABORTED') {
            errorMessage += '\nâ±ï¸ Timeout - coba lagi nanti';
        } else if (error.message?.includes('too large')) {
            errorMessage += '\nðŸ“ File terlalu besar (maks 10MB)';
        } else if (error.message?.includes('timeout')) {
            errorMessage += '\nâ° Proses terlalu lama';
        } else if (error.message?.includes('model')) {
            errorMessage += '\nðŸš« Model tidak ditemukan atau tidak tersedia';
        } else {
            errorMessage += '\n' + (error.message || 'Terjadi kesalahan');
        }
        
        errorMessage += '\n\nCoba dengan model lain atau audio yang lebih pendek.';
        
        Reply(errorMessage);
    }
}
break;

case 'infogrup':
case 'groupinfo':
case 'gcinfo': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!')
    
    try {
        const groupMetadata = await alip.groupMetadata(m.chat)
        const participants = groupMetadata.participants
        
        const owner = participants.find(p => p.admin === 'superadmin') || participants[0]
        const admins = participants.filter(p => p.admin === 'admin')
        
        const creationDate = new Date(groupMetadata.creation * 1000)
        const now = new Date()
        const diffTime = now - creationDate
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24))
        
        const groupDB = global.db.groups[m.chat] || {}
        const botJoinTime = groupDB.botJoinTime ? new Date(groupDB.botJoinTime) : null
        const botDaysInGroup = botJoinTime ? Math.floor((now - botJoinTime) / (1000 * 60 * 60 * 24)) : 0
        
        let groupDesc = groupMetadata.desc || 'Tidak ada deskripsi'
        if (groupDesc.length > 100) {
            groupDesc = groupDesc.substring(0, 100) + '...'
        }
        
        const infoText = `ðŸ“Š *INFORMASI GRUP*

ðŸ·ï¸ *Nama Grup:* ${groupMetadata.subject}
ðŸ‘¤ *Pemilik:* @${owner.id.split('@')[0]}
ðŸ‘¥ *Total Anggota:* ${participants.length} orang
ðŸ“… *Dibuat:* ${creationDate.toLocaleDateString('id-ID')}
â³ *Usia Grup:* ${diffDays} hari
ðŸ¤– *Bot Bergabung:* ${botDaysInGroup} hari yang lalu

ðŸ’¬ *ID Grup:* ${m.chat}`

        let groupPicture
        try {
            groupPicture = await alip.profilePictureUrl(m.chat, 'image')
        } catch (e) {
            groupPicture = null
        }
        
        if (groupPicture) {
            await alip.sendMessage(m.chat, {
                image: { url: groupPicture },
                caption: infoText,
                mentions: [owner.id]
            }, { quoted: m })
        } else {
            await Reply(infoText, [owner.id])
        }
        
    } catch (error) {
        console.error('Group info error:', error)
        Reply('âŒ Gagal mengambil informasi grup.')
    }
}
break;
case 'tembak': {
    if (!m.isGroup) return Reply('âŒ Fitur ini hanya untuk grup!')
    
    let users = []
    if (m.mentionedJid && m.mentionedJid.length) {
        users = m.mentionedJid.map(id => {
            if (id.endsWith('@lid')) {
                let p = m.metadata?.participants?.find(x => x.lid === id || x.id === id)
                return p ? p.jid : null
            } else {
                return id
            }
        }).filter(Boolean)
    } else if (text) {
        const mentionedNumber = text.trim().replace(/[^0-9]/g, '')
        if (mentionedNumber.length < 10) return Reply('âŒ Format: .tembak @user atau .tembak 628xxx')
        users = [mentionedNumber + '@s.whatsapp.net']
    } else {
        return Reply('âŒ Tag seseorang! Contoh: .tembak @user')
    }
    
    if (users.length === 0) return Reply('âŒ Tidak ada user yang valid!')
    
    const targetUser = users[0]
    const shooter = m.sender
    
    const isSameUser = (jid1, jid2) => {
        const normalize = (jid) => jid.replace('@lid', '@s.whatsapp.net')
        return normalize(jid1) === normalize(jid2)
    }
    
    if (isSameUser(targetUser, shooter)) {
        return Reply('âŒ Gak bisa nembak diri sendiri!')
    }
    
    const targetName = targetUser.split('@')[0]
    const shooterName = shooter.split('@')[0]
    
    const couplesPath = './library/database/couples.json'
    if (!fs.existsSync(couplesPath)) {
        fs.writeFileSync(couplesPath, JSON.stringify({}))
    }
    
    const couplesData = JSON.parse(fs.readFileSync(couplesPath))
    
    const checkIfInRelationship = (jid) => {
        const normalizeJid = (jid) => jid.replace('@lid', '@s.whatsapp.net')
        const userJid = normalizeJid(jid)
        
        for (const coupleId in couplesData) {
            const couple = couplesData[coupleId]
            if (normalizeJid(couple.user1) === userJid || normalizeJid(couple.user2) === userJid) {
                return true
            }
        }
        return false
    }
    
    if (checkIfInRelationship(targetUser) || checkIfInRelationship(shooter)) {
        return Reply('âŒ Salah satu dari kalian sudah punya pasangan!')
    }
    
    const proposalId = `${shooter}_${targetUser}_${Date.now()}`
    
    global.tembakProposals = global.tembakProposals || {}
    global.tembakProposals[proposalId] = {
        shooter: shooter,
        target: targetUser,
        shooterName: m.pushName || shooterName,
        targetName: targetName,
        timestamp: Date.now(),
        groupId: m.chat,
        proposalMessageId: null
    }
    
    const proposalText = `ðŸ’˜ *PERMINTAAN JADIAN* ðŸ’˜

@${shooterName} nembak @${targetName} nih!

â° *Batas waktu: 5 menit*

Gunakan command: .terimajadian untuk menerima`
    
    const sentMsg = await Reply(proposalText, [shooter, targetUser])
    
    global.tembakProposals[proposalId].proposalMessageId = sentMsg.key.id
    
    setTimeout(() => {
        if (global.tembakProposals && global.tembakProposals[proposalId]) {
            delete global.tembakProposals[proposalId]
        }
    }, 5 * 60 * 1000)
    
    break
}

case 'terimajadian': {
    if (!m.isGroup) return Reply('âŒ Fitur ini hanya untuk grup!')
    
    const userJid = m.sender
    
    if (!global.tembakProposals) return Reply('âŒ Tidak ada permintaan jadian untuk kamu!')
    
    let matchedProposal = null
    let proposalId = null
    
    for (const id in global.tembakProposals) {
        const proposal = global.tembakProposals[id]
        const normalizedTarget = proposal.target.replace('@lid', '@s.whatsapp.net')
        const normalizedUser = userJid.replace('@lid', '@s.whatsapp.net')
        
        if (normalizedTarget === normalizedUser) {
            matchedProposal = proposal
            proposalId = id
            break
        }
    }
    
    if (!matchedProposal) {
        return Reply('âŒ Tidak ada permintaan jadian untuk kamu!')
    }
    
    const couplesPath = './library/database/couples.json'
    if (!fs.existsSync(couplesPath)) {
        fs.writeFileSync(couplesPath, JSON.stringify({}))
    }
    
    const couplesData = JSON.parse(fs.readFileSync(couplesPath))
    
    const coupleId = `${matchedProposal.shooter}_${matchedProposal.target}`
    
    couplesData[coupleId] = {
        user1: matchedProposal.shooter,
        user2: matchedProposal.target,
        user1Name: matchedProposal.shooterName,
        user2Name: matchedProposal.targetName,
        startedAt: Date.now()
    }
    
    fs.writeFileSync(couplesPath, JSON.stringify(couplesData, null, 2))
    
    delete global.tembakProposals[proposalId]
    
    const announcement = `ðŸŽ‰ *SELAMAT!* ðŸŽ‰

@${matchedProposal.shooterName} dan @${matchedProposal.targetName} resmi JADIAN! ðŸ’‘

Semoga langgeng selalu!

ðŸ’ ${matchedProposal.shooterName} + ${matchedProposal.targetName} = FOREVER ðŸ’

Gunakan command: .buatstreak biar hubungan kalian makin langgeng!`
    
    await Reply(announcement, [matchedProposal.shooter, matchedProposal.target])
    break
}

case 'setlist': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('Fitur ini khusus untuk admin grup.');
  
  if (!text) {
    const helpText = `
Gunakan: .setlist [template]

VARIABEL UNTUK .list:
â€¢ @name - Nama user yang lihat .list
â€¢ @group - Nama grup  
â€¢ @time - Waktu (HH:mm:ss)
â€¢ @date - Tanggal (DD/MM/YYYY)
â€¢ @fulldate - Hari, Tanggal Bulan Tahun
â€¢ @daytime - Pagi/Siang/Sore/Malam/Dini Hari
â€¢ @x - Daftar keyword
â€¢ @prefix teks - Ganti format item

CONTOH:
.setlist @prefix âœ¦
ðŸ“‹ DAFTAR PRODUK @group
@x

CONTOH LAIN:
.setlist ðŸ“‹ LIST @group
ðŸ‘‹ Hai @name!
ðŸ“… @fulldate
@prefix â†’

Daftar:
@x

NOTE: Auto response hanya tampilkan deskripsi dari .addlist`;
    return Reply(helpText);
  }
  
  const settings = loadListSettings();
  if (!settings[m.chat]) settings[m.chat] = {};
  
  const prefixMatch = text.match(/@prefix\s+([^\n]+)/i);
  if (prefixMatch && prefixMatch[1]) {
    settings[m.chat].prefix = prefixMatch[1].trim();
  } else {
    delete settings[m.chat].prefix;
  }
  
  settings[m.chat].template = text;
  
  if (m.type === 'imageMessage') {
    try {
      const media = await downloadAndSaveMedia(m, 'image');
      settings[m.chat].media = media;
      settings[m.chat].mediaType = 'image';
    } catch (e) {}
  } else if (m.quoted && m.quoted.type === 'imageMessage') {
    try {
      const media = await downloadAndSaveMedia(m.quoted, 'image');
      settings[m.chat].media = media;
      settings[m.chat].mediaType = 'image';
    } catch (e) {}
  } else {
    delete settings[m.chat].media;
    delete settings[m.chat].mediaType;
  }
  
  saveListSettings(settings);
  
  Reply(`Template .list berhasil diatur!${settings[m.chat]?.prefix ? `\nPrefix: "${settings[m.chat].prefix}"` : ''}

Sekarang .list akan tampil dengan template ini.`);
}
break;

case 'addlist': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('Fitur ini khusus untuk admin grup.');
  
  if (!text || !text.includes('|')) return Reply(`Format salah!

Contoh:
.addlist Burger|Burger dengan keju melt

Bisa juga kirim gambar dengan caption .addlist.`);
  
  // PERBAIKAN DI SINI:
  let parts = text.split('|');
  if (parts.length < 2) return Reply(`Format salah!
Pastikan ada nama dan deskripsi dipisahkan oleh |`);
  
  const nama = parts[0].trim();
  const deskripsi = parts.slice(1).join('|').trim(); // Ambil semua bagian setelah nama
  
  const chatId = m.chat;
  let listDb = loadLists();
  
  if (!listDb[chatId]) {
    listDb[chatId] = [];
  }
  
  const newItem = {
    name: nama,
    desc: deskripsi,
    addedBy: m.sender,
    addedAt: Date.now()
  };
  
  if (m.type === 'imageMessage') {
    try {
      const mediaPath = await downloadAndSaveMedia(m, 'image');
      newItem.image = mediaPath;
      newItem.hasImage = true;
    } catch (e) {}
  } else if (m.quoted && m.quoted.type === 'imageMessage') {
    try {
      const mediaPath = await downloadAndSaveMedia(m.quoted, 'image');
      newItem.image = mediaPath;
      newItem.hasImage = true;
    } catch (e) {}
  }
  
  listDb[chatId].push(newItem);
  saveLists(listDb);
  
  Reply(`Item berhasil ditambahkan!

ðŸ“ Nama: ${nama}
ðŸ“‹ Deskripsi: ${deskripsi}
${newItem.hasImage ? 'ðŸ–¼ï¸ Gambar: Tersedia' : ''}`);
}
break;

case 'list': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  
  const chatId = m.chat;
  const listDb = loadLists();
  const listGrup = listDb[chatId] || [];
  
  if (listGrup.length === 0) {
    return Reply(`Daftar kosong

Belum ada item di list grup ini.
Admin bisa menambahkan dengan:
.addlist nama|deskripsi`);
  }
  
  try {
    const groupMetadata = m.isGroup ? await alip.groupMetadata(chatId) : null;
    const groupName = groupMetadata ? groupMetadata.subject : 'Grup Ini';
    const userName = m.pushName || m.sender.split('@')[0];
    
    const listText = getListWithTemplate(chatId, userName, groupName, listGrup);
    
    const settings = loadListSettings();
    const chatSettings = settings[chatId];
    
    if (chatSettings && chatSettings.media) {
      await alip.sendMessage(chatId, {
        image: fs.readFileSync(chatSettings.media),
        caption: listText
      }, { quoted: m });
    } else {
      await alip.sendMessage(chatId, {
        text: listText
      }, { quoted: m });
    }
    
  } catch (e) {
    Reply('Gagal menampilkan daftar. Coba lagi nanti.');
  }
}
break;

case 'updatelist': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('Fitur ini khusus untuk admin grup.');
  
  if (!text || !text.includes('|')) return Reply(`Format: .updatelist [nama_item]|[deskripsi_baru]

Contoh:
.updatelist Burger|Dengan daging wagyu premium`);
  
  let parts = text.split('|');
  if (parts.length < 2) return Reply(`Format salah!
Minimal: .updatelist nama_item|deskripsi_baru`);
  
  const keyword = parts[0].trim();
  const deskripsiBaru = parts.slice(1).join('|').trim();
  
  const chatId = m.chat;
  const listDb = loadLists();
  let listGrup = listDb[chatId] || [];
  
  if (listGrup.length === 0) {
    return Reply(`Tidak ada item di list grup ini.`);
  }
  
  let itemIndex = listGrup.findIndex(item => 
    item.name.toLowerCase() === keyword.toLowerCase() ||
    item.name.toLowerCase().includes(keyword.toLowerCase())
  );
  
  if (itemIndex === -1) {
    return Reply(`Item "${keyword}" tidak ditemukan.`);
  }
  
  const itemLama = listGrup[itemIndex];
  
  // Hanya update deskripsi, nama tetap sama
  listGrup[itemIndex].desc = deskripsiBaru;
  
  // Handle gambar
  if (m.type === 'imageMessage') {
    try {
      if (itemLama.hasImage && itemLama.image && fs.existsSync(itemLama.image)) {
        fs.unlinkSync(itemLama.image);
      }
      const mediaPath = await downloadAndSaveMedia(m, 'image');
      listGrup[itemIndex].image = mediaPath;
      listGrup[itemIndex].hasImage = true;
    } catch (e) {}
  } else if (m.quoted && m.quoted.type === 'imageMessage') {
    try {
      if (itemLama.hasImage && itemLama.image && fs.existsSync(itemLama.image)) {
        fs.unlinkSync(itemLama.image);
      }
      const mediaPath = await downloadAndSaveMedia(m.quoted, 'image');
      listGrup[itemIndex].image = mediaPath;
      listGrup[itemIndex].hasImage = true;
    } catch (e) {}
  }
  
  listDb[chatId] = listGrup;
  saveLists(listDb);
  
  Reply(`Item berhasil diperbarui!

ðŸ“ Nama: ${itemLama.name}
ðŸ“‹ Deskripsi Baru: ${deskripsiBaru}
${listGrup[itemIndex].hasImage ? 'ðŸ–¼ï¸ Gambar: Diperbarui' : 'ðŸ–¼ï¸ Gambar: Tidak berubah'}`);
}
break;

case 'dellist': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('Fitur ini khusus untuk admin grup.');
  
  if (!text) return Reply(`Gunakan: .dellist [nama_keyword/angka]

Contoh:
.dellist Burger (hapus berdasarkan nama)
.dellist 1 (hapus berdasarkan nomor di .list)`);
  
  const chatId = m.chat;
  const listDb = loadLists();
  let listGrup = listDb[chatId] || [];
  
  if (listGrup.length === 0) {
    return Reply(`Tidak ada item untuk dihapus di grup ini.`);
  }
  
  let itemDihapus = null;
  let index = -1;
  
  if (!isNaN(text)) {
    index = parseInt(text) - 1;
    if (index >= 0 && index < listGrup.length) {
      itemDihapus = listGrup[index];
    }
  } else {
    const keyword = text.toLowerCase();
    index = listGrup.findIndex(item => 
      item.name.toLowerCase() === keyword ||
      item.name.toLowerCase().includes(keyword)
    );
    if (index !== -1) {
      itemDihapus = listGrup[index];
    }
  }
  
  if (!itemDihapus) {
    return Reply(`Item "${text}" tidak ditemukan.

Gunakan .list untuk melihat daftar.`);
  }
  
  if (itemDihapus.hasImage && itemDihapus.image && fs.existsSync(itemDihapus.image)) {
    try {
      fs.unlinkSync(itemDihapus.image);
    } catch (e) {}
  }
  
  listGrup.splice(index, 1);
  listDb[chatId] = listGrup;
  saveLists(listDb);
  
  Reply(`Item berhasil dihapus!

Nama: ${itemDihapus.name}
Deskripsi: ${itemDihapus.desc}`);
}
break;

case 'resetlist': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('Fitur ini khusus untuk admin grup.');
  
  const settings = loadListSettings();
  if (settings[m.chat]) {
    if (settings[m.chat].media && fs.existsSync(settings[m.chat].media)) {
      try {
        fs.unlinkSync(settings[m.chat].media);
      } catch (e) {}
    }
    
    delete settings[m.chat];
    saveListSettings(settings);
  }
  
  Reply(`Template list telah direset ke default!`);
}
break;

case 'vocalremover': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    if (!m.quoted || !(m.quoted.type === 'audioMessage' || m.quoted.type === 'videoMessage' || (m.quoted.msg && /audio/.test(m.quoted.mimetype || "")))) {
        return Reply(`ðŸŽµ *VOCAL REMOVER*\n\nReply audio yang ingin dipisahkan dengan perintah:\n*${prefix}vocalremover*\n\nFitur ini akan memisahkan audio menjadi 2 versi:\nâ€¢ ðŸŽ¼ Instrumental (tanpa vokal)\nâ€¢ ðŸŽ¤ Vocal only`);
    }
    
    const processMsg = await Reply('ðŸ”„ *Memproses audio...*\nâ±ï¸ Estimasi: 1-2 menit\n\nMohon tunggu sebentar...');
    
    try {
        let buffer;
        
        if (m.quoted.msg?.audioMessage) {
            try {
                const mediaBuffer = await downloadContentFromMessage(m.quoted.msg, 'audio');
                let chunks = [];
                for await (const chunk of mediaBuffer) {
                    chunks.push(chunk);
                }
                buffer = Buffer.concat(chunks);
            } catch (e) {
                if (m.quoted.download) {
                    buffer = await m.quoted.download();
                } else {
                    throw new Error('Gagal mendownload audio');
                }
            }
        } else if (m.quoted.msg?.videoMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.quoted.msg, 'video');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else if (m.quoted.download) {
            buffer = await m.quoted.download();
        } else {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply('âŒ Gagal mengambil audio! Pastikan Anda membalas pesan audio/mp3 yang valid.');
        }
        
        if (!buffer || buffer.length === 0) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            throw new Error('Buffer audio kosong atau tidak valid!');
        }
        
        if (buffer.length > 10 * 1024 * 1024) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply('âŒ Audio terlalu besar! Maksimal 10MB.\nCoba dengan audio yang lebih pendek.');
        }
        
        const tmpDir = path.join(os.tmpdir(), 'vocal_remover');
        if (!fs.existsSync(tmpDir)) {
            fs.mkdirSync(tmpDir, { recursive: true });
        }
        
        const tempFile = path.join(tmpDir, `${Date.now()}_${m.sender.split('@')[0]}.mp3`);
        fs.writeFileSync(tempFile, buffer);
        
        const form = new FormData();
        form.append('fileName', fs.createReadStream(tempFile), {
            filename: 'audio.mp3',
            contentType: 'audio/mpeg'
        });
        
        const uploadResponse = await axios.post('https://aivocalremover.com/api/v2/FileUpload', form, {
            headers: {
                ...form.getHeaders(),
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            timeout: 60000
        });
        
        const uploadResult = uploadResponse.data;
        
        if (!uploadResult?.file_name) {
            throw new Error('Upload audio gagal!');
        }
        
        const processBody = new URLSearchParams({
            file_name: uploadResult.file_name,
            action: 'watermark_video',
            key: 'X9QXlU9PaCqGWpnP1Q4IzgXoKinMsKvMuMn3RYXnKHFqju8VfScRmLnIGQsJBnbZFdcKyzeCDOcnJ3StBmtT9nDEXJn',
            web: 'web'
        });
        
        const processResponse = await axios.post('https://aivocalremover.com/api/v2/ProcessFile', processBody.toString(), {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'origin': 'https://aivocalremover.com',
                'referer': 'https://aivocalremover.com/'
            },
            timeout: 120000
        });
        
        const processResult = processResponse.data;
        
        if (!processResult?.instrumental_path || !processResult?.vocal_path) {
            throw new Error('Pemisahan audio gagal!');
        }
        
        const instrumentalUrl = processResult.instrumental_path;
        const vocalUrl = processResult.vocal_path;
        
        await alip.sendMessage(m.chat, { delete: processMsg.key });
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
        await alip.sendMessage(m.chat, {
            audio: { url: instrumentalUrl },
            mimetype: 'audio/mpeg',
            fileName: 'instrumental.mp3',
            caption: 'ðŸŽ¼ *INSTRUMENTAL* (tanpa vokal)',
            ptt: false
        }, { quoted: m });
        
        await sleep(2000);
        
        await alip.sendMessage(m.chat, {
            audio: { url: vocalUrl },
            mimetype: 'audio/mpeg',
            fileName: 'vocal_only.mp3',
            caption: 'ðŸŽ¤ *VOCAL ONLY* (hanya vokal)',
            ptt: false
        }, { quoted: m });
        
        if (fs.existsSync(tempFile)) {
            fs.unlinkSync(tempFile);
        }
        
    } catch (error) {
        console.error('Vocal Remover Error:', error);
        
        try {
            if (processMsg?.key) {
                await alip.sendMessage(m.chat, { delete: processMsg.key });
            }
        } catch (e) {}
        
        let errorMessage = 'âŒ *GAGAL MEMPROSES AUDIO*';
        
        if (error.code === 'ECONNABORTED') {
            errorMessage += '\nâ±ï¸ Timeout - coba lagi nanti';
        } else if (error.response?.status === 413) {
            errorMessage += '\nðŸ“ File terlalu besar (maks 10MB)';
        } else if (error.message?.includes('ENOTFOUND')) {
            errorMessage += '\nðŸŒ Server tidak dapat diakses';
        } else {
            errorMessage += '\n' + (error.message || 'Terjadi kesalahan');
        }
        
        errorMessage += '\n\nCoba dengan audio yang lebih pendek.';
        
        Reply(errorMessage);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
    }
    break;
}

case 'tempo': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || q.mediaType || '';

    if (!/audio/.test(mime)) {
        return Reply(`ðŸŽµ *UBAH TEMPO AUDIO*\n\nBalas audio yang ingin diubah temponya dengan perintah:\n*${prefix}tempo <kecepatan>*\n\nðŸ“Œ *Contoh:*\nâ€¢ ${prefix}tempo 0.8 (memperlambat)\nâ€¢ ${prefix}tempo 1.5 (mempercepat)\n\nâ„¹ï¸ *Tips:*\nâ€¢ Angka < 1 = memperlambat\nâ€¢ Angka > 1 = mempercepat\nâ€¢ Range: 0.5 - 2.0`);
    }

    const speed = parseFloat(text);
    if (isNaN(speed)) {
        return Reply(`âŒ Masukkan angka kecepatan yang valid!\nContoh: *${prefix}tempo 0.8*`);
    }

    if (speed < 0.5 || speed > 2.0) {
        return Reply('âŒ Kecepatan harus antara 0.5 dan 2.0 untuk menjaga kualitas audio!');
    }
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

    try {
        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (q.msg?.audioMessage) {
            const mediaBuffer = await downloadContentFromMessage(q.msg, 'audio');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('âŒ Gagal mengambil audio! Pastikan Anda membalas pesan audio yang valid.');
        }

        const tempDir = path.join(os.tmpdir(), 'wa-bot-temp');
        if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
        }
        const inputPath = path.join(tempDir, `input_${m.sender.split('@')[0]}_${Date.now()}.mp3`);
        const outputPath = path.join(tempDir, `output_${m.sender.split('@')[0]}_${Date.now()}.mp3`);
        fs.writeFileSync(inputPath, buffer);
        await new Promise((resolve, reject) => {
            require('fluent-ffmpeg')(inputPath)
                .audioFilter(`asetrate=48000*${speed}`)
                .on('error', (err) => {
                    reject(new Error(`FFmpeg error: ${err.message}`));
                })
                .on('end', () => {
                    resolve();
                })
                .save(outputPath);
        });
        await alip.sendMessage(m.chat, {
            audio: fs.readFileSync(outputPath),
            mimetype: 'audio/mpeg',
            fileName: `audio_${speed}x.mp3`,
            caption: `âœ… *Audio Berhasil Diubah*\n\nðŸ“Š Kecepatan: ${speed}x\nðŸŽµ Format: MP3\n\n> Powered by ${global.namaOwner}`
        }, { quoted: m });
        fs.unlinkSync(inputPath);
        fs.unlinkSync(outputPath);

    } catch (error) {
        console.error('Tempo Error:', error);
        Reply(`âŒ Gagal memproses audio: ${error.message}`);
    }
    break;
}

case 'kuismath':
case 'mathquiz':
case 'mathchallenge': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) {
        return Reply(`ðŸ§® *KUIS PENGETAHUAN UMUM*\n\nPilih kategori:\n\nðŸŽ¯ *MATEMATIKA*\n- Easy: 10 soal dasar\n- Normal: 15 soal menengah\n- Hard: 20 soal sulit\n\nðŸ“š *BAHASA INDONESIA*\n- Easy: 10 soal kosakata\n- Normal: 15 soal tata bahasa\n- Hard: 20 soal sastra\n\nðŸŒ *GEOGRAFI*\n- Easy: 10 soal ibukota\n- Normal: 15 soal geografis\n- Hard: 20 soal negara\n\nðŸ“– *SEJARAH*\n- Easy: 10 soal tokoh\n- Normal: 15 soal peristiwa\n- Hard: 20 soal tahun\n\nðŸŽ¨ *SENI & BUDAYA*\n- Easy: 10 soal seni\n- Normal: 15 soal budaya\n- Hard: 20 soal internasional\n\nâš¡ *SAINS & TEKNOLOGI*\n- Easy: 10 soal sains\n- Normal: 15 soal teknologi\n- Hard: 20 soal penemuan\n\nðŸŽ® *GAME & ANIME*\n- Easy: 10 soal karakter\n- Normal: 15 soal plot\n- Hard: 20 soal detail\n\nContoh: .kuismath matematika easy`);
    }

    const args = text.toLowerCase().trim().split(' ');
    if (args.length < 2) {
        return Reply('âŒ Format: .kuismath <kategori> <level>\nContoh: .kuismath matematika easy');
    }

    const category = args[0];
    const level = args[1];

    const validCategories = ['matematika', 'bahasa', 'geografi', 'sejarah', 'seni', 'sains', 'game'];
    const validLevels = ['easy', 'normal', 'hard'];

    if (!validCategories.includes(category)) {
        return Reply('âŒ Kategori tidak valid! Pilih: matematika, bahasa, geografi, sejarah, seni, sains, game');
    }

    if (!validLevels.includes(level)) {
        return Reply('âŒ Level tidak valid! Pilih: easy, normal, hard');
    }

    if (global.mathQuizSessions && global.mathQuizSessions[m.sender]) {
        return Reply('âš ï¸ Kamu sedang mengikuti kuis! Selesaikan dulu.');
    }

    const quizData = generateGeneralQuiz(category, level);
    
    if (!global.mathQuizSessions) global.mathQuizSessions = {};
    
    global.mathQuizSessions[m.sender] = {
        category: category,
        level: level,
        questions: quizData.questions,
        currentQuestion: 0,
        score: 0,
        startTime: Date.now(),
        timeLimit: level === 'easy' ? 300000 : level === 'normal' ? 450000 : 600000,
        reward: level === 'easy' ? 10 : level === 'normal' ? 25 : 50,
        answers: []
    };

    const session = global.mathQuizSessions[m.sender];
    const totalQuestions = session.questions.length;
    
    await Reply(`ðŸ§® *KUIS ${category.toUpperCase()} - ${level.toUpperCase()}*\n\nâ±ï¸ Waktu: ${Math.floor(session.timeLimit / 60000)} menit\nðŸ“Š Soal: ${totalQuestions} pertanyaan\nðŸŽ Hadiah: ${session.reward} limit\n\nKetik *mulai* untuk memulai kuis!\nKetik *batal* untuk membatalkan.`);

    break;
}

case 'mulai': {
    if (!global.mathQuizSessions || !global.mathQuizSessions[m.sender]) {
        return Reply('âŒ Tidak ada kuis yang aktif! Ketik .kuismath terlebih dahulu.');
    }

    const session = global.mathQuizSessions[m.sender];
    
    await Reply(`ðŸš€ *KUIS DIMULAI!*\n\nðŸ“š Kategori: ${session.category.toUpperCase()}\nðŸŽ¯ Level: ${session.level.toUpperCase()}\nðŸ“Š Total soal: ${session.questions.length}\nâ±ï¸ Waktu: ${Math.floor(session.timeLimit / 60000)} menit\nðŸŽ Hadiah: ${session.reward} limit\n\nSelamat mengerjakan! ðŸ’ª`);
    
    await sleep(2000);
    await sendQuizQuestion(m.sender, m.chat, session, alip);
    break;
}

case 'batal':
case 'quitmath': {
    if (!global.mathQuizSessions || !global.mathQuizSessions[m.sender]) {
        return Reply('âŒ Tidak ada kuis yang aktif!');
    }

    delete global.mathQuizSessions[m.sender];
    Reply('âœ… Kuis berhasil dibatalkan.');
    break;
}

case 'stikercmd': {
    if (!isCreator) return Reply('âŒ Command ini hanya untuk owner!');
    
    if (!m.quoted || m.quoted.type !== 'stickerMessage') {
        return Reply('âŒ Reply stiker yang ingin dijadikan command!');
    }
    
    if (!text) return Reply('âŒ Format: .stikercmd <command>\nContoh: .stikercmd .menu');
    
    const stickerId = m.quoted.message.stickerMessage?.fileSha256?.toString('hex') || 
                     m.quoted.message.stickerMessage?.stickerSha256?.toString('hex');
    
    if (!stickerId) return Reply('âŒ Gagal mendapatkan ID stiker!');
    
    const stickerCommands = loadStickerCommands();
    stickerCommands[stickerId] = {
        command: text.startsWith('.') ? text : `.${text}`,
        addedBy: m.sender,
        addedAt: Date.now(),
        stickerInfo: {
            isAnimated: m.quoted.message.stickerMessage?.isAnimated || false,
            packName: m.quoted.message.stickerMessage?.packName || 'Unknown'
        }
    };
    
    saveStickerCommands(stickerCommands);
    
    Reply(`âœ… Stiker berhasil diset sebagai command: *${text}*\n\nID Stiker: ${stickerId.substring(0, 16)}...`);
    break;
}
case 'delstikercmd': {
    if (!isCreator) return Reply('âŒ Command ini hanya untuk owner!');
    
    if (!m.quoted || m.quoted.type !== 'stickerMessage') {
        return Reply('âŒ Reply stiker yang ingin dihapus dari command!');
    }
    
    const stickerId = m.quoted.message.stickerMessage?.fileSha256?.toString('hex') || 
                     m.quoted.message.stickerMessage?.stickerSha256?.toString('hex');
    
    if (!stickerId) return Reply('âŒ Gagal mendapatkan ID stiker!');
    
    const stickerCommands = loadStickerCommands();
    
    if (!stickerCommands[stickerId]) {
        return Reply('âŒ Stiker ini belum dijadikan command!');
    }
    
    const removedCmd = stickerCommands[stickerId].command;
    delete stickerCommands[stickerId];
    saveStickerCommands(stickerCommands);
    
    Reply(`âœ… Command stiker *${removedCmd}* berhasil dihapus!`);
    break;
}

case 'wattpad':
case 'cariwattpad':
case 'wattpadsearch': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) return Reply('âŒ Masukkan kata kunci cerita Wattpad!\nContoh: .wattpad Anime');

    await alip.sendMessage(m.chat, { react: { text: "ðŸ”", key: m.key } });

    try {
        const searchQuery = encodeURIComponent(text);
        const apiUrl = `${global.yudzxml}/api/search/wattpad?q=${searchQuery}&apikey=${global.apikeyyud}`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.status !== 200 || !data.data || data.data.length === 0) {
            return Reply('âŒ Cerita Wattpad tidak ditemukan! Coba kata kunci lain.');
        }

        const stories = data.data.slice(0, 5);

        let resultText = `ðŸ“š *HASIL PENCARIAN WATTPAD*\n\n`;
        resultText += `ðŸ” Kata kunci: *${text}*\n`;
        resultText += `ðŸ“Š Ditemukan: ${data.data.length} cerita\n\n`;

        stories.forEach((story, index) => {
            resultText += `*${index + 1}. ${story.title}*\n`;
            resultText += `   ðŸ‘ï¸ Pembaca: ${story.readCount}\n`;
            resultText += `   â­ Vote: ${story.voteCount}\n`;
            resultText += `   ðŸ“– Bab: ${story.chapterCount}\n`;
            
            if (story.description) {
                const cleanDesc = story.description.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '');
                const shortDesc = cleanDesc.length > 100 ? cleanDesc.substring(0, 100) + '...' : cleanDesc;
                resultText += `   ðŸ“ ${shortDesc}\n`;
            }
            
            resultText += `   ðŸ”— ${story.link}\n\n`;
        });

        if (data.data.length > 5) {
            resultText += `ðŸ“‹ Dan ${data.data.length - 5} cerita lainnya...\n`;
        }

        await alip.sendMessage(m.chat, {
            image: { url: stories[0].image },
            caption: resultText
        }, { quoted: m });

    } catch (error) {
        console.error('Wattpad search error:', error);
        Reply('âŒ Gagal mencari cerita Wattpad. API mungkin sedang bermasalah.');
    }
    break;
}

case 'sidompul':
case 'ceksid':
case 'cekno': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) return Reply('âŒ Masukkan nomor HP!\nContoh: .sidompul 087835253027');

    let nomor = text.replace(/\D/g, '');
    if (!nomor.startsWith('62')) {
        if (nomor.startsWith('0')) {
            nomor = '62' + nomor.substring(1);
        } else {
            nomor = '62' + nomor;
        }
    }
    if (!nomor.startsWith('628')) {
        return Reply('âŒ Format nomor salah! Harus nomor Indonesia (contoh: 087835253027)');
    }

    m.reply('ðŸ“± Mengecek informasi nomor...');

    try {
        const apiUrl = `${global.yudzxml}/api/tools/sidompul?number=%2B${nomor}&apikey=${global.apikeyyud}`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.status !== 200 || !data.data || !data.data.data) {
            return Reply('âŒ Gagal mendapatkan informasi nomor. Nomor mungkin tidak valid.');
        }

        const info = data.data.data;

        let resultText = `ðŸ“± *INFORMASI NOMOR TELEPON*\n\n`;
        resultText += `ðŸ“ž *Nomor:* +${nomor}\n`;
        resultText += `ðŸ“¡ *Operator:* ${info.operator}\n`;
        resultText += `ðŸ“¶ *Status 4G:* ${info.status_4G}\n`;
        resultText += `ðŸ†” *Status Dukcapil:* ${info.dukcapil_status}\n`;
        resultText += `ðŸ“… *Umur Kartu:* ${info.card_age}\n`;
        resultText += `ðŸ“† *Masa Aktif:* ${info.active_period}\n`;
        resultText += `â³ *Grace Period:* ${info.grace_period}\n\n`;
        resultText += `â„¹ï¸ *Informasi ini berasal dari database Sidompul*`;

        await alip.sendMessage(m.chat, {
            text: resultText
        }, { quoted: m });

    } catch (error) {
        console.error('Sidompul error:', error);
        Reply('âŒ Gagal mengecek nomor. API mungkin sedang bermasalah.');
    }
    break;
}

case 'searchgame':
case 'cariandroid':
case 'gamesearch': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) return Reply('âŒ Masukkan nama game yang ingin dicari!\nContoh: .searchgame Pou');

    m.reply('ðŸ” Mencari game...');

    try {
        const searchQuery = encodeURIComponent(text);
        const apiUrl = `${global.yudzxml}/api/search/an1?q=${searchQuery}&apikey=${global.apikeyyud}`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.status !== 200 || !data.data || data.data.length === 0) {
            return Reply('âŒ Game tidak ditemukan! Coba kata kunci lain.');
        }

        const games = data.data.slice(0, 10);

        let resultText = `ðŸŽ® *HASIL PENCARIAN GAME*\n\n`;
        resultText += `ðŸ” Kata kunci: *${text}*\n`;
        resultText += `ðŸ“Š Ditemukan: ${data.data.length} game\n\n`;

        games.forEach((game, index) => {
            resultText += `*${index + 1}. ${game.name}*\n`;
            resultText += `   ðŸ‘¨â€ðŸ’» Developer: ${game.developer}\n`;
            resultText += `   â­ Rating: ${game.rating}/5\n`;
            resultText += `   ðŸ”— ${game.link}\n\n`;
        });

        if (data.data.length > 10) {
            resultText += `ðŸ“‹ Dan ${data.data.length - 10} game lainnya...\n`;
        }

        resultText += `\nðŸ“Œ *Tips:* Klik link untuk download game MOD APK`;

        await alip.sendMessage(m.chat, {
            image: { url: games[0].imageUrl },
            caption: resultText
        }, { quoted: m });

    } catch (error) {
        console.error('Game search error:', error);
        Reply('âŒ Gagal mencari game. API mungkin sedang bermasalah.');
    }
    break;
}
case 'spechtotext':
case 'speech2text':
case 'audiototext':
case 'stt': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';
    
    let audioUrl = '';
    
    if (/^audio\//.test(mime)) {
        try {
            await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
            
            let buffer;
            if (q.download) {
                buffer = await q.download();
            } else if (m.message?.audioMessage) {
                const mediaBuffer = await downloadContentFromMessage(m.message, 'audio');
                let chunks = [];
                for await (const chunk of mediaBuffer) {
                    chunks.push(chunk);
                }
                buffer = Buffer.concat(chunks);
            } else {
                return Reply('âŒ Gagal mendapatkan audio!');
            }
            
            const filename = `audio-${Date.now()}.mp3`;
            const uploadUrl = await uploadGitHub(buffer, 'audio/mpeg', () => filename);
            
            if (!uploadUrl) {
                return Reply('âŒ Gagal upload audio!');
            }
            
            audioUrl = uploadUrl;
            
        } catch (error) {
            console.error('Audio upload error:', error);
            return Reply('âŒ Gagal memproses audio!');
        }
    } else if (text && isUrl(text)) {
        audioUrl = text;
        await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    } else {
        return Reply('âŒ Reply audio atau berikan URL audio!\nContoh: .spechtotext [reply audio]');
    }

    try {
        const encodedUrl = encodeURIComponent(audioUrl);
        const apiUrl = `${global.yudzxml}/api/tools/spechtotext?url=${encodedUrl}&apikey=${global.apikeyyud}`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.status !== 200 || !data.data) {
            return Reply('âŒ Gagal mengonversi audio ke teks.');
        }

        const transcript = data.data;
        
        let resultText = `ðŸŽ¤ *HASIL KONVERSI AUDIO KE TEKS*\n\n`;
        resultText += `${transcript}\n\n`;
        resultText += `ðŸ”— *Sumber Audio:*\n${audioUrl}`;

        await alip.sendMessage(m.chat, {
            text: resultText
        }, { quoted: m });

    } catch (error) {
        console.error('Speech to text error:', error);
        Reply('âŒ Gagal mengonversi audio. API mungkin sedang bermasalah.');
    }
    break;
}
case "hidetagpoll": {
if (!isRegistered(m.sender) && !isCreator)
return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))  
    return Reply(global.mess.limit);  
  
addLimit(m.sender, global.isPrem(m.sender), isCreator);  
  
if (!m.isGroup) return Reply(mess.group);  
if (!isCreator && !m.isAdmin) return Reply(mess.admin);  
  
const members = m.metadata.participants.map(v => v.id);  
  
if (!text) return Reply("âŒ Format salah!\n\nGunakan: .hidetagpoll pertanyaan|jawaban1,jawaban2,jawaban3\n\n\nContoh:\n.hidetagpoll Menu makan siang?|Nasi Goreng,Mie Ayam,Bakso,Soto\n.hidetagpoll Pilihan warna?|Merah,Biru,Hijau,Kuning");  
  
const parts = text.split("|");  
if (parts.length < 2) return Reply("âŒ Format salah! Pisahkan pertanyaan dan jawaban dengan tanda '|'\n\nContoh: .hidetagpoll Pilihan warna?|Merah,Biru,Hijau");  
  
const question = parts[0].trim();  
const answersRaw = parts[1].trim();  
  
if (!question) return Reply("âŒ Pertanyaan tidak boleh kosong!");  
if (!answersRaw) return Reply("âŒ Jawaban tidak boleh kosong!");  
  
const pollOptions = answersRaw.split(",").map(opt => opt.trim()).filter(opt => opt);  
  
if (pollOptions.length < 2) return Reply("âŒ Minimal 2 jawaban untuk poll!");  
if (pollOptions.length > 12) return Reply("âŒ Maksimal 12 jawaban untuk poll!");  
  
try {  
    await alip.sendMessage(m.chat, {   
        text: `ðŸ“Š *POLLING HIDETAG*\n\n${question}\n\nTotal: ${members.length} member`,   
        mentions: members   
    });  
      
    setTimeout(async () => {  
        await alip.sendMessage(m.chat, {  
            poll: {  
                name: `ðŸ“Š ${question.substring(0, 60)}${question.length > 60 ? '...' : ''}`,  
                values: pollOptions,  
                selectableCount: 1  
            }  
        });  
    }, 1500);  
      
} catch (e) {  
    console.error("Hidetagpoll Error:", e);  
    Reply("âŒ Gagal membuat poll. Pastikan format benar!");  
}

}
break;
case 'tomirror': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/^image\//.test(mime)) {
        return Reply('Reply atau kirim gambar!');
    }

    try {
        m.reply('ðŸªž Membuat efek mirror...');

        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('Gagal mendapatkan gambar!');
        }

        const pixhostUrl = await uploadPixhost(buffer, `tomirror-${Date.now()}.jpg`);
        
        if (!pixhostUrl) {
            return Reply('Gagal upload gambar ke Pixhost!');
        }

        const encodedUrl = encodeURIComponent(pixhostUrl);
        const apiUrl = `https://api-faa.my.id/faa/tomirror?url=${encodedUrl}`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const resultBuffer = Buffer.from(response.data, 'binary');

        await alip.sendMessage(
            m.chat,
            { image: resultBuffer, caption: 'âœ… Mirror effect done' },
            { quoted: m }
        );

    } catch (e) {
        console.error('tomirror Error:', e);
        Reply('âŒ Gagal memproses gambar!');
    }
    break;
}
case 'sidergc':
case 'ceksider':
case 'sidercek':
case 'groupsider':
case 'sidergroup':
case 'sider':
case 'gcsider': {
    if (!m.isGroup) return Reply('Perintah ini hanya untuk grup');
    if (!isCreator && !m.isAdmin) return Reply('Hanya admin grup');
    
    try {
        const groupMetadata = await alip.groupMetadata(m.chat);
        const participants = groupMetadata.participants;
        
        const sevenDays = 86400000 * 7;
        const now = Date.now();
        
        if (!global.db.groups[m.chat]) {
            global.db.groups[m.chat] = {
                botJoinTime: Date.now() - (30 * 86400000),
                users: {}
            };
        }
        
        if (!global.db.groups[m.chat].botJoinTime) {
            global.db.groups[m.chat].botJoinTime = Date.now() - (30 * 86400000);
        }
        
        const botAgeDays = Math.floor((now - global.db.groups[m.chat].botJoinTime) / 86400000);
        
        let siderList = [];
        let activeList = [];
        let adminList = [];
        
        for (let participant of participants) {
            let memberJid = participant.jid || participant.id;
            let isAdmin = participant.admin !== null;
            
            if (isAdmin) {
                adminList.push(memberJid);
                continue;
            }
            
            if (memberJid.endsWith('@lid')) {
                let realParticipant = participants.find(p => p.id === memberJid);
                if (realParticipant && realParticipant.jid) {
                    memberJid = realParticipant.jid;
                } else {
                    memberJid = memberJid.replace('@lid', '@s.whatsapp.net');
                }
            }
            
            if (!memberJid.endsWith('@s.whatsapp.net')) {
                memberJid = memberJid + '@s.whatsapp.net';
            }
            
            if (!global.db.groups[m.chat].users) {
                global.db.groups[m.chat].users = {};
            }
            
            let userData = global.db.groups[m.chat].users[memberJid];
            
            if (!userData) {
                global.db.groups[m.chat].users[memberJid] = {
                    messages: 0,
                    lastMessage: 0,
                    name: participant.notify || memberJid.split('@')[0],
                    firstSeen: now
                };
                userData = global.db.groups[m.chat].users[memberJid];
            }
            
            if (userData.lastMessage > 0) {
                let inactiveDays = Math.floor((now - userData.lastMessage) / 86400000);
                
                if (inactiveDays > 7) {
                    siderList.push({
                        jid: memberJid,
                        name: userData.name,
                        lastMessage: userData.lastMessage,
                        daysInactive: inactiveDays,
                        messageCount: userData.messages
                    });
                } else {
                    activeList.push({
                        jid: memberJid,
                        name: userData.name,
                        daysInactive: inactiveDays
                    });
                }
            } else {
                let memberAge = Math.floor((now - userData.firstSeen) / 86400000);
                
                if (memberAge > 7) {
                    siderList.push({
                        jid: memberJid,
                        name: participant.notify || memberJid.split('@')[0],
                        daysInactive: memberAge,
                        status: 'NEVER_CHATTED'
                    });
                }
            }
        }
        
        if (siderList.length === 0) {
            return Reply(`âœ… *TIDAK ADA SIDER*\n\nTotal: ${participants.length}\nAktif: ${activeList.length}\nAdmin: ${adminList.length}\nBot: ${botAgeDays} hari`);
        }
        
        siderList.sort((a, b) => b.daysInactive - a.daysInactive);
        
        let resultText = `ðŸ“Š *SIDER REPORT*\n\n`;
        resultText += `ðŸ‘¥ *Grup:* ${groupMetadata.subject}\n`;
        resultText += `ðŸ“ˆ *Statistik:*\n`;
        resultText += `â€¢ Total: ${participants.length} member\n`;
        resultText += `â€¢ Sider: ${siderList.length}\n`;
        resultText += `â€¢ Aktif: ${activeList.length}\n`;
        resultText += `â€¢ Admin: ${adminList.length}\n`;
        resultText += `â€¢ Bot: ${botAgeDays} hari\n\n`;
        resultText += `ðŸ“Œ *Kriteria:*\n`;
        resultText += `1. Tidak chat di grup >7 hari\n`;
        resultText += `2. Bergabung >7 hari belum pernah chat\n\n`;
        resultText += `ðŸ‘¤ *DAFTAR SIDER:*\n`;
        
        let mentionJids = [];
        for (let i = 0; i < Math.min(siderList.length, 20); i++) {
            let sider = siderList[i];
            
            if (sider.status === 'NEVER_CHATTED') {
                resultText += `${i+1}. @${sider.jid.split('@')[0]}\n   ðŸ“› ${sider.name} - ${sider.daysInactive} hari belum chat\n\n`;
            } else {
                let lastDate = new Date(sider.lastMessage).toLocaleDateString('id-ID');
                resultText += `${i+1}. @${sider.jid.split('@')[0]}\n   â³ ${sider.name} - ${sider.daysInactive} hari (${lastDate})\n\n`;
            }
            mentionJids.push(sider.jid);
        }
        
        if (siderList.length > 20) {
            resultText += `ðŸ“‹ +${siderList.length - 20} sider lainnya\n\n`;
        }
        
        resultText += `âš¡ *Gunakan:* .siderkick untuk membersihkan`;
        
        await alip.sendMessage(m.chat, {
            text: resultText,
            mentions: mentionJids
        }, { quoted: m });
        
    } catch (error) {
        console.error('Sider error:', error);
        Reply('Gagal memindai sider');
    }
    break;
}

case 'siderkick':
case 'kicksider': {
    if (!m.isGroup) return Reply('Perintah ini hanya untuk grup');
    if (!isCreator && !m.isAdmin) return Reply('Hanya admin grup');
    if (!m.isBotAdmin) return Reply('Bot bukan admin');
    
    try {
        const groupMetadata = await alip.groupMetadata(m.chat);
        const participants = groupMetadata.participants;
        
        const sevenDays = 86400000 * 7;
        const now = Date.now();
        
        let kickList = [];
        
        for (let participant of participants) {
            let memberJid = participant.jid || participant.id;
            let isAdmin = participant.admin !== null;
            
            if (isAdmin) continue;
            
            if (memberJid.endsWith('@lid')) {
                let realParticipant = participants.find(p => p.id === memberJid);
                if (realParticipant && realParticipant.jid) {
                    memberJid = realParticipant.jid;
                } else {
                    memberJid = memberJid.replace('@lid', '@s.whatsapp.net');
                }
            }
            
            if (!memberJid.endsWith('@s.whatsapp.net')) {
                memberJid = memberJid + '@s.whatsapp.net';
            }
            
            if (!global.db.groups[m.chat]) global.db.groups[m.chat] = { users: {} };
            if (!global.db.groups[m.chat].users) global.db.groups[m.chat].users = {};
            
            let userData = global.db.groups[m.chat].users[memberJid];
            
            if (!userData) {
                global.db.groups[m.chat].users[memberJid] = {
                    messages: 0,
                    lastMessage: 0,
                    name: participant.notify || memberJid.split('@')[0],
                    firstSeen: now
                };
                userData = global.db.groups[m.chat].users[memberJid];
            }
            
            let shouldKick = false;
            let reason = '';
            
            if (userData.lastMessage > 0) {
                let inactiveDays = Math.floor((now - userData.lastMessage) / 86400000);
                if (inactiveDays > 7) {
                    shouldKick = true;
                    reason = `${inactiveDays} hari tidak chat`;
                }
            } else {
                let memberAge = Math.floor((now - userData.firstSeen) / 86400000);
                if (memberAge > 7) {
                    shouldKick = true;
                    reason = `${memberAge} hari belum pernah chat`;
                }
            }
            
            if (shouldKick) {
                kickList.push({
                    jid: memberJid,
                    name: userData.name || participant.notify || memberJid.split('@')[0],
                    reason: reason
                });
            }
        }
        
        if (kickList.length === 0) {
            return Reply('Tidak ada member yang perlu dikick');
        }
        
        let warningText = `âš ï¸ *KICK WARNING*\n\n`;
        warningText += `${kickList.length} member akan dikick:\n\n`;
        
        let mentionJids = [];
        for (let i = 0; i < Math.min(kickList.length, 10); i++) {
            let member = kickList[i];
            warningText += `${i+1}. @${member.jid.split('@')[0]}\n   ${member.name}\n   ${member.reason}\n\n`;
            mentionJids.push(member.jid);
        }
        
        if (kickList.length > 10) {
            warningText += `ðŸ“‹ +${kickList.length - 10} member lainnya\n\n`;
        }
        
        warningText += `â³ Proses mulai dalam 5 detik...`;
        
        await alip.sendMessage(m.chat, {
            text: warningText,
            mentions: mentionJids
        }, { quoted: m });
        
        await sleep(5000);
        
        let success = 0;
        let failed = 0;
        
        for (let member of kickList) {
            try {
                await alip.groupParticipantsUpdate(m.chat, [member.jid], 'remove');
                success++;
                await sleep(1200);
            } catch (e) {
                failed++;
            }
        }
        
        let resultMsg = `âœ… *KICK COMPLETE*\n\n`;
        resultMsg += `â€¢ Berhasil: ${success}\n`;
        resultMsg += `â€¢ Gagal: ${failed}\n`;
        resultMsg += `â€¢ Total: ${kickList.length}`;
        
        Reply(resultMsg);
        
    } catch (error) {
        console.error('Siderkick error:', error);
        Reply('Gagal melakukan kick');
    }
    break;
}
case 'tospiderman':
case 'tonaruto':
case 'tobatman':
case 'tosuperman':
case 'toironman':
case 'tocaptainamerica':
case 'tothor':
case 'tohulk':
case 'towolverine':
case 'todeadpool':
case 'toflash':
case 'toaquaman':
case 'tocyan':
case 'tovision':
case 'toblackpanther':
case 'tostarlord':
case 'togroot':
case 'torocket':
case 'todracula':
case 'tofrankenstein':
case 'towerewolf':
case 'tozombie':
case 'tovampire':
case 'toghost':
case 'toskeleton':
case 'todevil':
case 'toangel':
case 'tofairy':
case 'towizard':
case 'towinged':
case 'toelf':
case 'todwarf':
case 'toorc':
case 'totroll':
case 'togiant':
case 'tominotaur':
case 'tomedusa':
case 'tocentaur':
case 'togriffin':
case 'tophoenix':
case 'todragon':
case 'tounicorn':
case 'topeacock':
case 'towolf':
case 'tofox':
case 'tobear':
case 'tolion':
case 'totiger':
case 'topanda':
case 'tokoala':
case 'topenguin':
case 'toowl':
case 'toeagle':
case 'tofalcon':
case 'toraven':
case 'tocrow':
case 'tosnake':
case 'toshark':
case 'tocrocodile':
case 'tooctopus':
case 'tojellyfish':
case 'tostarfish':
case 'toseahorse':
case 'todolphin':
case 'towhale':
case 'torobot':
case 'tocyborg':
case 'toandroid':
case 'toalien':
case 'toufo':
case 'toastronaut':
case 'tocosmonaut':
case 'toscuba':
case 'todiver':
case 'topirate':
case 'tocowboy':
case 'toninja':
case 'tosamurai':
case 'toviking':
case 'toknight':
case 'toarcher':
case 'tomage':
case 'tocleric':
case 'tobard':
case 'torogue':
case 'tomonk':
case 'tobarbarian':
case 'tonecromancer':
case 'todruid':
case 'toranger':
case 'topaladin':
case 'togunslinger':
case 'tomechanic':
case 'toscientist':
case 'todoctor':
case 'toengineer':
case 'toartist':
case 'tosinger':
case 'todancer':
case 'toactor':
case 'todirector':
case 'towriter':
case 'tophotographer':
case 'tochef':
case 'tobaker':
case 'tobarista':
case 'tobartender':
case 'topilot':
case 'todriver':
case 'tosailor':
case 'tosoldier':
case 'topoliceman':
case 'tofirefighter':
case 'toteacher':
case 'toprofessor':
case 'tostudent':
case 'toprogrammer':
case 'todesigner':
case 'totester':
case 'tomanager':
case 'toboss':
case 'toceo':
case 'tocfo':
case 'tocoo':
case 'tocmo':
case 'tocto':
case 'tocpo':
case 'tocko':
case 'toclown':
case 'tomime':
case 'tojester':
case 'tomagician':
case 'toillusionist':
case 'toescapeartist':
case 'toacrobat':
case 'tocontortionist':
case 'toswordswallower':
case 'tofirebreather':
case 'tojugger':
case 'tounicyclist':
case 'totightrope':
case 'totrapeze':
case 'toaerialist':
case 'tocannon':
case 'tostilts':
case 'tomask':
case 'tomummy':
case 'tozorro':
case 'tosherlock':
case 'tophantom':
case 'todraco':
case 'tohannibal':
case 'tojoker':
case 'tovenom':
case 'tocarnage':
case 'togreen':
case 'tolizard':
case 'torhino':
case 'tovulture':
case 'toelectro':
case 'tosandman':
case 'tomysterio':
case 'togoblin':
case 'tochemo':
case 'toloki':
case 'tothanos':
case 'togalactus':
case 'todarkseid':
case 'tobrainiac':
case 'todoomsday':
case 'tobizarro':
case 'tometallo':
case 'toparasite':
case 'togrodd':
case 'tocircus':
case 'toreverse':
case 'togold':
case 'tosilver':
case 'tobronze':
case 'tocopper':
case 'tosteel':
case 'tocarbon':
case 'tocrystal':
case 'todiamond':
case 'tosapphire':
case 'toruby':
case 'toemerald':
case 'totopaz':
case 'toamethyst':
case 'toopal':
case 'toperidot':
case 'toaquamarine':
case 'tocitrine':
case 'totourmaline':
case 'togarnet':
case 'tospinel':
case 'tozircon':
case 'totanzanite':
case 'toiolite':
case 'tohematite':
case 'tomoonstone':
case 'tosunstone':
case 'tostarstone':
case 'tocomet':
case 'tometeor':
case 'toasteroid':
case 'tonebula':
case 'togalaxy':
case 'touniverse':
case 'toblackhole':
case 'towormhole':
case 'toportal':
case 'totime':
case 'tospace':
case 'todimension':
case 'toparallel':
case 'toalternate':
case 'tomultiverse':
case 'tomegaverse':
case 'tometaverse':
case 'toomniverse': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/^image\//.test(mime)) {
        return Reply('Reply atau kirim gambar!');
    }

    try {
        m.reply('â³ Memproses gambar...');

        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('Gagal mendapatkan gambar!');
        }

        const pixhostUrl = await uploadPixhost(buffer, `${command}-${Date.now()}.jpg`);
        
        if (!pixhostUrl) {
            return Reply('Gagal upload gambar ke Pixhost!');
        }

        const encodedUrl = encodeURIComponent(pixhostUrl);
        const promptMap = {
            'tospiderman': 'transform into Spider-Man in Marvel comics style, wearing iconic red and blue suit with web patterns, dynamic spider pose, detailed costume texture, while keeping the same original face and only changing the outfit',
            'tonaruto': 'transform into Naruto Uzumaki from Naruto anime, wearing orange jumpsuit, Konoha headband, spiky blonde hair, ninja pose, anime art style, while keeping the same original face and only changing the outfit',
            'tobatman': 'transform into Batman from DC comics, wearing black cape and cowl, bat symbol on chest, Gotham city background, dark knight aesthetic, while keeping the same original face and only changing the outfit',
            'tosuperman': 'transform into Superman, wearing blue suit with red cape and S symbol, heroic pose, flying in Metropolis, comic book style, while keeping the same original face and only changing the outfit',
            'toironman': 'transform into Iron Man, wearing red and gold armor suit with arc reactor, high-tech mechanical details, glowing repulsors, while keeping the same original face and only changing the outfit',
            'tocaptainamerica': 'transform into Captain America, wearing star-spangled uniform with shield, patriotic theme, WWII soldier aesthetic, while keeping the same original face and only changing the outfit',
            'tothor': 'transform into Thor from Asgard, wearing armor, holding Mjolnir hammer, lightning effects, Norse mythology style, while keeping the same original face and only changing the outfit',
            'tohulk': 'transform into Hulk, green skin, muscular physique, torn purple pants, angry expression, gamma radiation effects, while keeping the same original face and only changing the outfit',
            'towolverine': 'transform into Wolverine, wearing yellow and blue X-Men suit, adamantium claws extended, feral expression, mutant power, while keeping the same original face and only changing the outfit',
            'todeadpool': 'transform into Deadpool, wearing red and black suit, katana swords, fourth-wall breaking pose, Marvel anti-hero style, while keeping the same original face and only changing the outfit',
            'toflash': 'transform into The Flash, wearing red suit with lightning bolt symbol, speed force energy trails, running pose, while keeping the same original face and only changing the outfit',
            'toaquaman': 'transform into Aquaman, wearing orange and green suit, holding trident, underwater Atlantis background, while keeping the same original face and only changing the outfit',
            'tocyan': 'transform into Cyborg, half-human half-machine, robotic parts with glowing blue lights, Teen Titans aesthetic, while keeping the same original face and only changing the outfit',
            'tovision': 'transform into Vision, synthetic body with yellow gem on forehead, red face, cape, Marvel android style, while keeping the same original face and only changing the outfit',
            'toblackpanther': 'transform into Black Panther, wearing vibranium suit with panther helmet, Wakandan warrior aesthetic, while keeping the same original face and only changing the outfit',
            'tostarlord': 'transform into Star-Lord, wearing red jacket, helmet, holding blasters, Guardians of the Galaxy style, while keeping the same original face and only changing the outfit',
            'togroot': 'transform into Groot, tree-like humanoid, "I am Groot" pose, Guardians of the Galaxy flora colossus, while keeping the same original face and only changing the outfit',
            'torocket': 'transform into Rocket Raccoon, wearing tactical gear, holding large gun, cybernetic enhancements, while keeping the same original face and only changing the outfit',
            'todracula': 'transform into Count Dracula, vampire lord with red cape, pale skin, fangs, Transylvanian castle background, while keeping the same original face and only changing the outfit',
            'tofrankenstein': 'transform into Frankenstein\'s monster, green skin, neck bolts, square head, classic horror movie style, while keeping the same original face and only changing the outfit',
            'towerewolf': 'transform into werewolf, half-human half-wolf hybrid, full moon background, fur, claws, fangs, while keeping the same original face and only changing the outfit',
            'tozombie': 'transform into zombie, undead appearance, torn clothes, pale skin, hunger for brains, horror style, while keeping the same original face and only changing the outfit',
            'tovampire': 'transform into elegant vampire, formal attire, red eyes, pale complexion, Gothic aesthetic, while keeping the same original face and only changing the outfit',
            'toghost': 'transform into ghost, transparent ethereal form, haunting pose, paranormal energy aura, while keeping the same original face and only changing the outfit',
            'toskeleton': 'transform into living skeleton, bones visible, no flesh, spooky Halloween style, while keeping the same original face and only changing the outfit',
            'todevil': 'transform into devil, red skin, horns, tail, pitchfork, hellfire background, while keeping the same original face and only changing the outfit',
            'toangel': 'transform into angel, white wings, halo, heavenly light, divine aura, celestial being, while keeping the same original face and only changing the outfit',
            'tofairy': 'transform into fairy, small winged creature, magical forest background, glitter dust, enchanting, while keeping the same original face and only changing the outfit',
            'towizard': 'transform into wizard, long beard, pointed hat, staff, spellbook, magical aura, while keeping the same original face and only changing the outfit',
            'towinged': 'transform into winged humanoid, angelic or demonic wings, flying pose, fantasy creature, while keeping the same original face and only changing the outfit',
            'toelf': 'transform into elf, pointed ears, forest dweller, nature magic, fantasy RPG style, while keeping the same original face and only changing the outfit',
            'todwarf': 'transform into dwarf, short stature, beard, axe, mountain miner, fantasy warrior, while keeping the same original face and only changing the outfit',
            'toorc': 'transform into orc, green skin, tusks, tribal warrior, brutal strength, fantasy race, while keeping the same original face and only changing the outfit',
            'togoblin': 'transform into goblin, small green creature, mischievous expression, treasure hoarder, while keeping the same original face and only changing the outfit',
            'totroll': 'transform into troll, large brutish creature, bridge dweller, fantasy monster, while keeping the same original face and only changing the outfit',
            'togiant': 'transform into giant, enormous humanoid, cloud-height, mythological being, while keeping the same original face and only changing the outfit',
            'tominotaur': 'transform into minotaur, bull head human body, labyrinth dweller, Greek mythology, while keeping the same original face and only changing the outfit',
            'tomedusa': 'transform into Medusa, snake hair, stone gaze, Greek mythology gorgon, while keeping the same original face and only changing the outfit',
            'tocentaur': 'transform into centaur, half-human half-horse, archer pose, Greek mythology, while keeping the same original face and only changing the outfit',
            'togriffin': 'transform into griffin, eagle head lion body, mythical creature, guardian, while keeping the same original face and only changing the outfit',
            'tophoenix': 'transform into phoenix, firebird, rebirth from ashes, flaming wings, while keeping the same original face and only changing the outfit',
            'todragon': 'transform into dragon, winged reptile, fire breath, medieval fantasy, while keeping the same original face and only changing the outfit',
            'tounicorn': 'transform into unicorn, horse with horn, magical forest, rainbow mane, while keeping the same original face and only changing the outfit',
            'topeacock': 'transform into peacock, colorful feathers display, majestic bird, while keeping the same original face and only changing the outfit',
            'towolf': 'transform into wolf, pack animal, forest dweller, howling at moon, while keeping the same original face and only changing the outfit',
            'tofox': 'transform into fox, cunning animal, red fur, forest creature, while keeping the same original face and only changing the outfit',
            'tobear': 'transform into bear, powerful mammal, forest giant, protective, while keeping the same original face and only changing the outfit',
            'tolion': 'transform into lion, king of jungle, majestic mane, savanna, while keeping the same original face and only changing the outfit',
            'totiger': 'transform into tiger, striped predator, jungle hunter, powerful, while keeping the same original face and only changing the outfit',
            'topanda': 'transform into panda, bamboo eater, black and white, cute, while keeping the same original face and only changing the outfit',
            'tokoala': 'transform into koala, eucalyptus eater, tree climber, Australia, while keeping the same original face and only changing the outfit',
            'topenguin': 'transform into penguin, Antarctic bird, tuxedo appearance, waddling, while keeping the same original face and only changing the outfit',
            'toowl': 'transform into owl, wise bird, night hunter, rotating head, while keeping the same original face and only changing the outfit',
            'toeagle': 'transform into eagle, majestic bird of prey, soaring high, while keeping the same original face and only changing the outfit',
            'tofalcon': 'transform into falcon, fastest bird, hunting dive, while keeping the same original face and only changing the outfit',
            'toraven': 'transform into raven, intelligent bird, dark feathers, mystical, while keeping the same original face and only changing the outfit',
            'tocrow': 'transform into crow, black bird, ominous, flocking, while keeping the same original face and only changing the outfit',
            'tosnake': 'transform into snake, reptile, slithering, venomous or constrictor, while keeping the same original face and only changing the outfit',
            'toshark': 'transform into shark, ocean predator, sharp teeth, fin, while keeping the same original face and only changing the outfit',
            'tocrocodile': 'transform into crocodile, reptile, powerful jaws, river dweller, while keeping the same original face and only changing the outfit',
            'tooctopus': 'transform into octopus, eight arms, ocean creature, intelligent, while keeping the same original face and only changing the outfit',
            'tojellyfish': 'transform into jellyfish, translucent, floating, tentacles, while keeping the same original face and only changing the outfit',
            'tostarfish': 'transform into starfish, sea creature, radial symmetry, while keeping the same original face and only changing the outfit',
            'toseahorse': 'transform into seahorse, small fish, curled tail, ocean, while keeping the same original face and only changing the outfit',
            'todolphin': 'transform into dolphin, intelligent mammal, ocean, playful, while keeping the same original face and only changing the outfit',
            'towhale': 'transform into whale, largest mammal, ocean, majestic, while keeping the same original face and only changing the outfit',
            'torobot': 'transform into robot, mechanical humanoid, metallic body, futuristic, while keeping the same original face and only changing the outfit',
            'tocyborg': 'transform into cyborg, human with robotic parts, cybernetic enhancements, while keeping the same original face and only changing the outfit',
            'toandroid': 'transform into android, artificial human, synthetic skin, AI, while keeping the same original face and only changing the outfit',
            'toalien': 'transform into alien, extraterrestrial being, unknown biology, sci-fi, while keeping the same original face and only changing the outfit',
            'toufo': 'transform into UFO, flying saucer, alien spacecraft, abduction beam, while keeping the same original face and only changing the outfit',
            'toastronaut': 'transform into astronaut, space suit, zero gravity, NASA style, while keeping the same original face and only changing the outfit',
            'tocosmonaut': 'transform into cosmonaut, Russian space suit, Soviet space program, while keeping the same original face and only changing the outfit',
            'toscuba': 'transform into scuba diver, underwater, oxygen tank, exploring ocean, while keeping the same original face and only changing the outfit',
            'todiver': 'transform into deep sea diver, heavy suit, ocean depth exploration, while keeping the same original face and only changing the outfit',
            'topirate': 'transform into pirate, eye patch, wooden leg, parrot, treasure map, while keeping the same original face and only changing the outfit',
            'tocowboy': 'transform into cowboy, hat, boots, lasso, Wild West saloon, while keeping the same original face and only changing the outfit',
            'toninja': 'transform into ninja, black outfit, stealth pose, throwing stars, while keeping the same original face and only changing the outfit',
            'tosamurai': 'transform into samurai, armor, katana, Japanese warrior, honor code, while keeping the same original face and only changing the outfit',
            'toviking': 'transform into viking, horned helmet, axe, longship, Norse warrior, while keeping the same original face and only changing the outfit',
            'toknight': 'transform into knight, full plate armor, sword, shield, medieval, while keeping the same original face and only changing the outfit',
            'toarcher': 'transform into archer, bow and arrow, Robin Hood style, precise aim, while keeping the same original face and only changing the outfit',
            'tomage': 'transform into mage, spellcaster, elemental magic, fantasy RPG class, while keeping the same original face and only changing the outfit',
            'tocleric': 'transform into cleric, holy healer, divine magic, religious warrior, while keeping the same original face and only changing the outfit',
            'tobard': 'transform into bard, musical instrument, storyteller, charming performer, while keeping the same original face and only changing the outfit',
            'torogue': 'transform into rogue, stealth, daggers, thief, shadowy figure, while keeping the same original face and only changing the outfit',
            'tomonk': 'transform into monk, martial artist, spiritual, hand-to-hand combat, while keeping the same original face and only changing the outfit',
            'tobarbarian': 'transform into barbarian, fierce warrior, axe, tribal rage, while keeping the same original face and only changing the outfit',
            'tonecromancer': 'transform into necromancer, death magic, raising undead, dark arts, while keeping the same original face and only changing the outfit',
            'todruid': 'transform into druid, nature magic, animal shapeshifter, forest guardian, while keeping the same original face and only changing the outfit',
            'toranger': 'transform into ranger, wilderness expert, bow, animal companion, while keeping the same original face and only changing the outfit',
            'topaladin': 'transform into paladin, holy warrior, light magic, righteous crusader, while keeping the same original face and only changing the outfit',
            'togunslinger': 'transform into gunslinger, dual pistols, quick draw, Western outlaw, while keeping the same original face and only changing the outfit',
            'tomechanic': 'transform into mechanic, tools, grease stains, repairing machines, while keeping the same original face and only changing the outfit',
            'toscientist': 'transform into scientist, lab coat, test tubes, research, discovery, while keeping the same original face and only changing the outfit',
            'todoctor': 'transform into doctor, medical scrubs, stethoscope, healing profession, while keeping the same original face and only changing the outfit',
            'toengineer': 'transform into engineer, blueprint, hard hat, construction, design, while keeping the same original face and only changing the outfit',
            'toartist': 'transform into artist, paint palette, canvas, creative expression, while keeping the same original face and only changing the outfit',
            'tosinger': 'transform into singer, microphone, stage performance, musical talent, while keeping the same original face and only changing the outfit',
            'todancer': 'transform into dancer, graceful movements, performance art, rhythm, while keeping the same original face and only changing the outfit',
            'toactor': 'transform into actor, dramatic pose, movie set, character portrayal, while keeping the same original face and only changing the outfit',
            'todirector': 'transform into director, clapperboard, film set, creative vision, while keeping the same original face and only changing the outfit',
            'towriter': 'transform into writer, typewriter, books, literary creation, while keeping the same original face and only changing the outfit',
            'tophotographer': 'transform into photographer, camera, lens, capturing moments, while keeping the same original face and only changing the outfit',
            'tochef': 'transform into chef, chef hat, kitchen, cooking masterpiece, while keeping the same original face and only changing the outfit',
            'tobaker': 'transform into baker, pastry chef, oven, delicious baked goods, while keeping the same original face and only changing the outfit',
            'tobarista': 'transform into barista, coffee machine, latte art, cafÃ©, while keeping the same original face and only changing the outfit',
            'tobartender': 'transform into bartender, cocktail shaker, bar, mixing drinks, while keeping the same original face and only changing the outfit',
            'topilot': 'transform into pilot, flight suit, cockpit, aviation, while keeping the same original face and only changing the outfit',
            'todriver': 'transform into race car driver, helmet, fast car, speedway, while keeping the same original face and only changing the outfit',
            'tosailor': 'transform into sailor, naval uniform, ship wheel, ocean voyage, while keeping the same original face and only changing the outfit',
            'tosoldier': 'transform into soldier, military uniform, combat gear, battlefield, while keeping the same original face and only changing the outfit',
            'topoliceman': 'transform into police officer, uniform, badge, law enforcement, while keeping the same original face and only changing the outfit',
            'tofirefighter': 'transform into firefighter, fire suit, hose, rescue hero, while keeping the same original face and only changing the outfit',
            'toteacher': 'transform into teacher, classroom, chalkboard, education, while keeping the same original face and only changing the outfit',
            'toprofessor': 'transform into professor, academic gown, university, knowledge, while keeping the same original face and only changing the outfit',
            'tostudent': 'transform into student, backpack, books, learning, while keeping the same original face and only changing the outfit',
            'toprogrammer': 'transform into programmer, computer, code, software development, while keeping the same original face and only changing the outfit',
            'todesigner': 'transform into designer, sketchpad, creative concepts, visual art, while keeping the same original face and only changing the outfit',
            'totester': 'transform into quality tester, checking products, attention to detail, while keeping the same original face and only changing the outfit',
            'tomanager': 'transform into manager, office, leadership, business strategy, while keeping the same original face and only changing the outfit',
            'toboss': 'transform into boss, executive office, commanding presence, while keeping the same original face and only changing the outfit',
            'toceo': 'transform into CEO, corporate leader, boardroom, business decisions, while keeping the same original face and only changing the outfit',
            'tocfo': 'transform into CFO, financial expert, money management, while keeping the same original face and only changing the outfit',
            'tocoo': 'transform into COO, operations management, efficiency expert, while keeping the same original face and only changing the outfit',
            'tocmo': 'transform into CMO, marketing strategy, brand development, while keeping the same original face and only changing the outfit',
            'tocto': 'transform into CTO, technology leadership, innovation, while keeping the same original face and only changing the outfit',
            'tocpo': 'transform into CPO, product development, user experience, while keeping the same original face and only changing the outfit',
            'tocko': 'transform into CKO, knowledge management, information systems, while keeping the same original face and only changing the outfit',
            'toclown': 'transform into clown, colorful costume, red nose, circus performer, while keeping the same original face and only changing the outfit',
            'tomime': 'transform into mime, white face paint, invisible walls, silent performance, while keeping the same original face and only changing the outfit',
            'tojester': 'transform into jester, medieval court fool, bells, entertainment, while keeping the same original face and only changing the outfit',
            'tomagician': 'transform into magician, top hat, magic wand, illusion performance, while keeping the same original face and only changing the outfit',
            'toillusionist': 'transform into illusionist, mind tricks, grand magic show, while keeping the same original face and only changing the outfit',
            'toescapeartist': 'transform into escape artist, chains, locks, daring escapes, while keeping the same original face and only changing the outfit',
            'toacrobat': 'transform into acrobat, flexibility, balance, circus performance, while keeping the same original face and only changing the outfit',
            'tocontortionist': 'transform into contortionist, extreme flexibility, bending body, while keeping the same original face and only changing the outfit',
            'toswordswallower': 'transform into sword swallower, dangerous feat, circus act, while keeping the same original face and only changing the outfit',
            'tofirebreather': 'transform into fire breather, breathing fire, dangerous performance, while keeping the same original face and only changing the outfit',
            'tojugger': 'transform into juggler, multiple objects in air, coordination, while keeping the same original face and only changing the outfit',
            'tounicyclist': 'transform into unicyclist, balancing on one wheel, circus skill, while keeping the same original face and only changing the outfit',
            'totightrope': 'transform into tightrope walker, high wire, balance pole, while keeping the same original face and only changing the outfit',
            'totrapeze': 'transform into trapeze artist, flying through air, circus aerialist, while keeping the same original face and only changing the outfit',
            'toaerialist': 'transform into aerialist, silk ropes, aerial acrobatics, while keeping the same original face and only changing the outfit',
            'tocannon': 'transform into human cannonball, launched from cannon, daredevil, while keeping the same original face and only changing the outfit',
            'tostilts': 'transform into stilt walker, tall stilts, parade performer, while keeping the same original face and only changing the outfit',
            'tomask': 'transform into masked figure, mysterious identity, hidden face, while keeping the same original face and only changing the outfit',
            'tomummy': 'transform into mummy, ancient Egypt, wrapped bandages, cursed, while keeping the same original face and only changing the outfit',
            'tozorro': 'transform into Zorro, masked vigilante, sword, Spanish California, while keeping the same original face and only changing the outfit',
            'tosherlock': 'transform into Sherlock Holmes, detective, pipe, magnifying glass, while keeping the same original face and only changing the outfit',
            'tophantom': 'transform into Phantom of the Opera, mask, cape, tragic figure, while keeping the same original face and only changing the outfit',
            'todraco': 'transform into Dracula, vampire count, Transylvania, classic horror, while keeping the same original face and only changing the outfit',
            'tohannibal': 'transform into Hannibal Lecter, intelligent cannibal, psychological, while keeping the same original face and only changing the outfit',
            'tojoker': 'transform into Joker, clown prince of crime, chaotic evil, DC villain, while keeping the same original face and only changing the outfit',
            'tovenom': 'transform into Venom, black symbiote, spider-man antagonist, while keeping the same original face and only changing the outfit',
            'tocarnage': 'transform into Carnage, red symbiote, psychotic killer, while keeping the same original face and only changing the outfit',
            'togreen': 'transform into Green Goblin, goblin glider, pumpkin bombs, while keeping the same original face and only changing the outfit',
            'tolizard': 'transform into Lizard, reptilian creature, scientist transformed, while keeping the same original face and only changing the outfit',
            'torhino': 'transform into Rhino, powerful brute, armored suit, while keeping the same original face and only changing the outfit',
            'tovulture': 'transform into Vulture, winged villain, tech suit, while keeping the same original face and only changing the outfit',
            'toelectro': 'transform into Electro, electricity powers, lightning bolts, while keeping the same original face and only changing the outfit',
            'tosandman': 'transform into Sandman, sand body, shape-shifting, while keeping the same original face and only changing the outfit',
            'tomysterio': 'transform into Mysterio, fishbowl helmet, illusion master, while keeping the same original face and only changing the outfit',
            'tochemo': 'transform into Doctor Octopus, mechanical arms, brilliant scientist, while keeping the same original face and only changing the outfit',
            'toloki': 'transform into Loki, god of mischief, Asgardian, trickster, while keeping the same original face and only changing the outfit',
            'tothanos': 'transform into Thanos, Mad Titan, Infinity Gauntlet, cosmic threat, while keeping the same original face and only changing the outfit',
            'togalactus': 'transform into Galactus, devourer of worlds, cosmic entity, while keeping the same original face and only changing the outfit',
            'todarkseid': 'transform into Darkseid, New God, Omega beams, DC villain, while keeping the same original face and only changing the outfit',
            'tobrainiac': 'transform into Brainiac, alien android, knowledge collector, while keeping the same original face and only changing the outfit',
            'todoomsday': 'transform into Doomsday, creature that killed Superman, while keeping the same original face and only changing the outfit',
            'tobizarro': 'transform into Bizarro, opposite of Superman, imperfect clone, while keeping the same original face and only changing the outfit',
            'tometallo': 'transform into Metallo, cyborg with Kryptonite heart, while keeping the same original face and only changing the outfit',
            'toparasite': 'transform into Parasite, energy draining villain, while keeping the same original face and only changing the outfit',
            'togrodd': 'transform into Gorilla Grodd, super-intelligent ape, telepathy, while keeping the same original face and only changing the outfit',
            'tocircus': 'transform into circus performer, big top, carnival atmosphere, while keeping the same original face and only changing the outfit',
            'toreverse': 'transform into reversed version, mirror image, opposite colors, while keeping the same original face and only changing the outfit',
            'tomirror': 'transform into mirrored reflection, glass-like appearance, while keeping the same original face and only changing the outfit',
            'togold': 'transform into gold statue, metallic sheen, precious material, while keeping the same original face and only changing the outfit',
            'tosilver': 'transform into silver metallic form, shiny reflective surface, while keeping the same original face and only changing the outfit',
            'tobronze': 'transform into bronze statue, ancient metal, patina finish, while keeping the same original face and only changing the outfit',
            'tocopper': 'transform into copper material, reddish metallic, conductive, while keeping the same original face and only changing the outfit',
            'tosteel': 'transform into steel, industrial metal, strong and durable, while keeping the same original face and only changing the outfit',
            'tocarbon': 'transform into carbon fiber, modern material, lightweight strength, while keeping the same original face and only changing the outfit',
            'tocrystal': 'transform into crystal form, transparent, refractive, magical, while keeping the same original face and only changing the outfit',
            'todiamond': 'transform into diamond, hardest natural material, brilliant facets, while keeping the same original face and only changing the outfit',
            'tosapphire': 'transform into sapphire, blue gemstone, royal elegance, while keeping the same original face and only changing the outfit',
            'toruby': 'transform into ruby, red gemstone, passionate and vibrant, while keeping the same original face and only changing the outfit',
            'toemerald': 'transform into emerald, green gemstone, nature\'s treasure, while keeping the same original face and only changing the outfit',
            'totopaz': 'transform into topaz, golden gemstone, solar energy, while keeping the same original face and only changing the outfit',
            'toamethyst': 'transform into amethyst, purple gemstone, spiritual crystal, while keeping the same original face and only changing the outfit',
            'toopal': 'transform into opal, iridescent gemstone, rainbow colors, while keeping the same original face and only changing the outfit',
            'toperidot': 'transform into peridot, olive green gemstone, space origin, while keeping the same original face and only changing the outfit',
            'toaquamarine': 'transform into aquamarine, sea blue gemstone, ocean calm, while keeping the same original face and only changing the outfit',
            'tocitrine': 'transform into citrine, yellow gemstone, solar power, while keeping the same original face and only changing the outfit',
            'totourmaline': 'transform into tourmaline, multi-colored gemstone, electric, while keeping the same original face and only changing the outfit',
            'togarnet': 'transform into garnet, deep red gemstone, protective stone, while keeping the same original face and only changing the outfit',
            'tospinel': 'transform into spinel, various colors, misunderstood gem, while keeping the same original face and only changing the outfit',
            'tozircon': 'transform into zircon, brilliant gemstone, earth\'s oldest, while keeping the same original face and only changing the outfit',
            'totanzanite': 'transform into tanzanite, blue-violet, rare gemstone, while keeping the same original face and only changing the outfit',
            'toiolite': 'transform into iolite, violet-blue, Viking\'s compass, while keeping the same original face and only changing the outfit',
            'tohematite': 'transform into hematite, metallic gray, grounding stone, while keeping the same original face and only changing the outfit',
            'tomoonstone': 'transform into moonstone, glowing orb, lunar magic, while keeping the same original face and only changing the outfit',
            'tosunstone': 'transform into sunstone, golden glow, solar energy, while keeping the same original face and only changing the outfit',
            'tostarstone': 'transform into starstone, cosmic patterns, celestial, while keeping the same original face and only changing the outfit',
            'tocomet': 'transform into comet, celestial body, tail of light, while keeping the same original face and only changing the outfit',
            'tometeor': 'transform into meteor, shooting star, space rock, while keeping the same original face and only changing the outfit',
            'toasteroid': 'transform into asteroid, rocky body, asteroid belt, while keeping the same original face and only changing the outfit',
            'tonebula': 'transform into nebula, cosmic cloud, star nursery, while keeping the same original face and only changing the outfit',
            'togalaxy': 'transform into galaxy, spiral arms, billions of stars, while keeping the same original face and only changing the outfit',
            'touniverse': 'transform into universe, cosmic expanse, everything, while keeping the same original face and only changing the outfit',
            'toblackhole': 'transform into black hole, gravitational singularity, event horizon, while keeping the same original face and only changing the outfit',
            'towormhole': 'transform into wormhole, space-time tunnel, interstellar travel, while keeping the same original face and only changing the outfit',
            'toportal': 'transform into portal, dimensional gateway, magical entrance, while keeping the same original face and only changing the outfit',
            'totime': 'transform into time traveler, temporal displacement, clock motifs, while keeping the same original face and only changing the outfit',
            'tospace': 'transform into space explorer, cosmic environment, zero gravity, while keeping the same original face and only changing the outfit',
            'todimension': 'transform into dimensional being, alternate reality, physics defying, while keeping the same original face and only changing the outfit',
            'toparallel': 'transform into parallel universe version, similar but different, while keeping the same original face and only changing the outfit',
            'toalternate': 'transform into alternate self, different choices made, while keeping the same original face and only changing the outfit',
            'tomultiverse': 'transform into multiverse traveler, infinite possibilities, while keeping the same original face and only changing the outfit',
            'tomegaverse': 'transform into megaverse being, beyond multiverse, while keeping the same original face and only changing the outfit',
            'tometaverse': 'transform into metaverse entity, digital universe, while keeping the same original face and only changing the outfit',
            'toomniverse': 'transform into omniverse being, all of existence, while keeping the same original face and only changing the outfit'
        };

        const prompt = promptMap[command] || `transform into ${command.substring(2).replace(/[A-Z]/g, ' $&').toLowerCase().trim()}, detailed transformation, **keep the original facial features similar**`;
        const encodedPrompt = encodeURIComponent(prompt);
        
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodedUrl}&prompt=${encodedPrompt}`;
        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const resultBuffer = Buffer.from(response.data, 'binary');

        await alip.sendMessage(
            m.chat,
            { image: resultBuffer, caption: 'âœ… Done' },
            { quoted: m }
        );

    } catch (e) {
        console.error(`${command} Error:`, e);
        Reply('âŒ Gagal memproses gambar!');
    }
    break;
}

case 'tobabi': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/^image\//.test(mime)) {
        return Reply('Reply atau kirim gambar!');
    }

    try {
        m.reply('â³ Memproses gambar...');

        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('Gagal mendapatkan gambar!');
        }

        const pixhostUrl = await uploadPixhost(buffer, `tobabi-${Date.now()}.jpg`);
        
        if (!pixhostUrl) {
            return Reply('Gagal upload gambar ke Pixhost!');
        }

        const encodedUrl = encodeURIComponent(pixhostUrl);
        const apiUrl = `https://api-faa.my.id/faa/tobabi?url=${encodedUrl}`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const resultBuffer = Buffer.from(response.data, 'binary');

        await alip.sendMessage(
            m.chat,
            { image: resultBuffer, caption: 'âœ… Done' },
            { quoted: m }
        );

    } catch (e) {
        console.error('Tobabi Error:', e);
        Reply('âŒ Gagal memproses gambar!');
    }
    break;
}

case 'tomoai':
case 'tomonyet':
case 'topacar':
case 'tosatan': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/^image\//.test(mime)) {
        return Reply('Reply atau kirim gambar!');
    }

    try {
        m.reply('â³ Memproses gambar...');

        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('Gagal mendapatkan gambar!');
        }

        const pixhostUrl = await uploadPixhost(buffer, `${command}-${Date.now()}.jpg`);
        
        if (!pixhostUrl) {
            return Reply('Gagal upload gambar ke Pixhost!');
        }

        const encodedUrl = encodeURIComponent(pixhostUrl);
        const apiUrl = `https://api-faa.my.id/faa/${command}?url=${encodedUrl}`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const resultBuffer = Buffer.from(response.data, 'binary');

        await alip.sendMessage(
            m.chat,
            { image: resultBuffer, caption: 'âœ… Done' },
            { quoted: m }
        );

    } catch (e) {
        console.error(`${command} Error:`, e);
        Reply('âŒ Gagal memproses gambar!');
    }
    break;
}

case 'toroblox':
case 'topunk':
case 'tomangu':
case 'todpr':
case 'tosad': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/^image\//.test(mime)) {
        return Reply('Reply atau kirim gambar!');
    }

    try {
        m.reply('â³ Memproses gambar...');

        let buffer;
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
        } else {
            return Reply('Gagal mendapatkan gambar!');
        }

        const pixhostUrl = await uploadPixhost(buffer, `${command}-${Date.now()}.jpg`);
        
        if (!pixhostUrl) {
            return Reply('Gagal upload gambar ke Pixhost!');
        }

        const encodedUrl = encodeURIComponent(pixhostUrl);
        const apiUrl = `https://api-faa.my.id/faa/${command}?url=${encodedUrl}`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const resultBuffer = Buffer.from(response.data, 'binary');

        await alip.sendMessage(
            m.chat,
            { image: resultBuffer, caption: 'âœ… Done' },
            { quoted: m }
        );

    } catch (e) {
        console.error(`${command} Error:`, e);
        Reply('âŒ Gagal memproses gambar!');
    }
    break;
}

case 'infouser':
case 'userinfo': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    let users = []
    if (m.isGroup) {
        if (m.mentionedJid && m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else if (args[0]) {
            users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        } else {
            users = [m.sender]
        }
    } else {
        if (args[0]) {
            users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        } else {
            users = [m.sender]
        }
    }

    if (users.length === 0) {
        return Reply('âŒ Tidak ada user yang ditemukan!');
    }

    const targetJid = users[0];
    
    let targetName;
    if (m.isGroup) {
        const participant = m.metadata.participants.find(p => p.jid === targetJid || p.id === targetJid);
        if (participant) {
            targetName = participant.notify || participant.name || participant.id.split('@')[0];
        } else {
            targetName = targetJid.split('@')[0];
        }
    } else {
        try {
            const contact = await alip.getContact(targetJid);
            targetName = contact.name || contact.notify || targetJid.split('@')[0];
        } catch {
            targetName = targetJid.split('@')[0];
        }
    }

    try {
        m.reply('â³ Mengambil informasi user...');

        let profilePicture;
        try {
            profilePicture = await alip.profilePictureUrl(targetJid, 'image');
        } catch (e) {
            profilePicture = 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg';
        }

        let userLevel = { level: 1, xp: 0, messages: 0 };
        let groupActivity = {};
        
        const levelDBPath = './library/database/level.json';
        if (fs.existsSync(levelDBPath)) {
            try {
                const levelDB = JSON.parse(fs.readFileSync(levelDBPath, 'utf8'));
                
                if (m.isGroup && levelDB[m.chat] && levelDB[m.chat][targetJid]) {
                    const userData = levelDB[m.chat][targetJid];
                    userLevel = {
                        level: userData.level || 1,
                        xp: userData.xp || 0,
                        messages: userData.messages || 0
                    };
                }
            } catch (e) {}
        }

        const isPremiumUser = global.isPrem(targetJid);
        const isBlacklisted = blacklist.some(b => areJidsSameUser(b, targetJid));
        const isRegisteredUser = global.isRegistered(targetJid);

        const usageDB = safeReadJSON('./library/database/limit_usage.json', []);
        const today = getWIBTime().toISOString().split('T')[0];
        const userUsage = usageDB.find(v => areJidsSameUser(v.jid, targetJid));
        const todayLimitUsed = userUsage && userUsage.date === today ? userUsage.count : 0;
        const maxLimit = getUserMaxLimit(targetJid);
        const limitPercentage = Math.min(100, Math.round((todayLimitUsed / maxLimit) * 100));

        const streakDB = loadStreaks();
        let streakInfo = '';
        const userStreaks = Object.entries(streakDB).filter(([key, data]) => {
            const [jid1, jid2] = key.split(':');
            return areJidsSameUser(jid1, targetJid) || areJidsSameUser(jid2, targetJid);
        });
        
        if (userStreaks.length > 0) {
            const totalStreaks = userStreaks.length;
            const highestStreak = Math.max(...userStreaks.map(([_, data]) => data.streak || 0));
            streakInfo = `\nâ”œâ”€ ðŸ”¥ *Streak:* ${totalStreaks} hubungan â€¢ Tertinggi: ${highestStreak} hari`;
        }

        const premiumAccess = hasPremiumAccess(targetJid);
        let premiumInfo = '';
        if (isPremiumUser || premiumAccess) {
            const premDB = JSON.parse(fs.readFileSync('./library/database/premium.json'));
            const premData = premDB.find(v => areJidsSameUser(v.jid, targetJid));
            
            if (premData) {
                const daysLeft = Math.max(0, Math.floor((premData.expired - Date.now()) / (24 * 60 * 60 * 1000)));
                premiumInfo = `\nâ”œâ”€ ðŸ‘‘ *Premium:* âœ… (${daysLeft} hari tersisa)`;
            } else if (premiumAccess) {
                const accessData = loadPremiumAccess();
                const userAccess = accessData.users[targetJid];
                if (userAccess) {
                    const daysLeft = Math.max(0, Math.floor((userAccess.expires - Date.now()) / (24 * 60 * 60 * 1000)));
                    premiumInfo = `\nâ”œâ”€ ðŸ‘‘ *Premium Access:* âœ… (${daysLeft} hari tersisa)`;
                }
            }
        }

        let afkInfo = '';
        try {
            const afkData = JSON.parse(fs.readFileSync('./library/database/afk.json', 'utf8') || '[]');
            const userAfk = afkData.find(v => areJidsSameUser(v.jid, targetJid));
            if (userAfk) {
                const duration = Date.now() - userAfk.time;
                const hours = Math.floor(duration / (1000 * 60 * 60));
                const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
                afkInfo = `\nâ”œâ”€ ðŸ’¤ *AFK:* âœ… (${hours}j ${minutes}m â€¢ ${userAfk.reason})`;
            }
        } catch (e) {}

        let tttInfo = '';
        if (global.tttGames && m.isGroup) {
            const gameKey = m.chat;
            const game = global.tttGames[gameKey];
            if (game && (areJidsSameUser(game.playerX, targetJid) || areJidsSameUser(game.playerO, targetJid))) {
                const role = areJidsSameUser(game.playerX, targetJid) ? 'âŒ (X)' : 'â­• (O)';
                const status = game.status === 'playing' ? 'Sedang bermain' : 'Menunggu';
                tttInfo = `\nâ”œâ”€ ðŸŽ® *Tic Tac Toe:* ${role} â€¢ ${status}`;
            }
        }

        const userDBPath = './library/database/user.json';
        let registrationDate = 'Tidak terdaftar';
        if (fs.existsSync(userDBPath)) {
            try {
                const userDB = JSON.parse(fs.readFileSync(userDBPath, 'utf8'));
                const userData = userDB.find(v => areJidsSameUser(v.jid, targetJid));
                if (userData && userData.date) {
                    registrationDate = new Date(userData.date).toLocaleDateString('id-ID', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
            } catch (e) {}
        }

        const isOwnerUser = ownerList.some(ownerJid => areJidsSameUser(ownerJid, targetJid));
        const status = isOwnerUser ? 'ðŸ‘‘ Owner' : 
                      isPremiumUser || premiumAccess ? 'â­ Premium' : 
                      isRegisteredUser ? 'âœ… Terdaftar' : 'âŒ Belum terdaftar';

        const limitBar = makeProgressBar(todayLimitUsed, maxLimit, 10);

        const infoText = `â•­â”€â¬£ã€Œ *INFORMASI USER* ã€â¬£
â”‚
â”œâ”€ ðŸ“± *Nomor:* ${targetJid.split('@')[0]}
â”œâ”€ ðŸ†” *User ID:* ${targetJid}
â”œâ”€ ðŸ·ï¸ *Status:* ${status}
â”‚
â”œâ”€ ðŸ“Š *Statistik Grup Ini*
â”‚  â”œâ”€ ðŸ“ˆ Level: ${userLevel.level}
â”‚  â”œâ”€ â­ XP: ${userLevel.xp}
â”‚  â”œâ”€ ðŸ’¬ Pesan: ${userLevel.messages}
â”‚  â”œâ”€ ðŸ“Š Limit: ${todayLimitUsed}/${maxLimit}
â”‚  â”‚  ${limitBar}
â”‚  â””â”€ ðŸ“ˆ Penggunaan: ${limitPercentage}%${premiumInfo}${streakInfo}${afkInfo}${tttInfo}
â”œâ”€ ðŸ›¡ï¸ *Keamanan*
â”‚  â”œâ”€ ${isBlacklisted ? 'ðŸ”´' : 'ðŸŸ¢'} Blacklist: ${isBlacklisted ? 'Ya' : 'Tidak'}
â”‚  â””â”€ ðŸ“… Terdaftar: ${registrationDate}
â”‚
â”œâ”€ ðŸ”— *Kontak*
â”‚  â”œâ”€ ðŸ‘¤ Profile: wa.me/${targetJid.split('@')[0]}
â”‚  â””â”€ ðŸ“ž Chat: https://wa.me/${targetJid.split('@')[0]}?text=Halo
â”‚
â•°â”€â¬£

_â„¹ï¸ Data diperbarui: ${new Date().toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' })}_`;

        await alip.sendMessage(m.chat, {
            image: { url: profilePicture },
            caption: infoText,
            mentions: [targetJid]
        }, { quoted: m });

    } catch (error) {
        console.error('User Info Error:', error);
        Reply('âŒ Gagal mendapatkan informasi user.');
    }
    break;
}

case 'photoai': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    const axios = require("axios");
    const FormData = require("form-data");
    const Jimp = require("jimp");
    const fakeUserAgent = require("fake-useragent");
    const https = require("https");

    const agent = new https.Agent({
        rejectUnauthorized: false
    });

    if (!global.photoaiSessions) global.photoaiSessions = {};

    const PROMPT_LOCK = `@Azel:Subject 1: Guy in the image\nSubject 2: Girl in the image\nA downward-angled photograph captures the active MacBook screen filling nearly the entire frame, its glossy surface reflecting faint ambient light while revealing subtle pixel-grid texture from the close proximity, with only a thin strip of the keyboard visible along the lower edge. The digital workspace shows a dark-themed Spotify â€œLiked Songsâ€ window on the left and a large Photo Booth live-preview window on the right, where both Subjects appear side-by-side in a dim bedroom. They are still wearing the same oversized black hoodies, but the hoods rest back enough for their faces to remain fully visible, allowing natural light to fall cleanly across their expressions. The hoodie fabric forms soft folds and textured shadows around their shoulders and necklines, framing their faces without obscuring them. The couple reclines against an off-white wall and lightly rumpled bedding, leaning comfortably toward one another; the Guy holds a phone in his right hand, the clear protective case catching small screen reflections, while the Girl rests closely beside him, their proximity creating realistic overlapping shadows and gentle shared warmth in the frame. Ambient room lighting mixes with the cool glow of the MacBook screen, producing lifelike gradients on their skin, soft directional shading beneath their jawlines, and subtle highlights on foreheads and cheeks. Deep blacks from the interface, cool digital blues, muted greens, and warm skin tones combine into a natural, nocturnal color palette that feels candid and unedited. The full scene carries an HD, ultra-realistic, authentic atmosphere with natural imperfectionsâ€”tiny screen reflections, soft moirÃ© patterns, slight dust on the glassâ€”mirroring a real late-night moment taken by an iPhone camera. Do not change Subjectsâ€™ facial features. Subjects must look 1000% identical to uploaded images.`;

    async function uploadUguu(buffer, filename = "file.jpg") {
        const form = new FormData();
        form.append("files[]", buffer, { filename, contentType: "application/octet-stream" });
        const { data } = await axios.post("https://uguu.se/upload.php", form, {
            headers: { ...form.getHeaders(), "User-Agent": fakeUserAgent() },
            httpsAgent: agent,
            maxBodyLength: Infinity,
            timeout: 60000
        });
        const url = data?.files?.[0]?.url;
        if (!url) throw new Error("Upload ke Uguu gagal");
        return url;
    }

    async function mergePhotos(buf1, buf2) {
        const img1 = await Jimp.read(buf1);
        const img2 = await Jimp.read(buf2);
        const size = 700;
        img1.cover(size, size);
        img2.cover(size, size);
        const gap = 20;
        const canvas = new Jimp(size * 2 + gap, size, 0xffffffff);
        canvas.composite(img1, 0, 0);
        canvas.composite(img2, size + gap, 0);
        return await canvas.getBufferAsync(Jimp.MIME_JPEG);
    }

    const key = `${m.chat}:${m.sender}`;
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";

    if (!global.photoaiSessions[key]) {
        if (!/image\//i.test(mime)) {
            return Reply(`âŒ Balas *gambar pertama* dengan caption *${prefix}photoai*`);
        }
        const buf1 = await q.download();
        if (!buf1) return Reply("Gagal download gambar pertama.");
        
        global.photoaiSessions[key] = { buf1 };
        return m.reply(
            "âœ… Foto pertama disimpan!\n" +
            `Sekarang balas *gambar kedua* dengan caption *${prefix}photoai* lagi.\n\n` +
            `Ketik *.batalphotoai* untuk membatalkan.`
        );
        
    } else {
        const sess = global.photoaiSessions[key];
        if (!/image\//i.test(mime)) {
            return Reply(`âŒ Balas *gambar kedua* dengan caption *${prefix}photoai*`);
        }
        const buf2 = await q.download();
        if (!buf2) return Reply("Gagal download gambar kedua.");

        try {
            await alip.sendMessage(m.chat, { react: { text: "ðŸ”„", key: m.key } });
            m.reply("â³ Menggabungkan gambar dan memproses dengan AI, mohon tunggu...");

            const merged = await mergePhotos(sess.buf1, buf2);
            const mergedUrl = await uploadUguu(merged, "merged.jpg");

            const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(mergedUrl)}&prompt=${encodeURIComponent(PROMPT_LOCK)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*Done*` },
    { quoted: m }
);
        } catch (e) {
            await Reply("âŒ Error: " + e.message);
        } finally {
            delete global.photoaiSessions[key];
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        }
    }
}
break;

case 'addaksesprem': {
    if (!isCreator && !hasPremiumAccess(m.sender)) 
        return Reply('Hanya owner atau user dengan akses premium yang bisa!');
    
    if (!args[0]) return Reply(`Contoh:\n${prefix}addaksesprem 6281234567890 30\n${prefix}addaksesprem @tag 30`);
    
    let users = []
    if (m.isGroup) {
        if (m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else {
            users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    } else {
        users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }

    let days = Number(args[1])
    if (!days || days <= 0) days = 30
    if (days > 365) return Reply('Maksimal 365 hari!')
    
    const ms = days * 24 * 60 * 60 * 1000
    const expired = Date.now() + ms
    
    const data = loadPremiumAccess();
    
    for (let jid of users) {
        data.users[jid] = {
            addedBy: m.sender,
            addedAt: Date.now(),
            expires: expired,
            days: days
        };
    }
    
    savePremiumAccess(data);
    
    Reply(`Akses premium ${users.map(j => '@' + j.split('@')[0]).join(', ')} ditambahkan selama ${days} hari`, users);
    break;
}

case 'delaksesprem': {
    if (!isCreator) return Reply('Hanya owner yang bisa!');
    
    if (!args[0]) return Reply(`Contoh:\n${prefix}delaksesprem @tag\n${prefix}delaksesprem 6281234567890`);
    
    let targetJid = ''
    if (m.isGroup && m.mentionedJid.length) {
        const id = m.mentionedJid[0]
        if (id.endsWith('@lid')) {
            let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
            targetJid = p ? p.jid : null
        } else {
            targetJid = id
        }
    } else {
        targetJid = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    }
    
    if (!targetJid) return Reply('User tidak ditemukan!');
    
    const data = loadPremiumAccess();
    if (!data.users[targetJid]) 
        return Reply('User tidak punya akses premium!');
    
    delete data.users[targetJid];
    savePremiumAccess(data);
    
    Reply(`Akses premium @${targetJid.split('@')[0]} dihapus!`, [targetJid]);
    break;
}

case 'listaksesprem': {
    if (!isCreator && !hasPremiumAccess(m.sender)) 
        return Reply('Hanya owner atau user dengan akses premium yang bisa!');
    
    const data = loadPremiumAccess();
    const users = Object.entries(data.users);
    
    if (users.length === 0) 
        return Reply('Tidak ada user dengan akses premium!');
    
    let text = 'DAFTAR AKSES PREMIUM\n\n';
    const now = Date.now();
    
    users.forEach(([jid, info], i) => {
        const remaining = Math.max(0, Math.floor((info.expires - now) / (24 * 60 * 60 * 1000)));
        text += `${i+1}. @${jid.split('@')[0]}\n`;
        text += `   ${info.days} hari (${remaining}d tersisa)\n`;
        text += `   ${new Date(info.expires).toLocaleDateString('id-ID')}\n`;
        text += `   Oleh: @${info.addedBy.split('@')[0]}\n\n`;
    });
    
    const mentions = users.map(([jid]) => jid);
    Reply(text, mentions);
    break;
}

case 'setnamagc': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!isCreator && !m.isAdmin) return Reply('âŒ Hanya admin atau owner yang bisa!');
    if (!m.isBotAdmin) return Reply('âŒ Bot harus admin untuk ubah nama grup!');
    
    if (!text) return Reply('âŒ Masukkan nama grup baru!\nContoh: .setnamagc Grup Komunitas Kita');
    
    try {
        m.reply('â³ Mengubah nama grup...');
        
        if (text.length > 100) {
            return Reply('âŒ Nama terlalu panjang! Maksimal 100 karakter.');
        }
        
        await alip.groupUpdateSubject(m.chat, text);
        
        Reply('âœ… Nama grup berhasil diubah menjadi: ' + text);
    } catch (error) {
        console.error('Set Name Error:', error);
        
        if (error.message.includes('conflict') || error.data === 409) {
            Reply('âš ï¸ WhatsApp API sedang membatasi perubahan nama.\nCoba lagi dalam beberapa menit.');
        } else {
            Reply('âŒ Gagal mengubah nama grup. Pastikan bot memiliki permission yang cukup.');
        }
    }
    break;
}

case 'setppgc': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!isCreator && !m.isAdmin) return Reply('âŒ Hanya admin atau owner yang bisa!');
    if (!m.isBotAdmin) return Reply('âŒ Bot harus admin untuk ubah foto grup!');
    
    const quoted = m.quoted;
    let imageBuffer;
    if (quoted) {
        const quotedMime = (quoted.msg || quoted).mimetype || '';
        if (quotedMime.startsWith('image/')) {
            imageBuffer = await quoted.download();
        } else {
            return Reply('âŒ Hanya bisa reply ke gambar!');
        }
    } 
    else if (m.type === 'imageMessage') {
        imageBuffer = await downloadContentFromMessage(m.message, 'image');
        let chunks = [];
        for await (const chunk of imageBuffer) {
            chunks.push(chunk);
        }
        imageBuffer = Buffer.concat(chunks);
    } 
    else if (m.message?.imageMessage) {
        imageBuffer = await downloadContentFromMessage(m.message, 'image');
        let chunks = [];
        for await (const chunk of imageBuffer) {
            chunks.push(chunk);
        }
        imageBuffer = Buffer.concat(chunks);
    }
    else {
        return Reply('âŒ Reply atau kirim gambar untuk dijadikan foto grup!\n\n*Cara penggunaan:*\n1. Reply gambar dengan caption `.setppgc`\n2. Kirim gambar dengan caption `.setppgc`');
    }
    
    try {
        m.reply('â³ Mengubah foto grup...');
        
        await alip.updateProfilePicture(m.chat, imageBuffer);
        
        Reply('âœ… Foto grup berhasil diubah!');
    } catch (error) {
        console.error('Set PP Group Error:', error);
        Reply('âŒ Gagal mengubah foto grup. Pastikan bot memiliki permission yang cukup.');
    }
    break;
}

case 'schedule': {
    if (!m.isGroup) return Reply('âŒ Hanya untuk grup!');
    if (!isCreator && !m.isAdmin) return Reply('âŒ Hanya admin!');
    
    const subcmd = args[0]?.toLowerCase();
    
    if (subcmd === 'add' || subcmd === 'tambah') {
        if (args.length < 3) return Reply(`Format: ${prefix}schedule add <waktu> <pesan>\nContoh: ${prefix}schedule add 30m Selamat pagi semua!`);
        
        const timeStr = args[1];
        const message = args.slice(2).join(' ');
        
        let minutes = 0;
        if (timeStr.endsWith('m')) {
            minutes = parseInt(timeStr);
        } else if (timeStr.endsWith('h')) {
            minutes = parseInt(timeStr) * 60;
        } else if (timeStr.endsWith('d')) {
            minutes = parseInt(timeStr) * 60 * 24;
        } else {
            minutes = parseInt(timeStr);
        }
        
        if (isNaN(minutes) || minutes <= 0) return Reply('Waktu tidak valid!');
        
        const timestamp = Date.now() + (minutes * 60 * 1000);
        const data = JSON.parse(fs.readFileSync(schedulePath));
        
        data.messages.push({
            chat: m.chat,
            type: 'text',
            content: message,
            timestamp: timestamp,
            createdBy: m.sender,
            createdAt: Date.now(),
            scheduledFor: new Date(timestamp).toLocaleString('id-ID')
        });
        
        fs.writeFileSync(schedulePath, JSON.stringify(data, null, 2));
        
        Reply(`âœ… Pesan terjadwal ditambahkan!\nâ° Akan dikirim: ${new Date(timestamp).toLocaleString('id-ID')}\nðŸ“ Pesan: ${message}`);
    }
    else if (subcmd === 'list' || subcmd === 'daftar') {
        const data = JSON.parse(fs.readFileSync(schedulePath));
        const groupMessages = data.messages.filter(msg => msg.chat === m.chat);
        
        if (groupMessages.length === 0) return Reply('ðŸ“­ Tidak ada jadwal posting di grup ini.');
        
        let text = 'ðŸ“… *JADWAL POSTING GRUP*\n\n';
        groupMessages.forEach((msg, i) => {
            const timeLeft = Math.max(0, Math.floor((msg.timestamp - Date.now()) / 60000));
            text += `*${i+1}. ${msg.type.toUpperCase()}*\n`;
            text += `â° ${msg.scheduledFor}\n`;
            text += `â³ ${timeLeft} menit lagi\n`;
            text += `ðŸ“ ${msg.content.substring(0, 50)}${msg.content.length > 50 ? '...' : ''}\n`;
            text += `ðŸ‘¤ @${msg.createdBy.split('@')[0]}\n\n`;
        });
        
        Reply(text);
    }
    else if (subcmd === 'delete' || subcmd === 'hapus') {
        if (!args[1]) return Reply(`Format: ${prefix}schedule delete <nomor>\nGunakan ${prefix}schedule list untuk melihat nomor.`);
        
        const index = parseInt(args[1]) - 1;
        const data = JSON.parse(fs.readFileSync(schedulePath));
        const groupMessages = data.messages.filter(msg => msg.chat === m.chat);
        
        if (isNaN(index) || index < 0 || index >= groupMessages.length) {
            return Reply('âŒ Nomor tidak valid!');
        }
        
        const msgToDelete = groupMessages[index];
        data.messages = data.messages.filter(msg => 
            !(msg.chat === msgToDelete.chat && 
              msg.timestamp === msgToDelete.timestamp && 
              msg.content === msgToDelete.content)
        );
        
        fs.writeFileSync(schedulePath, JSON.stringify(data, null, 2));
        
        Reply(`âœ… Jadwal posting #${index+1} dihapus!`);
    }
    else if (subcmd === 'clear' || subcmd === 'bersihkan') {
        const data = JSON.parse(fs.readFileSync(schedulePath));
        const beforeCount = data.messages.length;
        
        data.messages = data.messages.filter(msg => msg.chat !== m.chat);
        
        fs.writeFileSync(schedulePath, JSON.stringify(data, null, 2));
        
        Reply(`âœ… ${beforeCount - data.messages.length} jadwal posting dibersihkan!`);
    }
    else {
        Reply(`ðŸ“… *FITUR JADWAL POSTING*\n\nGunakan:\nâ€¢ ${prefix}schedule add <waktu> <pesan> - Tambah jadwal\nâ€¢ ${prefix}schedule list - Lihat jadwal\nâ€¢ ${prefix}schedule delete <no> - Hapus jadwal\nâ€¢ ${prefix}schedule clear - Hapus semua\n\n*Format waktu:*\n30m = 30 menit\n2h = 2 jam\n1d = 1 hari`);
    }
    break;
}

case "onlyprem": {
if (!m.isGroup) return Reply(mess.group)
if (!isCreator && !m.isAdmin) return Reply(mess.admin)

if (!text) {
return Reply(
"Mode onlyPrem grup\n\n" +
"Gunakan:\n" +
".onlyprem on\n" +
".onlyprem off"
)
}

const data = loadOnlyPrem()

if (text === "on") {
data[m.chat] = true
saveOnlyPrem(data)
return Reply("Mode onlyPrem diaktifkan untuk grup ini.")
}

if (text === "off") {
data[m.chat] = false
saveOnlyPrem(data)
return Reply("Mode onlyPrem dimatikan untuk grup ini.")
}

Reply("Gunakan: .onlyprem on / off")
}
break

case "autoabsen": {
    if (!m.isGroup) return Reply("âŒ Command hanya untuk grup");
    if (!isCreator && !m.isAdmin) return Reply("âŒ Hanya admin yang bisa");
    
    const action = args[0]?.toLowerCase();
    const autoAbsenData = loadAutoAbsen();
    
    if (action === "on") {
        autoAbsenData[m.chat] = {
            enabled: true,
            time: "07:00",
            lastSent: "",
            activated: new Date().toISOString()
        };
        
        saveAutoAbsen(autoAbsenData);
        try {
            const now = new Date();
            const wibTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Jakarta' }));
            const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
            const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
            
            const day = dayNames[wibTime.getDay()];
            const date = wibTime.getDate();
            const month = monthNames[wibTime.getMonth()];
            const year = wibTime.getFullYear();
            
            await alip.sendMessage(m.chat, {
                poll: {
                    name: `ðŸ“… TEST ABSEN ${day}, ${date} ${month} ${year}`,
                    values: ['Hadir', 'Sakit', 'Izin', 'Alpa'],
                    selectableCount: 1
                }
            });
            
            await Reply(`âœ… Auto absen DIHIDUPKAN!\n\nðŸ“Œ Contoh poll absen sudah dikirim.\nâ° Default waktu: 07:00\nðŸ”§ Gunakan: ${prefix}setabsen <jam:menit> untuk ubah waktu`);
            
        } catch (e) {
            Reply(`âœ… Auto absen DIHIDUPKAN!\nâ° Default waktu: 07:00\nâš ï¸ Gagal kirim test poll: ${e.message}`);
        }
    } 
    else if (action === "off") {
        if (autoAbsenData[m.chat]) {
            autoAbsenData[m.chat].enabled = false;
            saveAutoAbsen(autoAbsenData);
        }
        Reply(`âŒ Auto absen DIMATIKAN.`);
    } 
    else if (action === "test") {
        try {
            const now = new Date();
            const wibTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Jakarta' }));
            const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
            const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
            
            const day = dayNames[wibTime.getDay()];
            const date = wibTime.getDate();
            const month = monthNames[wibTime.getMonth()];
            const year = wibTime.getFullYear();
            
            await alip.sendMessage(m.chat, {
                poll: {
                    name: `ðŸ“… TEST ABSEN ${day}, ${date} ${month} ${year}`,
                    values: ['Hadir', 'Sakit', 'Izin', 'Alpa'],
                    selectableCount: 1
                }
            });
            
            await Reply(`ðŸ“¨ Poll test terkirim!`);
            
        } catch (e) {
            Reply(`âŒ Gagal kirim test: ${e.message}`);
        }
    }
    else {
        const groupData = autoAbsenData[m.chat];
        const status = groupData?.enabled ? "AKTIF âœ…" : "MATI âŒ";
        const timeInfo = groupData?.enabled ? `â° Waktu: ${groupData.time}` : "";
        const lastInfo = groupData?.lastSent ? `ðŸ“… Terakhir: ${groupData.lastSent}` : "";
        
        Reply(`ðŸ“Š STATUS AUTO ABSEN\n\nStatus: ${status}\n${timeInfo}\n${lastInfo}\n\nGunakan:\nâ€¢ ${prefix}autoabsen on - hidupkan\nâ€¢ ${prefix}autoabsen off - matikan\nâ€¢ ${prefix}autoabsen test - test poll\nâ€¢ ${prefix}setabsen <jam:menit> - ubah waktu`);
    }
    break
}

case "setabsen": {
    if (!m.isGroup) return Reply("âŒ Command hanya untuk grup");
    if (!isCreator && !m.isAdmin) return Reply("âŒ Hanya admin yang bisa");
    
    if (!text) return Reply(`Contoh: ${prefix}setabsen 07:00`);
    
    const timePattern = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
    if (!timePattern.test(text)) return Reply('âŒ Format waktu salah!\nGunakan HH:MM (24 jam)\nContoh: 07:00, 13:30, 22:15');
    
    const autoAbsenData = loadAutoAbsen();
    
    if (!autoAbsenData[m.chat]) {
        autoAbsenData[m.chat] = {
            enabled: true,
            time: text,
            lastSent: "",
            activated: new Date().toISOString()
        };
    } else {
        autoAbsenData[m.chat].time = text;
        autoAbsenData[m.chat].enabled = true;
    }
    
    saveAutoAbsen(autoAbsenData);
    
    Reply(`âœ… Waktu absen diatur ke: ${text}\n\nðŸ“Œ Bot akan kirim poll absen:\nâ° Setiap hari jam ${text}`);
    break
}

case "tagadmin": {
    if (!m.isGroup) return Reply(mess.group);
    if (!isCreator && !m.isAdmin) return Reply(mess.admin);
if (!text) return Reply(example("pesannya"))

let teks = text+"\n\n"
let admins = await m.metadata.participants.filter(v => v.admin).map(v => v.id)
let adminList = admins.filter(e => e !== botNumber && e !== m.sender)

if (adminList.length === 0) {
    return Reply('âš ï¸ Tidak ada admin di grup ini.')
}

await adminList.forEach((e) => {
teks += `@${e.split("@")[0]}\n`
})
await alip.sendMessage(m.chat, {text: teks, mentions: [...adminList]}, {quoted: m})
}
break
case 'deletepanel':
case 'delpanel': {
    if (!isCreator && !isReseller(m.sender))
        return Reply("â›” AKSES DITOLAK!\n\nFitur ini hanya untuk Reseller atau Owner.");

    if (!text) {
        return Reply(`âŒ Format salah. Gunakan: *${prefix}deletepanel <server id>*`);
    }

    try {
        const fetch = require("node-fetch");
        const serverIdString = text.trim();
        const serverIdNum = parseInt(serverIdString);

        if (isNaN(serverIdNum) || serverIdNum <= 0) {
             return Reply(`âŒ Server ID harus berupa angka yang valid.`);
        }

        const panel = getPanelByServerId(serverIdNum);

        if (!panel) {
            return Reply(`âŒ Server ID *${serverIdString}* tidak ditemukan di database lokal.`);
        }

        if (!isCreator && panel.reseller !== m.sender) {
            return Reply(`âŒ Server *${panel.username || panel.serverName || panel.serverId}* bukan milik Anda dan tidak bisa dihapus.`);
        }

        let isPanelDeleted = false;
        let apiError = null;

        try {
            const delRes = await fetch(`${domain}/api/application/servers/${serverIdString}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${apikey}`,
                    'Accept': 'application/json'
                }
            });

            if (delRes.status === 204) {
                isPanelDeleted = true;
            } else if (delRes.status === 404) {
                apiError = "Server tidak ditemukan di panel.";
                isPanelDeleted = true; 
            } else {
                apiError = `Gagal menghapus server di panel: Status ${delRes.status}`;
            }

        } catch (e) {
            apiError = `Kesalahan koneksi saat menghapus panel: ${e.message}`;
        }

        removePanelEntry(serverIdNum);

        const successText = `âœ… *PENGHAPUSAN SERVER BERHASIL!*

ðŸ—‘ï¸ *Server ID:* ${serverIdString}
ðŸ‘¤ *Username:* ${panel.username || "N/A"}

*Catatan:*
- Entri database lokal sudah dihapus.
- Status penghapusan dari Pterodactyl: ${isPanelDeleted ? 'BERHASIL' : 'GAGAL'}
${apiError ? `*Detail API:* ${apiError}` : ''}

Server ini tidak akan muncul lagi di daftar dan tidak akan dicek oleh sistem expired.`;

        Reply(successText);

    } catch (error) {
        console.error('Delete Panel Error:', error);
        Reply(`âŒ Terjadi kesalahan saat menghapus panel: ${error.message}`);
    }
}
break;

case "installpanel": {
    if (!isOwner) return Reply(mess.owner)
    if (!text) return Reply("\nFormat salah!\n\n*Contoh penggunaan :*\nketik .instalpanel ipvps|pwvps|panel.com|node.com|ramserver *(contoh 100000)*");
    
    let vii = text.split("|");
    if (vii.length < 5) return Reply("\nFormat salah!\n\n*Contoh penggunaan :*\nketik .instalpanel ipvps|pwvps|panel.com|node.com|ramserver *(contoh 100000)*");
    
    const ssh2 = require("ssh2");
    const ress = new ssh2.Client();
    const connSettings = {
        host: vii[0],
        port: '22',
        username: 'root',
        password: vii[1]
    };
    
    const jids = m.chat
    const pass = "admin001";
    let passwordPanel = pass;
    const domainpanel = vii[2];
    const domainnode = vii[3];
    const ramserver = vii[4];
    const usernamePanel = "admin"; 
    const deletemysql = `\n`;
    const commandPanel = `bash <(curl -s https://pterodactyl-installer.se)`;
    
    async function instalWings() {
        ress.exec(commandPanel, async (err, stream) => {
            if (err) {
                console.error('Wings installation error:', err);
                Reply(`Gagal memulai instalasi Wings: ${err.message}`);
                return ress.end();
            }
            
            stream.on('close', async (code, signal) => {
                await InstallNodes()            
            }).on('data', async (data) => {
                const dataStr = data.toString();
                console.log('Wings Install: ' + dataStr);
                
                if (dataStr.includes('Input 0-6')) {
                    stream.write('1\n');
                }
                else if (dataStr.includes('(y/N)')) {
                    stream.write('y\n');
                }
                else if (dataStr.includes('Enter the panel address (blank for any address)')) {
                    stream.write(`${domainpanel}\n`);
                }
                else if (dataStr.includes('Database host username (pterodactyluser)')) {
                    stream.write('admin\n');
                }
                else if (dataStr.includes('Database host password')) {
                    stream.write('admin\n');
                }
                else if (dataStr.includes('Set the FQDN to use for Let\'s Encrypt (node.example.com)')) {
                    stream.write(`${domainnode}\n`);
                }
                else if (dataStr.includes('Enter email address for Let\'s Encrypt')) {
                    stream.write('admin@gmail.com\n');
                }
            }).stderr.on('data', async (data) => {
                console.error('Wings Install Error: ' + data);
                Reply(`Error pada instalasi Wings:\n${data}`);
            });
        });
    }

    async function InstallNodes() {
        ress.exec('bash <(curl -s https://raw.githubusercontent.com/SkyzoOffc/Pterodactyl-Theme-Autoinstaller/main/createnode.sh)', async (err, stream) => {
            if (err) throw err;
            
            stream.on('close', async (code, signal) => {
                
                let teks = `
*Install Panel Telah Berhasil âœ…*

*Berikut Detail Akun Panel Kamu ðŸ“¦*

ðŸ‘¤ Username : \`${usernamePanel}\`
ðŸ” Password : \`${passwordPanel}\`
ðŸŒ ${domainpanel}

Silahkan setting allocation & ambil token node di node yang sudah dibuat oleh bot.

*Cara menjalankan wings :*
\`.startwings ipvps|pwvps|tokennode\`
    `;

                let msg = await generateWAMessageFromContent(m.chat, {
                    viewOnceMessage: {
                        message: {
                            interactiveMessage: {
                                body: { text: teks },
                                nativeFlowMessage: {
                                    buttons: [
                                        { 
                                            name: "cta_copy",
                                            buttonParamsJson: `{"display_text":"Copy Username","copy_code":"${usernamePanel}"}`
                                        },
                                        { 
                                            name: "cta_copy",
                                            buttonParamsJson: `{"display_text":"Copy Password","copy_code":"${passwordPanel}"}`
                                        },
                                        { 
                                            name: "cta_url",
                                            buttonParamsJson: `{"display_text":"Login Panel","url":"${domainpanel}"}`
                                        }
                                    ]
                                }, 
                                contextInfo: {
                                    isForwarded: true
                                }
                            }
                        }
                    }
                }, {});

                await alip.relayMessage(m.chat, msg.message, { messageId: msg.key.id }); 
                ress.end();
            }).on('data', async (data) => {
                await console.log(data.toString());
                if (data.toString().includes("Masukkan nama lokasi: ")) {
                    stream.write('Singapore\n');
                }
                if (data.toString().includes("Masukkan deskripsi lokasi: ")) {
                    stream.write('Node By Skyzo\n');
                }
                if (data.toString().includes("Masukkan domain: ")) {
                    stream.write(`${domainnode}\n`);
                }
                if (data.toString().includes("Masukkan nama node: ")) {
                    stream.write('Skyzopedia\n');
                }
                if (data.toString().includes("Masukkan RAM (dalam MB): ")) {
                    stream.write(`${ramserver}\n`);
                }
                if (data.toString().includes("Masukkan jumlah maksimum disk space (dalam MB): ")) {
                    stream.write(`${ramserver}\n`);
                }
                if (data.toString().includes("Masukkan Locid: ")) {
                    stream.write('1\n');
                }
            }).stderr.on('data', async (data) => {
                console.log('Stderr : ' + data);
                Reply(`Error pada instalasi Wings: ${data}`);
            });
        });
    }

    async function instalPanel() {
        ress.exec(commandPanel, (err, stream) => {
            if (err) throw err;
            
            stream.on('close', async (code, signal) => {
                await instalWings();
            }).on('data', async (data) => {
                if (data.toString().includes('Input 0-6')) {
                    stream.write('0\n');
                } 
                if (data.toString().includes('(y/N)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('Database name (panel)')) {
                    stream.write('\n');
                }
                if (data.toString().includes('Database username (pterodactyl)')) {
                    stream.write('admin\n');
                }
                if (data.toString().includes('Password (press enter to use randomly generated password)')) {
                    stream.write('admin\n');
                } 
                if (data.toString().includes('Select timezone [Europe/Stockholm]')) {
                    stream.write('Asia/Jakarta\n');
                } 
                if (data.toString().includes('Provide the email address that will be used to configure Let\'s Encrypt and Pterodactyl')) {
                    stream.write('admin@gmail.com\n');
                } 
                if (data.toString().includes('Email address for the initial admin account')) {
                    stream.write('admin@gmail.com\n');
                } 
                if (data.toString().includes('Username for the initial admin account')) {
                    stream.write('admin\n');
                } 
                if (data.toString().includes('First name for the initial admin account')) {
                    stream.write('admin\n');
                } 
                if (data.toString().includes('Last name for the initial admin account')) {
                    stream.write('admin\n');
                } 
                if (data.toString().includes('Password for the initial admin account')) {
                    stream.write(`${passwordPanel}\n`);
                } 
                if (data.toString().includes('Set the FQDN of this panel (panel.example.com)')) {
                    stream.write(`${domainpanel}\n`);
                } 
                if (data.toString().includes('Do you want to automatically configure UFW (firewall)')) {
                    stream.write('y\n')
                } 
                if (data.toString().includes('Do you want to automatically configure HTTPS using Let\'s Encrypt? (y/N)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('Select the appropriate number [1-2] then [enter] (press \'c\' to cancel)')) {
                    stream.write('1\n');
                } 
                if (data.toString().includes('I agree that this HTTPS request is performed (y/N)')) {
                    stream.write('y\n');
                }
                if (data.toString().includes('Proceed anyways (your install will be broken if you do not know what you are doing)? (y/N)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('(yes/no)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('Initial configuration completed. Continue with installation? (y/N)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('Still assume SSL? (y/N)')) {
                    stream.write('y\n');
                } 
                if (data.toString().includes('Please read the Terms of Service')) {
                    stream.write('y\n');
                }
                if (data.toString().includes('(A)gree/(C)ancel:')) {
                    stream.write('A\n');
                } 
                console.log('Logger: ' + data.toString());
            }).stderr.on('data', (data) => {
                Reply(`Error Terjadi kesalahan :\n${data}`);
                console.log('STDERR: ' + data);
            });
        });
    }

    ress.on('ready', async () => {
        await Reply(`*Memproses install server panel ðŸš€*\n\n` +
                     `*IP Address:* ${vii[0]}\n` +
                     `*Domain Panel:* ${domainpanel}\n\n` +
                     `Mohon tunggu 10-20 menit hingga proses install selesai`);
        
        ress.exec(deletemysql, async (err, stream) => {
            if (err) throw err;
            
            stream.on('close', async (code, signal) => {
                await instalPanel();
            }).on('data', async (data) => {
                await stream.write('\t');
                await stream.write('\n');
                await console.log(data.toString());
            }).stderr.on('data', async (data) => {
                Reply(`Error Terjadi kesalahan :\n${data}`);
                console.log('Stderr : ' + data);
            });
        });
    });

    ress.on('error', (err) => {
        console.error('SSH Connection Error:', err);
        Reply(`Gagal terhubung ke server: ${err.message}`);
    });

    ress.connect(connSettings);
    break; 
}
case "startwings":
case "configurewings": {
    if (!isOwner) return Reply(mess.owner)
    let t = text.split('|');
    if (t.length < 3) return Reply("\nFormat salah!\n\n*Contoh penggunaan :*\nketik .startwings ipvps|pwvps|token_wings");

    let ipvps = t[0].trim();
    let passwd = t[1].trim();
    let token = t[2].trim();

    const ssh2 = require("ssh2"); 
    const ress = new ssh2.Client(); 

    const connSettings = {
        host: ipvps,
        port: 22,
        username: 'root',
        password: passwd
    };

    const command = `${token} && systemctl start wings`;

    ress.on('ready', () => {
        ress.exec(command, (err, stream) => {
            if (err) {
                Reply('Gagal menjalankan perintah di VPS');
                ress.end();
                return;
            }

            stream.on('close', async (code, signal) => {
                await Reply("Berhasil menjalankan wings node panel pterodactyl âœ…");
                ress.end();
            }).on('data', (data) => {
                console.log("STDOUT:", data.toString());
            }).stderr.on('data', (data) => {
                console.log("STDERR:", data.toString());
                stream.write("y\n");
                stream.write("systemctl start wings\n");
                Reply('Terjadi error saat eksekusi:\n' + data.toString());
            });
        });
    }).on('error', (err) => {
        console.log('Connection Error:', err.message);
        Reply('Gagal terhubung ke VPS: IP atau password salah.');
    }).connect(connSettings);
    break;
}

case "1gb": case "2gb": case "3gb": case "4gb": case "5gb": case "6gb": case "7gb": case "unlimited": case "unli": {
    if (!isCreator && !isReseller(m.sender)) 
        return Reply("AKSES DITOLAK! Fitur ini hanya untuk Reseller atau Owner. Hubungi owner jika ingin menjadi reseller.");

    const args = text.split(" ").filter(Boolean);  
    if (args.length < 2) return Reply(example("username jumlah_hari"));  
    
    let username = args[0].toLowerCase();  
    let days = parseInt(args[1]);   
    if (isNaN(days) || days <= 0 || days > 365) {
        return Reply("Jumlah hari tidak valid. Harap masukkan angka antara 1 hingga 365.");
    }

    if (!/^[a-z0-9]{3,15}$/.test(username)) {
        return Reply("Username tidak valid. Hanya boleh huruf kecil dan angka (3-15 karakter).");
    }

    let email = username + "@gmail.com";  
    let name = capital(username) + " Server";  
    let password = username + crypto.randomBytes(2).toString("hex");  
    let ram, disknya, cpu;  

    const specs = {
        "1gb": { ram: "1500", disk: "3000", cpu: "100" },
        "2gb": { ram: "3500", disk: "6000", cpu: "190" },
        "3gb": { ram: "4000", disk: "7000", cpu: "250" },
        "4gb": { ram: "5000", disk: "9000", cpu: "290" },
        "5gb": { ram: "6000", disk: "13000", cpu: "330" },
        "6gb": { ram: "7000", disk: "15000", cpu: "450" },
        "7gb": { ram: "8000", disk: "17000", cpu: "500" },
        "unlimited": { ram: "0", disk: "25000", cpu: "0" },
        "unli": { ram: "0", disk: "25000", cpu: "0" }
    };

    const spec = specs[command];
    ram = spec.ram;
    disknya = spec.disk;
    cpu = spec.cpu;

    const fetch = require("node-fetch");  

    try {
        m.reply("â³ Membuat panel... Mohon tunggu.");
        
        let checkUser = await fetch(`${domain}/api/application/users?filter[username]=${username}`, {  
            method: "GET",  
            headers: { "Authorization": `Bearer ${apikey}`, "Accept": "application/json" }  
        });  
        
        let checkData = await checkUser.json();  
        if (checkData.data && checkData.data.length > 0) {  
            let u = checkData.data[0].attributes;  
            return Reply(`Username ${u.username} sudah terdaftar di panel dengan email ${u.email}. Gunakan username lain.`);  
        }  

        let f = await fetch(domain + "/api/application/users", {  
            method: "POST",  
            headers: { "Accept": "application/json", "Content-Type": "application/json", "Authorization": "Bearer " + apikey },  
            body: JSON.stringify({  
                email: email,  
                username: username,  
                first_name: name,  
                last_name: "Server",  
                language: "en",  
                password: password  
            })  
        });  
        
        let data = await f.json();  
        if (data.errors) return Reply(`Gagal membuat user. Detail: ${JSON.stringify(data.errors[0], null, 2)}`);  

        let user = data.attributes;  
        let usr_id = user.id;  

        let f1 = await fetch(domain + `/api/application/nests/${nestid}/eggs/${egg}`, {
            method: "GET",
            headers: { "Accept": "application/json", "Content-Type": "application/json", "Authorization": "Bearer " + apikey }
        });
        
        let data2 = await f1.json();
        let startup_cmd = data2.attributes.startup;

        let f2 = await fetch(domain + "/api/application/servers", {  
            method: "POST",  
            headers: { "Accept": "application/json", "Content-Type": "application/json", "Authorization": "Bearer " + apikey },  
            body: JSON.stringify({  
                name: name,  
                description: `Server dibuat pada ${new Date().toLocaleDateString('id-ID')}`,  
                user: usr_id,  
                egg: parseInt(egg),  
                docker_image: "ghcr.io/parkervcp/yolks:nodejs_20",  
                startup: startup_cmd,   
                environment: { INST: "npm", USER_UPLOAD: "0", AUTO_UPDATE: "0", CMD_RUN: "npm start" },  
                limits: { memory: ram, swap: 0, disk: disknya, io: 500, cpu: cpu },  
                feature_limits: { databases: 5, backups: 5, allocations: 5 },  
                deploy: { locations: [parseInt(loc)], dedicated_ip: false, port_range: [] }  
            })  
        });  
        
        let result = await f2.json();  
        if (result.errors) return Reply(`Gagal membuat server. Detail: ${JSON.stringify(result.errors[0], null, 2)}`);  

        let server = result.attributes;  

        const expiresAt = Date.now() + (days * 24 * 60 * 60 * 1000);  
        
        addPanelEntry(server.id, {  
            serverId: server.id,  
            name: server.name,
            owner: m.sender,  
            username: user.username,  
            email: user.email,
            reseller: isReseller(m.sender) ? m.sender : null,
            expiresAt: expiresAt,  
            suspended: false,
            created: Date.now(),
            lastRenewed: Date.now(),
            notified: false,
            spec: {
                ram: ram,
                disk: disknya,
                cpu: cpu,
                type: command
            }
        });  
        
        let orang = m.isGroup ? m.sender : m.chat;  
        if (m.isGroup) {  
            await Reply("âœ… Panel berhasil dibuat! Data login sudah dikirim ke private chat.");  
        }  

        const expiryDate = new Date(expiresAt).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' });  
        var teks = `
â•­â”€â¬£ã€Œ *PANEL DIBUAT* ã€â¬£
â”‚
â”œâ”€ *Detail Akun*
â”‚  â”œâ”€ ðŸ‘¤ Username: \`${user.username}\`
â”‚  â”œâ”€ ðŸ”‘ Password: \`${password}\`
â”‚  â””â”€ ðŸŒ Login: ${global.domain}
â”‚
â”œâ”€ *Spesifikasi*
â”‚  â”œâ”€ ðŸ’¾ RAM: ${ram == "0" ? "Unlimited" : (ram / 1000) + "GB"}
â”‚  â”œâ”€ ðŸ’½ Disk: ${disknya == "0" ? "Unlimited" : (disknya / 1000) + "GB"}
â”‚  â””â”€ âš¡ CPU: ${cpu == "0" ? "Unlimited" : cpu + "%"}
â”‚
â”œâ”€ *Informasi*
â”‚  â”œâ”€ ðŸ†” Server ID: ${server.id}
â”‚  â”œâ”€ â° Durasi: ${days} Hari
â”‚  â””â”€ ðŸ“… Expired: ${expiryDate}
â”‚
${isReseller(m.sender) ? `â”œâ”€ *Reseller*\nâ”‚  â””â”€ ðŸ‘¤ @${m.sender.split('@')[0]}\nâ”‚` : ''}
â•°â”€â¬£

âš ï¸ *RULES PEMBELIAN PANEL*
1. Simpan data ini dengan baik
2. Seller hanya mengirim 1 kali
3. Garansi aktif 15 hari (1x replace)
4. Claim garansi wajib bawa bukti SS
`;

        await alip.sendMessage(orang, { 
            text: teks,
            mentions: isReseller(m.sender) ? [m.sender] : []
        }, { quoted: m });

    } catch (error) {
        console.error('Panel Creation Error:', error);
        Reply('âŒ Terjadi error saat membuat panel. Silakan coba lagi.');
    }
}
break;

case 'listpanel':
case 'mypanel': {
    if (!isCreator && !isReseller(m.sender)) 
        return Reply("â›” *AKSES DITOLAK!*\n\nFitur ini hanya untuk *Owner dan Reseller*!");

    try {
        await m.reply("â³ *Mengambil daftar panel dari server...*");

        const fetch = require('node-fetch');
        
        if (isReseller(m.sender) && !isCreator) {
            const myPanels = getResellerPanels(m.sender);
            
            if (myPanels.length === 0) {
                return Reply("âŒ Belum ada panel yang dibuat oleh Anda.");
            }

            let listText = "â•­â”€â¬£ã€Œ *PANEL ANDA* ã€â¬£\nâ”‚\n";
            let validServerCount = 0;
            let totalDaysLeft = 0;
            
            for (const panel of myPanels) {
                try {
                    const res = await fetch(`${domain}/api/application/servers/${panel.serverId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apikey}`,
                            'Accept': 'application/json'
                        },
                        timeout: 10000
                    });

                    if (res.ok) {
                        const serverData = await res.json();
                        const serverName = serverData.attributes.name;
                        const daysLeft = Math.ceil((panel.expiresAt - Date.now()) / (1000 * 60 * 60 * 24));
                        totalDaysLeft += daysLeft;
                        
                        const status = daysLeft > 0 ? `ðŸŸ¢ (${daysLeft}d)` : `ðŸ”´ (EXPIRED)`;
                        listText += `â”œâ”€ ${serverName} ${status}\n`;
                        validServerCount++;
                    }
                } catch (e) {
                }
            }
            
            if (validServerCount === 0) {
                return Reply("âŒ Tidak ada panel aktif yang ditemukan di server.");
            }
            
            const avgDaysLeft = Math.floor(totalDaysLeft / validServerCount);
            listText += `â”‚\nâ”œâ”€ *Statistik*\nâ”‚  â”œâ”€ âœ… Aktif di Server: ${validServerCount}\nâ”‚  â””â”€ â³ Rata-rata: ${avgDaysLeft} hari\n`;
            listText += "â•°â”€â¬£";

            return Reply(listText);
        }

        const res = await fetch(`${domain}/api/application/servers`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apikey}`,
                'Accept': 'application/json'
            },
            timeout: 15000
        });

        if (!res.ok) {
            return Reply(`âŒ Gagal mengambil data dari server (${res.status}).`);
        }

        const data = await res.json();
        if (!data.data || data.data.length === 0) {
            return Reply("âš ï¸ Tidak ada server yang aktif di panel.");
        }

        const allPanels = loadPanelDB();
        let listText = "â•­â”€â¬£ã€Œ *DAFTAR SERVER AKTIF* ã€â¬£\nâ”‚\n";
        let serverCount = 0;
        let activeInDB = 0;
        let expiredInDB = 0;
        
        for (const server of data.data) {
            const serverId = server.attributes.id;
            const serverName = server.attributes.name;
            const serverUser = server.attributes.user;
            
            const panelInfo = allPanels.find(p => p.serverId === serverId);
            const daysLeft = panelInfo ? Math.ceil((panelInfo.expiresAt - Date.now()) / (1000 * 60 * 60 * 24)) : 0;
            const status = panelInfo ? (daysLeft > 0 ? 'ðŸŸ¢' : 'ðŸ”´') : 'âšª';
            
            listText += `â”œâ”€ ${++serverCount}. ${serverName}\n`;
            listText += `â”‚  â”œâ”€ ðŸ†” ID: ${serverId}\n`;
            listText += `â”‚  â”œâ”€ ðŸ‘¤ User: ${serverUser}\n`;
            if (panelInfo) {
                listText += `â”‚  â”œâ”€ ðŸ“… Expiry: ${new Date(panelInfo.expiresAt).toLocaleDateString('id-ID')}\n`;
                listText += `â”‚  â””â”€ ðŸ”‹ Status: ${status} (${daysLeft}d)\n`;
                
                if (daysLeft > 0) activeInDB++;
                else expiredInDB++;
            } else {
                listText += `â”‚  â””â”€ âš ï¸ Tidak ada di database\n`;
            }
        }
        
        const notInServer = allPanels.filter(panel => 
            !data.data.some(server => server.attributes.id === panel.serverId)
        ).length;
        
        listText += `â”‚\nâ”œâ”€ *Statistik*\n`;
        listText += `â”‚  â”œâ”€ ðŸ–¥ï¸ Server Aktif: ${serverCount}\n`;
        listText += `â”‚  â”œâ”€ âœ… Aktif di DB: ${activeInDB}\n`;
        listText += `â”‚  â””â”€ ðŸ—‘ï¸ Tidak di Server: ${notInServer}\n`;
        listText += "â•°â”€â¬£";

        Reply(listText);

    } catch (e) {
        console.error('ListPanel Error:', e);
        Reply("âŒ Gagal mengambil data dari server panel.");
    }
}
break;

case 'renewserver':
case 'renew': {
    if (!isCreator && !isReseller(m.sender))
        return Reply("â›” AKSES DITOLAK!\n\nFitur ini hanya untuk Reseller atau Owner.");

    try {
        const fetch = require("node-fetch");

        if (!text) {
            const res = await fetch(`${domain}/api/application/servers`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${apikey}`,
                    'Accept': 'application/json'
                },
                timeout: 15000
            });

            if (!res.ok) {
                return Reply("âŒ Gagal mengambil data server.");
            }

            const data = await res.json();
            const allPanels = loadPanelDB();
            
            const myServers = data.data.filter(server => {
                if (isCreator) return true;
                const panel = allPanels.find(p => p.serverId === server.attributes.id);
                return panel && panel.reseller === m.sender;
            });

            if (myServers.length === 0) {
                return Reply("âŒ Tidak ada server yang bisa di-renew.");
            }

            let message = `ðŸ”„ *DAFTAR SERVER YANG BISA DI-RENEW*\n\n`;
            let serverCount = 0;

            for (const server of myServers) {
                const serverId = server.attributes.id;
                const serverName = server.attributes.name;
                const panel = allPanels.find(p => p.serverId === serverId);
                const daysLeft = panel ? Math.ceil((panel.expiresAt - Date.now()) / (1000 * 60 * 60 * 24)) : 0;
                const status = panel ? (daysLeft > 0 ? `ðŸŸ¢ (${daysLeft}d)` : `ðŸ”´ (EXPIRED)`) : `âšª (Belum ada expiry)`;

                message += `*${++serverCount}. ${serverName}*\n`;
                message += `   ðŸ†” Server ID: ${serverId}\n`;
                message += `   â° Status: ${status}\n`;
                message += `   ðŸ”„ Renew: *${prefix}renew ${serverId}*\n\n`;
            }

            message += `_Gunakan command di atas untuk renew server._`;

            return Reply(message);
        }

        const serverId = Number(text.trim());
        
        const verifyRes = await fetch(`${domain}/api/application/servers/${serverId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apikey}`,
                'Accept': 'application/json'
            },
            timeout: 10000
        });

        if (!verifyRes.ok) {
            if (verifyRes.status === 404) {
                const db = loadPanelDB();
                const newDB = db.filter(p => p.serverId !== serverId);
                savePanelDB(newDB);
                return Reply(`âŒ Server ID *${serverId}* tidak ditemukan di panel. Entri database dibersihkan.`);
            }
            return Reply(`âŒ Gagal memverifikasi server: ${verifyRes.status}`);
        }

        const serverData = await verifyRes.json();
        const server = serverData.attributes;

        const db = loadPanelDB();
        const panel = db.find(p => p.serverId === serverId);

        if (!isCreator && (!panel || panel.reseller !== m.sender)) {
            return Reply(`âŒ Server *${server.name}* bukan milik Anda.`);
        }

        const days = 30;
        const now = Date.now();
        
        let newExpiry;
        if (panel && panel.expiresAt > now) {
            newExpiry = panel.expiresAt + (days * 24 * 60 * 60 * 1000);
        } else {
            newExpiry = now + (days * 24 * 60 * 60 * 1000);
        }

        const updatedPanel = panel || {
            serverId: serverId,
            username: server.user.toString(),
            serverName: server.name,
            reseller: m.sender,
            suspended: false,
            notified: false
        };
        
        updatedPanel.expiresAt = newExpiry;
        updatedPanel.lastRenewed = now;
        updatedPanel.suspended = false;

        const panelIndex = db.findIndex(p => p.serverId === serverId);
        if (panelIndex >= 0) {
            db[panelIndex] = updatedPanel;
        } else {
            db.push(updatedPanel);
        }
        
        savePanelDB(db);

        const expiredDate = panel ? new Date(panel.expiresAt) : new Date(now);
        const newDate = new Date(newExpiry);
        const daysAdded = Math.ceil((newExpiry - Math.max(panel ? panel.expiresAt : now, now)) / (1000 * 60 * 60 * 24));
        
        const successText = `âœ… *RENEW SERVER BERHASIL!*

ðŸ·ï¸ *Nama:* ${server.name}
ðŸ†” *Server ID:* ${serverId}
ðŸ‘¤ *User:* ${server.user}
ðŸ’¾ *RAM:* ${server.limits?.memory || 'N/A'} MB
âž• *Ditambah:* ${days} hari
ðŸ“… *Expiry Lama:* ${expiredDate.toLocaleDateString('id-ID')}
ðŸ“… *Expiry Baru:* ${newDate.toLocaleDateString('id-ID')}
â° *Total Waktu:* ${daysAdded} hari dari sekarang

âœ… Server berhasil diperpanjang!`;

        Reply(successText);

    } catch (error) {
        console.error('Renew Error:', error);
        if (error.code === 'ECONNREFUSED') {
            Reply('âŒ Koneksi ke panel ditolak. Pastikan panel aktif.');
        } else if (error.name === 'TimeoutError') {
            Reply('âŒ Timeout menghubungi panel. Coba lagi.');
        } else {
            Reply(`âŒ Terjadi kesalahan: ${error.message}`);
        }
    }
}
break;
case 'fakektp': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, isPrem(m.sender), isCreator)) return Reply(global.mess.limit);

    let contoh = `*Format Penggunaan (Reply/Kirim Foto):*
${prefix + command} Nama|Nik|Provinsi|Kota|TTL|Kelamin|Darah|Alamat|RtRw|Desa|Kecamatan|Agama|Status|Pekerjaan|Warga|Berlaku|Dibuat

*Contoh:*
${prefix + command} Alip|12345678|Jawa Timur|Surabaya|Jakarta, 01-01-2000|Laki-laki|O|Jl. Mawar|001/002|Mekarsari|Tegalsari|Islam|Belum Kawin|Pelajar|WNI|Seumur Hidup|Surabaya, 20-01-2024`;

    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';
    if (!/image/.test(mime)) return Reply("Mana fotonya? Kirim atau reply foto untuk pas foto KTP!");
    if (!text) return Reply(contoh);

    let split = text.split("|");
    if (split.length < 17) return Reply(contoh);

    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

    try {
        let media = await q.download();
        let photoUrl = await uploadPixhost(media, `${m.sender}.jpg`);
        if (!photoUrl) return Reply("âŒ Gagal mengupload foto ke Pixhost.");

        addLimit(m.sender, isPrem(m.sender), isCreator);

        let [nama, nik, prov, kota, ttl, jk, darah, alamat, rtrw, desa, kec, agama, status, kerja, warga, berlaku, buat] = split;

        let api_url = `https://fgsi.dpdns.org/api/maker/ktp?apikey=fgsiapi-2ef6382d-6d&nama=${encodeURIComponent(nama)}&provinsi=${encodeURIComponent(prov)}&kota=${encodeURIComponent(kota)}&nik=${encodeURIComponent(nik)}&ttl=${encodeURIComponent(ttl)}&jenis_kelamin=${encodeURIComponent(jk)}&golongan_darah=${encodeURIComponent(darah)}&alamat=${encodeURIComponent(alamat)}&rtRw=${encodeURIComponent(rtrw)}&kel_desa=${encodeURIComponent(desa)}&kecamatan=${encodeURIComponent(kec)}&agama=${encodeURIComponent(agama)}&status=${encodeURIComponent(status)}&pekerjaan=${encodeURIComponent(kerja)}&kewarganegaraan=${encodeURIComponent(warga)}&masa_berlaku=${encodeURIComponent(berlaku)}&terbuat=${encodeURIComponent(buat)}&pas_photo=${encodeURIComponent(photoUrl)}`;

        await alip.sendMessage(m.chat, { 
            image: { url: api_url }, 
            caption: `âœ… *FAKE KTP SUCCESS*\n\nðŸ‘¤ *Nama:* ${nama}\nðŸ†” *NIK:* ${nik}\nðŸ“ *Wilayah:* ${kota}, ${prov}` 
        }, { quoted: m });

        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan saat memproses data.");
    }
}
break;

case 'removewm':
case 'hapuswm': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    const q = m.quoted ? m.quoted : m;
    let mime = q?.msg?.mimetype || q?.mimetype || "";

    if (!/^image\//.test(mime)) {
        return Reply("âš ï¸ Reply ke gambar yang memiliki watermark!");
    }

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Menghapus watermark dari gambar...');

        const imageBuffer = await q.download();
        if (!imageBuffer) throw new Error("Gagal mengunduh gambar.");

        async function uploadPixhost(buffer, filename = "file.jpg") {
            const service = new ImageUploadService('pixhost.to');
            const upload = await service.uploadFromBinary(buffer, filename);
            return upload.directLink;
        }

        const imageUrl = await uploadPixhost(imageBuffer);
        const encodedUrl = encodeURIComponent(imageUrl);

        const apiUrl = `https://api.zenzxz.my.id/api/tools/removewm?imageUrl=${encodedUrl}`;
        
        const response = await axios.get(apiUrl, { 
            responseType: 'arraybuffer',
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });

        if (response.status === 200 && response.data) {
            const resultBuffer = Buffer.from(response.data);
            
            await m.reply({ 
                image: resultBuffer, 
                caption: `âœ… *WATERMARK REMOVED*\n\nWatermark berhasil dihapus dari gambar!` 
            });
        } else {
            throw new Error('Gagal menghapus watermark');
        }

    } catch (error) {
        console.error('Remove Watermark Error:', error);
        await m.reply('âŒ Gagal menghapus watermark. Coba lagi nanti.');
    }
    break;
}

case 'carbon':
case 'carbonify': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    if (!text) return Reply(`Contoh: ${prefix + command} Hello World`);
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        m.reply('ðŸ”„ Membuat carbon code...');
        const apiUrl = `https://api.zenzxz.my.id/api/maker/carbonify?input=${encodeURIComponent(text)}&title=Code`;
        await alip.sendMessage(m.chat, {
            image: { url: apiUrl },
            caption: `ðŸ“„ *CARBON CODE*\n\n${text}`
        }, { quoted: m });
    } catch (error) {
        Reply('âŒ Gagal membuat carbon code.');
    }
    break;
}

case 'soundcloud': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    if (!text) return Reply(`Contoh: ${prefix + command} losing us`);
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        m.reply('ðŸŽµ Mencari lagu di SoundCloud...');
        const apiUrl = `https://api-faa.my.id/faa/soundcloud-play?query=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status && response.result) {
            const data = response.result;
            const duration = Math.floor(data.duration / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            
            const teks = `
ðŸŽ§ *SOUNDCLOUD TRACK*

ðŸŽµ *Judul:* ${data.title}
ðŸ‘¤ *Artist:* ${data.user}
â±ï¸ *Durasi:* ${minutes}:${seconds.toString().padStart(2, '0')}
ðŸ”— *Source:* ${data.source_url}
            `.trim();

            await alip.sendMessage(m.chat, {
                audio: { url: data.download_url },
                mimetype: 'audio/mpeg',
                fileName: `${data.title}.mp3`,
                contextInfo: {
                    externalAdReply: {
                        title: data.title,
                        body: `by ${data.user}`,
                        thumbnailUrl: data.thumbnail,
                        sourceUrl: data.source_url,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            }, { quoted: m });

            await alip.sendMessage(m.chat, { text: teks }, { quoted: m });
        } else {
            throw new Error('Lagu tidak ditemukan');
        }

    } catch (error) {
        Reply('âŒ Gagal mencari lagu di SoundCloud. Coba dengan query yang berbeda.');
    }
    break;
}

case 'npmjs': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    if (!text) return Reply(`Contoh: ${prefix + command} alipclutcH`);
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    try {
        m.reply('ðŸ” Mencari package npm...');
        const apiUrl = `https://api-faa.my.id/faa/npmjs?name=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status && response.result && response.result.length > 0) {
            const pkg = response.result[0];
            const teks = `
ðŸ“¦ *NPM PACKAGE INFO*

ðŸ·ï¸ *Nama:* ${pkg.name}
ðŸ”– *Versi:* ${pkg.version}
ðŸ”— *Link:* ${pkg.link}
ðŸ“ *Deskripsi:* ${pkg.description}
ðŸ‘¤ *Creator API:* ${response.creator}
            `.trim();

            await alip.sendMessage(m.chat, {
                text: teks,
                contextInfo: {
                    externalAdReply: {
                        title: pkg.name,
                        body: pkg.description,
                        thumbnailUrl: global.image.menu,
                        sourceUrl: pkg.link,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            }, { quoted: m });
        } else {
            throw new Error('Package tidak ditemukan');
        }

    } catch (error) {
        Reply('âŒ Gagal mencari package npm. Pastikan nama package benar.');
    }
    break;
}

case 'antidelete': {
    if (!m.isGroup) return Reply(mess.group);
    if (!isCreator && !m.isAdmin) return Reply(mess.admin);
    
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    
    const action = args[0]?.toLowerCase();
    
    if (action === 'on') {
        global.db.groups[m.chat].antidelete = true;
        if (!global.db.groups[m.chat].antideleteMessages) {
            global.db.groups[m.chat].antideleteMessages = {};
        }
        Reply(`âœ… *Antidelete diaktifkan*\n\nBot akan menyimpan dan mengembalikan pesan yang dihapus oleh anggota grup.`);
    } else if (action === 'off') {
        global.db.groups[m.chat].antidelete = false;
        if (global.db.groups[m.chat].antideleteMessages) {
            global.db.groups[m.chat].antideleteMessages = {};
        }
        Reply(`âŒ *Antidelete dimatikan*\n\nPesan yang dihapus tidak akan disimpan lagi.`);
    } else {
        const status = global.db.groups[m.chat].antidelete ? 'Aktif' : 'Mati';
        Reply(`ðŸ”§ *SETTING ANTIDELETE*\n\nStatus: ${status}\n\nGunakan:\nâ€¢ ${prefix}antidelete on - untuk mengaktifkan\nâ€¢ ${prefix}antidelete off - untuk mematikan`);
    }
    break;
}
case 'airealtime': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    if (!text) return Reply(`Contoh: ${prefix + command} jam berapa hari ini`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('Memproses pertanyaan...');

        const apiUrl = `https://api-faa.my.id/faa/ai-realtime?text=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status && response.result) {
            await Reply(response.result);
        } else {
            throw new Error('Gagal mendapatkan respons AI');
        }

    } catch (error) {
        console.error('AI Error:', error);
        Reply('Gagal memproses pertanyaan. Coba lagi nanti.');
    }
    break;
}

case 'whatmusic':
case 'whatmusik': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    const q = m.quoted ? m.quoted : m;
    let mime = q?.msg?.mimetype || q?.mimetype || "";

    if (!/^(audio|video)\//.test(mime)) {
        return Reply("Khusus file audio atau video!");
    }

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('Mengidentifikasi musik...');
        const mediaBuffer = await q.download();

        const uploadUrl = await uploadCatbox(mediaBuffer, mime, () => 'media.mp3');
        if (!uploadUrl) throw new Error('Gagal upload media');

        const apiUrl = `https://api-faa.my.id/faa/whatmusic?url=${encodeURIComponent(uploadUrl)}`;
        const response = await fetchJson(apiUrl);

        if (response.status && response.result) {
            const data = response.result;

            const teks = `
Judul: ${data.title}
Artis: ${data.artist}
Durasi: ${data.duration}
Views: ${data.views.toLocaleString()}
Upload: ${data.uploadedAt}
Channel: ${data.channel}
            `.trim();

            await alip.sendMessage(m.chat, {
                image: { url: data.thumbnail },
                caption: teks,
                buttons: [
                    {
                        buttonId: `.play ${data.title} ${data.artist}`,
                        buttonText: { displayText: 'Cari Musik/Video' },
                        type: 1
                    }
                ],
                headerType: 1
            }, { quoted: m });

        } else {
            throw new Error('Musik tidak teridentifikasi');
        }

    } catch (error) {
        console.error('WhatMusic Error:', error);
        Reply('Gagal mengidentifikasi musik. Coba lagi nanti.');
    }
    break;
}

case 'lirik':
case 'lyric': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    if (!text) return Reply(`Contoh: ${prefix + command} rumah ke rumah`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('Mencari lirik lagu...');

        const apiUrl = `https://api-faa.my.id/faa/lyrics?q=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status && response.result) {
            const data = response.result;
            
            let lirikText = data.lyrics;
            if (lirikText.length > 3000) {
                lirikText = lirikText.substring(0, 3000) + '...';
            }

            const teks = `
Judul: ${data.title}
Artis: ${data.artist}
Album: ${data.album}
Genre: ${data.genre}

${lirikText}
            `.trim();

            await alip.sendMessage(m.chat, {
                image: { url: data.cover.large },
                caption: teks,
                buttons: [
                    {
                        buttonId: `.play ${data.title} ${data.artist}`,
                        buttonText: { displayText: 'Cari musik' },
                        type: 1
                    }
                ],
                headerType: 1
            }, { quoted: m });

        } else {
            throw new Error('Lirik tidak ditemukan');
        }

    } catch (error) {
        console.error('Lyric Error:', error);
        Reply('Gagal mencari lirik lagu. Coba lagi nanti.');
    }
    break;
}

case 'tourlgh': {
    const githubToken = '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';
    const owner = 'alifalfarel25-commits';
    const branch = 'main';
    let repos = ['dat1','dat2','dat3','dat4'];
    
    async function ensureRepoExists(repo) {
        try {
            await axios.get(`https://api.github.com/repos/${owner}/${repo}`, {
                headers: { Authorization: `Bearer ${githubToken}` }
            });
        } catch (e) {
            if (e.response?.status === 404) {
                await axios.post(`https://api.github.com/user/repos`,
                    { name: repo, private: false },
                    { headers: { Authorization: `Bearer ${githubToken}` } }
                );
                if (!repos.includes(repo)) repos.push(repo);
            } else throw e;
        }
    }
    
    function generateRepoName() {
        return `dat-${crypto.randomBytes(3).toString('hex')}`;
    }
    
    function getExtension(mimeType) {
        const extensions = {
            'image/jpeg': 'jpg',
            'image/jpg': 'jpg',
            'image/png': 'png',
            'image/gif': 'gif',
            'image/webp': 'webp',
            'video/mp4': 'mp4',
            'video/3gpp': '3gp',
            'video/quicktime': 'mov',
            'audio/mpeg': 'mp3',
            'audio/ogg': 'ogg',
            'audio/aac': 'aac',
            'application/pdf': 'pdf',
            'application/zip': 'zip',
            'application/vnd.rar': 'rar',
            'text/plain': 'txt',
            'application/msword': 'doc'
        };
        return extensions[mimeType] || 'bin';
    }
    
    async function uploadFile(buffer, mimeType) {
        const ext = getExtension(mimeType);
        const code = crypto.randomBytes(3).toString('hex');
        const fileName = `alip-clutch-${Date.now()}.${ext}`;
        const filePathGitHub = `uploads/${fileName}`;
        const base64Content = buffer.toString('base64');
        
        let targetRepo = repos[Math.floor(Math.random()*repos.length)];
        
        try {
            await ensureRepoExists(targetRepo);
        } catch {
            targetRepo = generateRepoName();
            await ensureRepoExists(targetRepo);
        }
        
        const response = await axios.put(
            `https://api.github.com/repos/${owner}/${targetRepo}/contents/${filePathGitHub}`,
            { 
                message: `Upload file ${fileName}`, 
                content: base64Content, 
                branch: branch 
            },
            { 
                headers: { 
                    Authorization: `Bearer ${githubToken}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github+json'
                } 
            }
        );
        
        return `https://raw.githubusercontent.com/${owner}/${targetRepo}/${branch}/${filePathGitHub}`;
    }
    
    try {
        const q = m.quoted ? m.quoted : m;
        const mime = (q.msg || q).mimetype || '';
        
        if (!mime) return Reply('Mana filenya? Reply atau kirim file!');
        
        m.reply('Uploading to GitHub...');
        
        let buffer;
        let mimeType = mime;
        
        if (q.download) {
            buffer = await q.download();
        } else if (m.message?.imageMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'image');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
            mimeType = m.message.imageMessage.mimetype;
        } else if (m.message?.videoMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'video');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
            mimeType = m.message.videoMessage.mimetype;
        } else if (m.message?.audioMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'audio');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
            mimeType = m.message.audioMessage.mimetype;
        } else if (m.message?.documentMessage) {
            const mediaBuffer = await downloadContentFromMessage(m.message, 'document');
            let chunks = [];
            for await (const chunk of mediaBuffer) {
                chunks.push(chunk);
            }
            buffer = Buffer.concat(chunks);
            mimeType = m.message.documentMessage.mimetype;
        } else {
            return Reply('File tidak didukung!');
        }
        
        if (!buffer || buffer.length === 0) {
            return Reply('Gagal mendapatkan file!');
        }
        
        if (buffer.length > 25 * 1024 * 1024) {
            return Reply('File terlalu besar! Maksimal 25MB.');
        }
        
        let url = await uploadFile(buffer, mimeType);
        
        const fileSize = (buffer.length / 1024 / 1024).toFixed(2);
        const extension = getExtension(mimeType).toUpperCase();
        
        await alip.sendMessage(m.chat, {
            text: `âœ… *FILE UPLOADED TO GITHUB*\n\nðŸ“ *URL:* ${url}\nðŸ“¦ *Size:* ${fileSize} MB\nðŸ”¤ *Type:* ${extension}\n\n_Direct link tersedia untuk download_`,
            contextInfo: {
                externalAdReply: {
                    title: 'GitHub Upload Success',
                    body: `File ${extension} â€¢ ${fileSize}MB`,
                    thumbnailUrl: 'https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png',
                    sourceUrl: url,
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        }, { quoted: m });
        
    } catch(e) {
        console.error('GitHub Upload Error:', e.response?.data || e.message);
        
        if (e.response?.status === 401) {
            Reply('Token GitHub invalid! Periksa token Anda.');
        } else if (e.response?.status === 403) {
            Reply('Rate limit GitHub terlampaui! Coba lagi nanti.');
        } else if (e.response?.status === 404) {
            Reply('Repository tidak ditemukan! Buat repo dat1, dat2, dst di GitHub.');
        } else {
            Reply(`Gagal upload: ${e.message}`);
        }
    }
    
    break;
}

case 'tourl':
case 'touploader': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    const q = m.quoted ? m.quoted : m;
    let mime = q?.msg?.mimetype || q?.mimetype || "";

    if (!/^(image|video|audio|document)\//.test(mime)) {
        return Reply("âš ï¸ Khusus Image/Video/Audio/Document!");
    }
    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mengupload media...');
        const media = await q.download();
        
        const generateFilename = (mimeType) => {
            const extMap = {
                'image/jpeg': 'jpg',
                'image/jpg': 'jpg',
                'image/png': 'png',
                'image/gif': 'gif',
                'image/webp': 'webp',
                'video/mp4': 'mp4',
                'video/3gp': '3gp',
                'video/quicktime': 'mov',
                'audio/mpeg': 'mp3',
                'audio/mp4': 'm4a',
                'audio/ogg': 'ogg',
                'application/pdf': 'pdf',
                'application/zip': 'zip'
            };
            const ext = extMap[mimeType] || 'bin';
            return 'alip-' + Date.now() + '.' + ext;
        };

const uploadPromises = [
    uploadRyzumi(media, mime, generateFilename),
    uploadQu(media, mime, generateFilename),
    uploadTop4Top(media, mime, generateFilename),
    uploadCatbox(media, mime, generateFilename),
    uploadUguu(media, mime, generateFilename),
    uploadNauval(media, mime, generateFilename),
    uploadPixhost(media, generateFilename(mime)),
    uploadGitHub(media, mime, generateFilename),
    uploadElaina(media, mime, generateFilename) 
];

        const uploadResults = await Promise.allSettled(uploadPromises);
        
        let buttons = [];
        
        if (uploadResults[0].status === 'fulfilled' && uploadResults[0].value && uploadResults[0].value.url) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Ryzumi-Uploader","copy_code":"${uploadResults[0].value.url}"}`
            });
        }
        
        if (uploadResults[1].status === 'fulfilled' && uploadResults[1].value && uploadResults[1].value.url) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Qu-Uploader","copy_code":"${uploadResults[1].value.url}"}`
            });
        }
        
        if (uploadResults[2].status === 'fulfilled' && uploadResults[2].value && uploadResults[2].value.downloadUrl) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Top4Top-Uploader","copy_code":"${uploadResults[2].value.downloadUrl}"}`
            });
        }
        
        if (uploadResults[3].status === 'fulfilled' && uploadResults[3].value) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"CatBox-Uploader","copy_code":"${uploadResults[3].value}"}`
            });
        }
        
        if (uploadResults[4].status === 'fulfilled' && uploadResults[4].value) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Uguu-Uploader","copy_code":"${uploadResults[4].value}"}`
            });
        }
        
        if (uploadResults[5].status === 'fulfilled' && uploadResults[5].value) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Nauval-Uploader","copy_code":"${uploadResults[5].value}"}`
            });
        }
        
        if (uploadResults[6].status === 'fulfilled' && uploadResults[6].value) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"Pixhost-Uploader","copy_code":"${uploadResults[6].value}"}`
            });
        }
        
        if (uploadResults[7].status === 'fulfilled' && uploadResults[7].value) {
            buttons.push({
                name: "cta_copy",
                buttonParamsJson: `{"display_text":"GitHub-Uploader","copy_code":"${uploadResults[7].value}"}`
            });
        }
        
        if (uploadResults[8].status === 'fulfilled' && uploadResults[8].value) {
    buttons.push({
        name: "cta_copy",
        buttonParamsJson: `{"display_text":"Elaina-Uploader","copy_code":"${uploadResults[8].value}"}`
    });
}
        if (buttons.length === 0) {
            return Reply("âš ï¸ Semua uploader gagal!");
        }

        let headerImage;
        if (/^image\//.test(mime)) {
            headerImage = await prepareWAMessageMedia(
                { image: media },
                { upload: alip.waUploadToServer }
            );
        } else {
            headerImage = await prepareWAMessageMedia(
                { image: { url: global.image.menu } },
                { upload: alip.waUploadToServer }
            );
        }

        const msg = generateWAMessageFromContent(
            m.chat,
            {
                viewOnceMessage: {
                    message: {
                        messageContextInfo: {
                            deviceListMetadata: {},
                            deviceListMetadataVersion: 2,
                            stanzaId: m.key.id,
                            participant: m.sender
                        },
                        interactiveMessage: proto.Message.InteractiveMessage.create({
                            body: proto.Message.InteractiveMessage.Body.create({
                                text: `
â•”â”€â”€â˜‰ *UPLOADER RESULTS* 
â”‚âœŽ *Status* : âœ… Success
â”‚âœŽ *Total*  : ${buttons.length} Uploader
â•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜‰\n> Tekan tombol untuk menyalin`
                            }),
                            footer: proto.Message.InteractiveMessage.Footer.create({
                                text: ``
                            }),
                            header: proto.Message.InteractiveMessage.Header.create({
                                hasMediaAttachment: true,
                                ...headerImage
                            }),
                            nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                                buttons: buttons
                            }),
                            contextInfo: {
                                stanzaId: m.key.id,
                                participant: m.sender
                            }
                        })
                    }
                }
            },
            {}
        );

        await alip.relayMessage(m.chat, msg.message, { messageId: msg.key.id });

    } catch (e) {
        console.error('Tourl Error:', e);
        Reply("âŒ Error! Mungkin terlalu banyak request atau file terlalu besar.");
    }
    break;
}
case 'telanjang': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}telanjang*`);
    }
    m.reply("*Wet sabar anj, gua copot pakaian nya dlu!*");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ’¦", key: m.key } });

    const alippelergede = `buat foto ini jadi telanjang`;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }
    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(alippelergede)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "ðŸ˜¹", key: m.key } });
    }
}
break;

case 'douyin':
case 'dy': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    // Meminta input URL
    if (!text || !text.startsWith('http')) return Reply(`Contoh: ${prefix + command} https://www.douyin.com/`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mencari dan memproses video Douyin...');

        const apiUrl = `${global.velyn}/api/downloader/douyin?apikey=${global.apikeyvelyn}&url=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status === 200 && response.data && response.data.medias) {
            
            // Mencari media dengan kualitas tertinggi (MP4 HD)
            const hdMedia = response.data.medias.find(media => media.type.includes('HD')) || response.data.medias[0];
            
            if (!hdMedia || !hdMedia.url) {
                return m.reply('âŒ Gagal mendapatkan URL media video.');
            }

            const videoUrl = hdMedia.url;
            const captionText = `ðŸ“¥ *DOUYIN DOWNLOADER*\n\n*Judul:* ${response.data.title}\n*Durasi:* ${response.data.duration}\n*Kualitas:* ${hdMedia.type}`;
            
            // Mengirimkan video menggunakan URL
            // Catatan: Asumsi m.reply bisa menerima objek video dengan URL
            await m.reply({ 
                video: { url: videoUrl }, 
                mimetype: 'video/mp4',
                caption: captionText 
            });

        } else {
            throw new Error(response.message || 'Gagal mengunduh video Douyin. Pastikan URL valid.');
        }

    } catch (error) {
        console.error('Douyin Downloader Error:', error);
        await m.reply('âŒ Gagal memproses permintaan video. Coba lagi nanti.');
    }
    break;
}
case 'likee':
case 'lk': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    // Meminta input URL
    if (!text || !text.startsWith('http')) return Reply(`Contoh: ${prefix + command} https://play.google.com/store/apps/details?id=video.like&hl=en`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mencari dan memproses video Likee tanpa watermark...');

        const apiUrl = `${global.velyn}/api/downloader/likee?apikey=${global.apikeyvelyn}&url=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status === 200 && response.data && response.data.downloads) {
            
            // Mencari URL video tanpa watermark
            const mediaNoWatermark = response.data.downloads.find(dl => dl.quality === 'without_watermark');
            
            if (!mediaNoWatermark || !mediaNoWatermark.url) {
                // Jika video tanpa watermark tidak tersedia, coba ambil yang ada (meski ber-watermark)
                const fallbackMedia = response.data.downloads[0];
                if (!fallbackMedia || !fallbackMedia.url) {
                    return m.reply('âŒ Gagal mendapatkan URL media video.');
                }
            }

            const videoUrl = mediaNoWatermark ? mediaNoWatermark.url : fallbackMedia.url;
            const qualityText = mediaNoWatermark ? 'Tanpa Watermark' : 'Dengan Watermark (Fallback)';
            
            const captionText = `ðŸ“¥ *LIKEE DOWNLOADER*\n\n*Judul:* ${response.data.title}\n*Kualitas:* ${qualityText}`;
            
            // Mengirimkan video menggunakan URL
            await m.reply({ 
                video: { url: videoUrl }, 
                mimetype: 'video/mp4',
                caption: captionText 
            });

        } else {
            throw new Error(response.message || 'Gagal mengunduh video Likee. Pastikan URL valid.');
        }

    } catch (error) {
        console.error('Likee Downloader Error:', error);
        await m.reply('âŒ Gagal memproses permintaan video. Coba lagi nanti.');
    }
    break;
}
case 'snackvideo':
case 'sv': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    // Meminta input URL
    if (!text || !text.startsWith('http')) return Reply(`Contoh: ${prefix + command} https://www.snackvideo.com/`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mencari dan memproses video SnackVideo...');

        const apiUrl = `${global.velyn}/api/downloader/snackvideo?apikey=${global.apikeyvelyn}&url=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status === 200 && response.data && response.data.url) {
            
            const videoUrl = response.data.url;
            const captionText = `ðŸ“¥ *SNACKVIDEO DOWNLOADER*\n\n*URL Asli:* ${text}`;
            
            // Mengirimkan video menggunakan URL
            await m.reply({ 
                video: { url: videoUrl }, 
                mimetype: 'video/mp4',
                caption: captionText 
            });

        } else {
            throw new Error(response.message || 'Gagal mengunduh video SnackVideo. Pastikan URL valid.');
        }

    } catch (error) {
        console.error('SnackVideo Downloader Error:', error);
        await m.reply('âŒ Gagal memproses permintaan video. Coba lagi nanti.');
    }
    break;
}
case 'threads':
case 'thds': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    if (!text || !text.startsWith('http')) return Reply(`Contoh: ${prefix + command} https://www.threads.com/?hl=en`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mencari dan memproses media Threads...');

        const apiUrl = `${global.velyn}/api/downloader/threads?apikey=${global.apikeyvelyn}&url=${encodeURIComponent(text)}&type=video`;
        const response = await fetchJson(apiUrl);

        if (response.status === 200 && response.data && response.data.downloads && response.data.downloads.length > 0) {
            
            const mediaUrl = response.data.downloads[0];
            const mediaType = response.data.type || 'Media';
            
            const captionText = `ðŸ“¥ *THREADS DOWNLOADER*\n\n*Tipe Media:* ${mediaType}\n*URL Asli:* ${text}`;
            
            if (mediaType.toLowerCase().includes('video')) {
                await m.reply({ 
                    video: { url: mediaUrl }, 
                    mimetype: 'video/mp4',
                    caption: captionText 
                });
            } else if (mediaType.toLowerCase().includes('image') || mediaType.toLowerCase().includes('photo')) {
                 await m.reply({ 
                    image: { url: mediaUrl }, 
                    caption: captionText 
                });
            } else {
                 await m.reply(captionText + `\n\nLink Download: ${mediaUrl}`);
            }

        } else {
            throw new Error(response.message || 'Gagal mengunduh media Threads. Pastikan URL valid.');
        }

    } catch (error) {
        console.error('Threads Downloader Error:', error);
        await m.reply('âŒ Gagal memproses permintaan media. Coba lagi nanti.');
    }
    break;
}
case 'videy':
case 'vd': {
    if (!isRegistered(m.sender) && !isCreator) 
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    if (!text || !text.startsWith('http')) return Reply(`Contoh: ${prefix + command} https://videy.co/`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        m.reply('â³ Mencari dan memproses video Videy...');

        const apiUrl = `${global.velyn}/api/downloader/videy?apikey=${global.apikeyvelyn}&url=${encodeURIComponent(text)}`;
        const response = await fetchJson(apiUrl);

        if (response.status === 200 && response.data && response.data.url) {
            
            const videoUrl = response.data.url;
            const captionText = `ðŸ“¥ *VIDEY DOWNLOADER*\n\n*Provider:* ${response.data.provider || 'Videy'}\n*URL Asli:* ${text}`;
            
            await m.reply({ 
                video: { url: videoUrl }, 
                mimetype: 'video/mp4',
                caption: captionText 
            });

        } else {
            throw new Error(response.message || 'Gagal mengunduh video Videy. Pastikan URL valid.');
        }

    } catch (error) {
        console.error('Videy Downloader Error:', error);
        await m.reply('âŒ Gagal memproses permintaan video. Coba lagi nanti.');
    }
    break;
}

case "igstalk":
case "instagramstalk": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply('ðŸ“Œ Masukkan username Instagram\nContoh: .igstalk google');
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const username = text.trim();
        const apiUrl = `https://api.siputzx.my.id/api/stalk/instagram?username=${encodeURIComponent(username)}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 30000 });
        
        if (!data.status || !data.data) {
            return Reply('âŒ Username tidak ditemukan atau terjadi kesalahan');
        }
        
        const profile = data.data;
        
        let stalkText = `ðŸ“± *INSTAGRAM STALKER*\n\n`;
        stalkText += `ðŸ‘¤ *Username:* ${profile.username}\n`;
        stalkText += `ðŸ“› *Nama Lengkap:* ${profile.full_name || '-'}\n`;
        stalkText += `ðŸ“ *Bio:* ${profile.biography || '-'}\n`;
        stalkText += `ðŸ”— *Link Eksternal:* ${profile.external_url || '-'}\n`;
        stalkText += `ðŸ‘¥ *Followers:* ${profile.followers_count?.toLocaleString() || '0'}\n`;
        stalkText += `ðŸ“ˆ *Following:* ${profile.following_count?.toLocaleString() || '0'}\n`;
        stalkText += `ðŸ“· *Postingan:* ${profile.posts_count?.toLocaleString() || '0'}\n\n`;
        
        if (profile.bio_links && profile.bio_links.length > 0) {
            stalkText += `ðŸ”— *Link di Bio:*\n`;
            profile.bio_links.forEach((link, index) => {
                stalkText += `${index + 1}. ${link.url} ${link.title ? `(${link.title})` : ''}\n`;
            });
            stalkText += `\n`;
        }
        
        if (profile.posts && profile.posts.length > 0) {
            stalkText += `ðŸ“Š *Postingan Terbaru (${Math.min(profile.posts.length, 5)} dari ${profile.posts.length}):*\n`;
            profile.posts.slice(0, 5).forEach((post, index) => {
                const date = new Date(post.timestamp * 1000).toLocaleDateString('id-ID');
                stalkText += `\n${index + 1}. ${post.is_video ? 'ðŸŽ¬ Video' : 'ðŸ–¼ï¸ Foto'}\n`;
                if (post.caption && post.caption.length > 50) {
                    stalkText += `   ${post.caption.substring(0, 50)}...\n`;
                } else if (post.caption) {
                    stalkText += `   ${post.caption}\n`;
                }
                stalkText += `   â¤ï¸ ${post.like_count?.toLocaleString() || '0'} â€¢ ðŸ’¬ ${post.comment_count?.toLocaleString() || '0'}\n`;
                stalkText += `   ðŸ“… ${date}\n`;
            });
        }
        
        stalkText += `\nâ° *Data diambil:* ${new Date(data.timestamp).toLocaleString('id-ID')}`;
        
        let messageOptions = {
            text: stalkText
        };
        
        if (profile.profile_pic_url) {
            try {
                messageOptions.image = { url: profile.profile_pic_url };
                messageOptions.caption = stalkText;
            } catch (e) {
                console.error('Gagal load profile picture:', e);
            }
        }
        
        await alip.sendMessage(m.chat, messageOptions, { quoted: m });
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        
        if (error.response?.status === 404) {
            return Reply('âŒ Username Instagram tidak ditemukan');
        } else if (error.code === 'ECONNABORTED') {
            return Reply('â° Timeout, coba lagi nanti');
        } else {
            return Reply(`âŒ Error: ${error.message}`);
        }
    }
}
break;

case 'totalchat': 
case 'totalpesan': {
    if (!m.isGroup) return Reply(mess.group);
    
    if (!global.db.groups) global.db.groups = {};
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    if (!global.db.groups[m.chat].users) global.db.groups[m.chat].users = {};
    
    const groupUsersStats = global.db.groups[m.chat].users;
    
    try {
        const groupMetadata = await alip.groupMetadata(m.chat);
        const allMembers = groupMetadata.participants;
        
        const allUsersStats = [];
        for (const member of allMembers) {
            const memberJid = member.id;
            let trackedData = groupUsersStats[memberJid] || {};
            let normalizedJid = memberJid;
            if (memberJid.endsWith('@lid')) {
                if (member.jid) {
                    normalizedJid = member.jid;
                    trackedData = groupUsersStats[normalizedJid] || trackedData;
                } else {
                    const altJid = memberJid.replace('@lid', '@s.whatsapp.net');
                    trackedData = groupUsersStats[altJid] || trackedData;
                }
            }
            
            const messages = trackedData.messages || 0;
            const name = trackedData.name || member.name || member.notify || memberJid.split('@')[0];
            const lastMessage = trackedData.lastMessage || 0;
            
            allUsersStats.push({
                jid: memberJid,
                name: name,
                messages: messages,
                lastMessage: lastMessage,
                isAdmin: member.admin !== null
            });
        }
        const sortedStats = allUsersStats
            .sort((a, b) => b.messages - a.messages)
            .sort((a, b) => {
                if (a.isAdmin && !b.isAdmin) return -1;
                if (!a.isAdmin && b.isAdmin) return 1;
                return 0;
            });
        
        if (sortedStats.length === 0) {
            return Reply('âŒ Tidak ada data member di grup ini.');
        }
        
        let message = `ðŸ“Š *STATISTIK PESAN GRUP*\n`;
        message += `ðŸ‘¥ Total Member: ${sortedStats.length} orang\n\n`;
        
        let mentions = [];
        let totalPesan = 0;
        let activeUsers = 0;
        sortedStats.forEach((user, index) => {
            const rank = index + 1;
            const isActive = user.messages > 0;
            
            if (isActive) activeUsers++;
            totalPesan += user.messages;
            let medal = '';
            if (rank === 1) medal = 'ðŸ¥‡';
            else if (rank === 2) medal = 'ðŸ¥ˆ';
            else if (rank === 3) medal = 'ðŸ¥‰';
            else medal = `${rank}.`;
            const adminBadge = user.isAdmin ? 'ðŸ‘‘ ' : '';
            const activeBadge = isActive ? 'ðŸ’¬ ' : 'ðŸ¤ ';
            
            mentions.push(user.jid);
            message += `${medal} ${adminBadge}${activeBadge}@${user.jid.split('@')[0]}\n`;
            message += `   ðŸ“Š ${user.messages.toLocaleString()} pesan\n`;
            if (user.lastMessage > 0) {
                const lastMsgTime = new Date(user.lastMessage);
                const now = new Date();
                const diffHours = Math.floor((now - lastMsgTime) / (1000 * 60 * 60));
                
                if (diffHours < 24) {
                    message += `   â° Terakhir: ${diffHours} jam yang lalu\n`;
                }
            }
            
            message += '\n';
        });
        
        const rataRata = activeUsers > 0 ? Math.floor(totalPesan / activeUsers) : 0;
        
        message += `ðŸ“ˆ *RINGKASAN:*\n`;
        message += `ðŸ’¬ Pengguna aktif: ${activeUsers}/${sortedStats.length}\n`;
        message += `ðŸ“¨ Total pesan: ${totalPesan.toLocaleString()}\n`;
        message += `ðŸ“Š Rata-rata: ${rataRata.toLocaleString()} pesan/orang aktif\n`;
        message += `ðŸ† Top 1: @${sortedStats[0]?.jid.split('@')[0]} (${sortedStats[0]?.messages.toLocaleString()} pesan)\n`;
        message += `\n_Data real-time â€¢ Update otomatis_`;
        
        Reply(message, mentions);
        
    } catch (error) {
        console.error('Error in totalchat:', error);
        const groupUsersStats = global.db.groups[m.chat].users;
        
        const leaderboard = Object.entries(groupUsersStats)
            .map(([jid, stats]) => {
                const messages = stats.messages || 0;
                const name = stats.name || jid.split('@')[0];
                return { jid, name, messages };
            })
            .filter(user => user.messages > 0)
            .sort((a, b) => b.messages - a.messages);
        
        if (leaderboard.length === 0) {
            return Reply('âŒ Belum ada data chat yang tercatat di grup ini.');
        }
        
        let message = `ðŸ† *TOP PENGANGGURAN GRUP*\n\n`;
        let mentions = [];
        
        leaderboard.slice(0, 15).forEach((user, index) => {
            const rank = index + 1;
            const medal = index === 0 ? 'ðŸ¥‡' : index === 1 ? 'ðŸ¥ˆ' : index === 2 ? 'ðŸ¥‰' : `${rank}.`;
            
            mentions.push(user.jid);
            message += `${medal} @${user.jid.split('@')[0]}\n`;
            message += `   ðŸ“Š ${user.messages.toLocaleString()} pesan\n\n`;
        });
        
        Reply(message, mentions);
    }

} break;

case 'resettotalchat': {
    if (!m.isGroup) return Reply(mess.group);
    if (!isCreator && !isAdmin) 
        return Reply('âŒ Hanya admin dan owner bot yang bisa reset statistik chat.');
    if (!global.db.groups) global.db.groups = {};
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    if (!global.db.groups[m.chat].users) global.db.groups[m.chat].users = {};
    
    const groupUsersStats = global.db.groups[m.chat].users;
    const totalMembers = Object.keys(groupUsersStats).length;
    
    if (totalMembers === 0) {
        return Reply('âŒ Tidak ada data statistik yang perlu di-reset.');
    }
    let totalMessages = 0;
    let activeMembers = 0;
    
    for (const jid in groupUsersStats) {
        const messages = groupUsersStats[jid].messages || 0;
        if (messages > 0) {
            activeMembers++;
            totalMessages += messages;
        }
    }
    global.db.groups[m.chat].users = {};
    await alip.sendMessage(m.chat, { 
        react: { text: "âœ…", key: m.key } 
    });
    Reply(`âœ… *STATISTIK PESAN DI-RESET*\n\nðŸ“Š Data yang dihapus:\nðŸ‘¥ Member aktif: ${activeMembers} orang\nðŸ’¬ Total pesan: ${totalMessages.toLocaleString()}\n\nStatistik akan dimulai dari 0 lagi.`);
    
} break;

case 'setultah': {
    if (!m.isGroup) return Reply(mess.group);
    
    let text = q.trim();
    const prefix = m.prefix || ''; 
    if (!text) return Reply(`Format salah. Gunakan: ${prefix}setultah DD/MM\nContoh: ${prefix}setultah 25/12`);

    const dateRegex = /^(\d{1,2})[\/\-](\d{1,2})$/;
    const match = text.match(dateRegex);

    if (!match) return Reply(`Format tanggal salah. Harap gunakan format DD/MM (contoh: 01/05)`);

    const day = parseInt(match[1]);
    const month = parseInt(match[2]);

    if (day < 1 || day > 31 || month < 1 || month > 12) {
        return Reply('Tanggal atau bulan yang kamu masukkan tidak valid.');
    }
    if (month === 2 && day > 29) return Reply('Bulan Februari tidak mungkin memiliki tanggal lebih dari 29.');
    if ([4, 6, 9, 11].includes(month) && day > 30) return Reply('Bulan ini tidak mungkin memiliki tanggal lebih dari 30.');

    if (!global.ultahdb[m.chat]) global.ultahdb[m.chat] = {};

    const formattedDate = `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}`;
    global.ultahdb[m.chat][m.sender] = formattedDate;
    
    saveUltahDb();

    Reply(`ðŸŽ‰ Berhasil! Tanggal ulang tahunmu (${formattedDate}) telah disimpan.`);
} break

case 'cekultah': case 'ultah': {
    if (!m.isGroup) return Reply(mess.group);
    
    const targetJid = m.mentionedJid[0] || m.sender;
    const isSelf = targetJid === m.sender;
    const name = isSelf ? 'Kamu' : `@${targetJid.split('@')[0]}`;
    
    if (!global.ultahdb[m.chat] || !global.ultahdb[m.chat][targetJid]) {
        const prefix = m.prefix || ''; 
        return Reply(`âŒ Ulang tahun ${name} belum terdaftar di grup ini.\n${isSelf ? `Daftarkan dengan: ${prefix}setultah DD/MM` : ''}`, [targetJid]);
    }

    const ultahDate = global.ultahdb[m.chat][targetJid];
    const daysRemaining = getDaysUntil(ultahDate);
    
    let message = `ðŸŽ‚ *INFO ULANG TAHUN*\n\n`;
    
    if (daysRemaining === 0) {
        message += getBirthdayQuote(name);
    } else {
        message += `ðŸ‘¤ Nama: ${name}\n`;
        message += `ðŸ“… Tanggal Lahir: ${ultahDate}\n\n`;
        message += `â³ ${name} akan berulang tahun dalam *${daysRemaining} hari* lagi.`;
    }
    
    Reply(message, [targetJid]);
} break

case 'listultah': {
    if (!m.isGroup) return Reply(mess.group);
    if (!global.ultahdb[m.chat] || Object.keys(global.ultahdb[m.chat]).length === 0) {
        return Reply('âŒ Belum ada pengguna yang mendaftarkan ulang tahun di grup ini.');
    }

    const ultahList = Object.entries(global.ultahdb[m.chat])
        .map(([jid, date]) => ({
            jid,
            date,
            days: getDaysUntil(date)
        }))
        .sort((a, b) => a.days - b.days);

    let message = `ðŸ“œ *DAFTAR ULANG TAHUN GRUP*\n\n`;
    let mentions = [];
    
    ultahList.forEach((data, index) => {
        const username = `@${data.jid.split('@')[0]}`;
        mentions.push(data.jid);
        
        let status;
        if (data.days === 0) {
            status = 'ðŸ¥³ HARI INI!';
        } else {
            status = `(${data.days} hari lagi)`;
        }
        
        message += `${index + 1}. ${username} - ${data.date} ${status}\n`;
    });
    
    Reply(message, mentions);
} break

case 'delultah': {
    if (!m.isGroup) return Reply(mess.group);
    
    if (!global.ultahdb[m.chat] || !global.ultahdb[m.chat][m.sender]) {
        return Reply(`âŒ Kamu belum mendaftarkan ulang tahun.\nTidak ada yang bisa dihapus.`);
    }

    const deletedDate = global.ultahdb[m.chat][m.sender];
    delete global.ultahdb[m.chat][m.sender];
    
    saveUltahDb();

    Reply(`ðŸ—‘ï¸ Berhasil menghapus data ulang tahunmu (${deletedDate}).`);
} break
case 'glitchtext':
case 'writetext':
case 'advancedglow':
case 'typographytext':
case 'pixelglitch':
case 'neonglitch':
case 'flagtext':
case 'flag3dtext':
case 'deletingtext':
case 'blackpinkstyle':
case 'glowingtext':
case 'underwatertext':
case 'logomaker':
case 'cartoonstyle':
case 'papercutstyle':
case 'watercolortext':
case 'effectclouds':
case 'blackpinklogo':
case 'gradienttext':
case 'summerbeach':
case 'luxurygold':
case 'multicoloredneon':
case 'sandsummer':
case 'galaxywallpaper':
case '1917style':
case 'makingneon':
case 'royaltext':
case 'freecreate':
case 'galaxystyle':
case 'lighteffects': {
    if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
    if (!text) return Reply(`*Penggunaan salah!*\nGunakan seperti ini:\n${prefix + command} teks`)
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    async function ephoto(url, inputText) {
        const form = new (require("form-data"))()
        const getPage = await axios.get(url, {
            headers: {
                "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36"
            }
        })
        const $ = cheerio.load(getPage.data)

        const token = $("input[name=token]").val()
        const build_server = $("input[name=build_server]").val()
        const build_server_id = $("input[name=build_server_id]").val()

        form.append("text[]", inputText)
        form.append("token", token)
        form.append("build_server", build_server)
        form.append("build_server_id", build_server_id)

        const res = await axios.post(url, form, {
            headers: {
                Accept: "*/*",
                "Accept-Language": "en-US,en;q=0.9",
                "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36",
                cookie: getPage.headers["set-cookie"]?.join("; "),
                ...form.getHeaders()
            }
        })

        const $$ = cheerio.load(res.data)
        const json = JSON.parse($$("input[name=form_value_input]").val())
        json["text[]"] = json.text
        delete json.text

        const { data } = await axios.post("https://en.ephoto360.com/effect/create-image", new URLSearchParams(json), {
            headers: {
                "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36",
                cookie: getPage.headers["set-cookie"].join("; ")
            }
        })

        return build_server + data.image
    }

    await alip.sendMessage(m.chat, {
        react: { text: "â±ï¸", key: m.key }
    })

    const effectLinks = {
        glitchtext: 'https://en.ephoto360.com/create-digital-glitch-text-effects-online-767.html',
        writetext: 'https://en.ephoto360.com/write-text-on-wet-glass-online-589.html',
        advancedglow: 'https://en.ephoto360.com/advanced-glow-effects-74.html',
        typographytext: 'https://en.ephoto360.com/create-typography-text-effect-on-pavement-online-774.html',
        pixelglitch: 'https://en.ephoto360.com/create-pixel-glitch-text-effect-online-769.html',
        neonglitch: 'https://en.ephoto360.com/create-impressive-neon-glitch-text-effects-online-768.html',
        flagtext: 'https://en.ephoto360.com/nigeria-3d-flag-text-effect-online-free-753.html',
        flag3dtext: 'https://en.ephoto360.com/free-online-american-flag-3d-text-effect-generator-725.html',
        deletingtext: 'https://en.ephoto360.com/create-eraser-deleting-text-effect-online-717.html',
        blackpinkstyle: 'https://en.ephoto360.com/online-blackpink-style-logo-maker-effect-711.html',
        glowingtext: 'https://en.ephoto360.com/create-glowing-text-effects-online-706.html',
        underwatertext: 'https://en.ephoto360.com/3d-underwater-text-effect-online-682.html',
        logomaker: 'https://en.ephoto360.com/free-bear-logo-maker-online-673.html',
        cartoonstyle: 'https://en.ephoto360.com/create-a-cartoon-style-graffiti-text-effect-online-668.html',
        papercutstyle: 'https://en.ephoto360.com/multicolor-3d-paper-cut-style-text-effect-658.html',
        watercolortext: 'https://en.ephoto360.com/create-a-watercolor-text-effect-online-655.html',
        effectclouds: 'https://en.ephoto360.com/write-text-effect-clouds-in-the-alip-online-619.html',
        blackpinklogo: 'https://en.ephoto360.com/create-blackpink-logo-online-free-607.html',
        gradienttext: 'https://en.ephoto360.com/create-3d-gradient-text-effect-online-600.html',
        summerbeach: 'https://en.ephoto360.com/write-in-sand-summer-beach-online-free-595.html',
        luxurygold: 'https://en.ephoto360.com/create-a-luxury-gold-text-effect-online-594.html',
        multicoloredneon: 'https://en.ephoto360.com/create-multicolored-neon-light-signatures-591.html',
        sandsummer: 'https://en.ephoto360.com/write-in-sand-summer-beach-online-576.html',
        galaxywallpaper: 'https://en.ephoto360.com/create-galaxy-wallpaper-mobile-online-528.html',
        '1917style': 'https://en.ephoto360.com/1917-style-text-effect-523.html',
        makingneon: 'https://en.ephoto360.com/making-neon-light-text-effect-with-galaxy-style-521.html',
        royaltext: 'https://en.ephoto360.com/royal-text-effect-online-free-471.html',
        freecreate: 'https://en.ephoto360.com/free-create-a-3d-hologram-text-effect-441.html',
        galaxystyle: 'https://en.ephoto360.com/create-galaxy-style-free-name-logo-438.html',
        lighteffects: 'https://en.ephoto360.com/create-light-effects-green-neon-online-429.html'
    }

    try {
        const resultUrl = await ephoto(effectLinks[command], q)
        await alip.sendMessage(m.chat, {
            image: { url: resultUrl }
        }, { quoted: m })
    } catch {
        Reply('Sedang error kak, mohon maaf ðŸ™')
    }
}
break

// ================== [ STREAK FEATURE ] ==================
case 'buatstreak': {
    if (!m.isGroup) return Reply(global.mess.group);
    if (!m.mentionedJid || m.mentionedJid.length === 0) return Reply(`âŒ Tag pengguna yang ingin kamu ajak streak. Contoh: ${prefix + command} @tagusernya`);

    const targetIdRaw = m.mentionedJid[0];
    // Menggunakan helper untuk konversi LID ke JID
    const targetJid = getFinalJid(m, targetIdRaw);
    const senderJid = m.sender;

    if (areJidsSameUser(senderJid, targetJid)) {
        return Reply(`âŒ Kamu tidak bisa buat streak dengan diri sendiri!`);
    }

    let streaksDb = loadStreaks();
    if (!streaksDb[m.chat]) streaksDb[m.chat] = {};

    const streakKey = getStreakKey(senderJid, targetJid);

    // Cek apakah streak sudah berjalan
    if (streaksDb[m.chat][streakKey] && streaksDb[m.chat][streakKey].status === 'active') {
        const currentStreak = streaksDb[m.chat][streakKey].streak;
        return Reply(`âš ï¸ Streak antara @${senderJid.split('@')[0]} dan @${targetJid.split('@')[0]} sudah aktif dengan rekor *${currentStreak}* hari. Pertahankan!`, {mentions: [senderJid, targetJid]});
    }

    // Inisiasi streak baru atau reset yang sudah lama
    const [userA, userB] = getStreakKey(senderJid, targetJid).split(':');
    
    streaksDb[m.chat][streakKey] = {
        streak: 0,
        last_active_A: "0000-00-00", 
        last_active_B: "0000-00-00",
        user_A: userA, // JID yang diurutkan (pengguna 1)
        user_B: userB, // JID yang diurutkan (pengguna 2)
        status: 'active' // Langsung aktif, hitungan mulai dari 0.
    };
    saveStreaks(streaksDb);

    const teks = `ðŸ”¥ *STREAK BARU DIMULAI!* ðŸ”¥\n\n@${senderJid.split('@')[0]} telah mengajak @${targetJid.split('@')[0]} untuk memulai Daily Streak!\n\nðŸ”” *Cara Main:*\n*Kalian berdua* harus menggunakan command *.nyalainstreak* *SETIAP HARI* sebelum jam *00:00 WIB* (Waktu Jakarta). Jika salah satu telat, streak akan direset!\n\nRekor saat ini: *0* hari.`;
    
    await alip.sendMessage(m.chat, {
        text: teks,
        mentions: [senderJid, targetJid]
    }, { quoted: m });

} break;

case 'nyalainstreak': {
    if (!m.isGroup) return Reply(global.mess.group);
    
    const senderJid = m.sender;
    let streaksDb = loadStreaks();
    let groupStreaks = streaksDb[m.chat];

    if (!groupStreaks) return Reply(`âŒ Belum ada streak aktif di grup ini. Gunakan ${prefix}buatstreak @tagusernya untuk memulai.`);

    // Cari semua streak yang melibatkan pengirim
    const activeStreaks = Object.entries(groupStreaks).filter(([key, data]) => 
        data.status === 'active' && (data.user_A === senderJid || data.user_B === senderJid)
    );

    if (activeStreaks.length === 0) return Reply(`âŒ Kamu belum memiliki streak aktif di grup ini. Gunakan ${prefix}buatstreak @tagusernya untuk memulai.`);

    // Mengambil tanggal hari ini dan kemarin dalam WIB
    const today = moment().tz("Asia/Jakarta").format("YYYY-MM-DD");
    const yesterday = moment().tz("Asia/Jakarta").subtract(1, 'days').format("YYYY-MM-DD");

    let messages = [];

    for (const [key, data] of activeStreaks) {
        let partnerJid = (data.user_A === senderJid) ? data.user_B : data.user_A;
        let senderKey = (data.user_A === senderJid) ? 'last_active_A' : 'last_active_B';
        let partnerKey = (data.user_A === senderJid) ? 'last_active_B' : 'last_active_A';
        
        let msg = '';
        let status = '';

        // 1. Cek apakah sudah diaktifkan hari ini
        if (data[senderKey] === today) {
            msg = `ðŸŸ¢ Streak dengan @${partnerJid.split('@')[0]} sudah kamu aktifkan hari ini! Streak saat ini: *${data.streak}* hari.`;
        } else {
            // 2. Logika Reset (Streak terputus jika salah satu miss lebih dari 1 hari)
            const isSenderMissed = data[senderKey] !== "0000-00-00" && data[senderKey] !== yesterday;
            const isPartnerMissed = data[partnerKey] !== "0000-00-00" && data[partnerKey] !== today && data[partnerKey] !== yesterday;
            
            if (isSenderMissed || isPartnerMissed) {
                data.streak = 0; // Reset
                status = 'reset';
            }
            
            // 3. Update waktu aktif pengirim
            data[senderKey] = today;
            
            // 4. Logika Increment
            if (data[senderKey] === today && data[partnerKey] === today) {
                data.streak++;
                if (data.streak === 1) {
                     msg = `ðŸŽ‰ *STREAK DIMULAI!* Streak pertama dengan @${partnerJid.split('@')[0]} berhasil! Streak saat ini: *${data.streak}* hari. Pertahankan besok!`;
                } else {
                     msg = `âœ… *STREAK BERHASIL!* Streak harian ke *${data.streak}* dengan @${partnerJid.split('@')[0]} berhasil dipertahankan oleh kalian berdua hari ini!`;
                }
            } else if (status === 'reset') {
                 // Setelah direset, jika partner sudah aktif hari ini, streak jadi 1
                if (data[partnerKey] === today) {
                     data.streak = 1;
                     msg = `ðŸ”´ *STREAK GAGAL!* Streak dengan @${partnerJid.split('@')[0]} direset ke *0* hari. Karena kamu baru menyalakan hari ini, streak kembali menjadi *1* hari. Pertahankan!`;
                } else {
                    // Hanya pengirim yang aktif, partner belum aktif hari ini
                     data.streak = 0; // Tetap 0 sampai partner aktif
                     msg = `ðŸ”´ *STREAK GAGAL!* Streak dengan @${partnerJid.split('@')[0]} direset ke *0* hari. Sekarang giliran dia menggunakan *.nyalainstreak* hari ini agar streak dimulai kembali!`;
                }
            } else {
                // Hanya pengirim yang aktif, partner belum aktif hari ini
                msg = `ðŸŸ¡ Streak dengan @${partnerJid.split('@')[0]} aktif! Sekarang giliran dia untuk menggunakan *.nyalainstreak* hari ini agar streak bertambah. Streak saat ini: *${data.streak}* hari.`;
            }
            
        }
        
        groupStreaks[key] = data; // Update data di object
        messages.push(msg);
    }
    
    // Simpan perubahan dan kirim balasan
    saveStreaks(streaksDb);
    
    // Mengumpulkan semua JID yang dimention dari semua pesan
    const allMentions = messages.flatMap(msg => msg.match(/@(\d{0,16})/g) || []).map(tag => tag.slice(1) + '@s.whatsapp.net');
    
    await alip.sendMessage(m.chat, {
        text: messages.join('\n\n*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*\n\n'),
        mentions: [...new Set(allMentions)] // Hapus duplikat mention
    }, { quoted: m });

} break;

case 'cekstreak':
case 'streak': {
    if (!m.isGroup) return Reply(global.mess.group);

    const senderJid = m.sender;
    let targetJid;
    let cekUser = false;
    
    // Cek apakah ada mention
    if (m.mentionedJid && m.mentionedJid.length > 0) {
        const targetIdRaw = m.mentionedJid[0];
        targetJid = getFinalJid(m, targetIdRaw);
        cekUser = true;
    } else {
        // Jika tidak ada mention, cari streak yang melibatkan pengirim
        targetJid = m.sender; 
    }
    
    let streaksDb = loadStreaks();
    let groupStreaks = streaksDb[m.chat];

    if (!groupStreaks) return Reply(`âŒ Belum ada streak aktif di grup ini.`);

    let messages = [];
    const today = moment().tz("Asia/Jakarta").format("YYYY-MM-DD");
    
    // Logika pencarian streak
    let filteredStreaks = Object.entries(groupStreaks).filter(([key, data]) => {
        if (cekUser) {
            // Jika ada mention, cari streak antara sender dan target
            const requiredKey = getStreakKey(senderJid, targetJid);
            return data.status === 'active' && key === requiredKey;
        } else {
            // Jika tidak ada mention, cari semua streak yang melibatkan sender
            return data.status === 'active' && (data.user_A === senderJid || data.user_B === senderJid);
        }
    });

    if (filteredStreaks.length === 0) {
        if (cekUser) {
            return Reply(`âŒ Tidak ditemukan streak aktif antara @${senderJid.split('@')[0]} dan @${targetJid.split('@')[0]}.`);
        } else {
            return Reply(`âŒ Kamu belum memiliki streak aktif di grup ini.`);
        }
    }
    
    for (const [key, data] of filteredStreaks) {
        let partnerJid = (data.user_A === senderJid) ? data.user_B : data.user_A;
        let partnerJidCek = (data.user_A === targetJid) ? data.user_B : data.user_A; // Jika cek user
        let partnerName = partnerJidCek.split('@')[0];
        
        // Tentukan siapa partner sebenarnya berdasarkan skenario cek
        if (cekUser) {
             partnerJid = (data.user_A === senderJid) ? data.user_B : data.user_A;
             if (partnerJid !== targetJid) continue; // Pastikan hanya streak sender-target
             partnerName = targetJid.split('@')[0];
        } else {
             partnerJid = (data.user_A === senderJid) ? data.user_B : data.user_A;
             partnerName = partnerJid.split('@')[0];
        }
        
        let userA_Active = data.last_active_A === today;
        let userB_Active = data.last_active_B === today;

        let statusSender = (data.user_A === senderJid) ? userA_Active : userB_Active;
        let statusPartner = (data.user_A === partnerJid) ? userA_Active : userB_Active;

        let statusText;
        if (data.streak === 0) {
            statusText = `Belum dimulai.`;
        } else if (statusSender && statusPartner) {
            statusText = `âœ… Aman! Sudah diaktifkan oleh kalian berdua hari ini.`;
        } else if (statusSender) {
            statusText = `ðŸŸ¡ Giliran @${partnerName} untuk menyalakan streak hari ini.`;
        } else if (statusPartner) {
            statusText = `ðŸŸ¡ Giliran @${senderJid.split('@')[0]} untuk menyalakan streak hari ini.`;
        } else {
             statusText = `âŒ Belum diaktifkan oleh siapapun hari ini.`;
        }

        const msg = `ðŸ”¥ *DAILY STREAK CHECK* ðŸ”¥\n`
            + `ðŸ‘¤ *Partner:* @${partnerName}\n`
            + `ðŸ“ˆ *Rekor Streak:* *${data.streak}* hari\n`
            + `â° *Status Hari Ini:* ${statusText}\n`
            + `_Pertahankan sebelum jam 00:00 WIB!_`;

        messages.push(msg);
    }
    
    // Mengumpulkan semua JID yang dimention dari semua pesan
    const allMentions = messages.flatMap(msg => msg.match(/@(\d{0,16})/g) || []).map(tag => tag.slice(1) + '@s.whatsapp.net');
    
    await alip.sendMessage(m.chat, {
        text: messages.join('\n\n*====================*\n\n'),
        mentions: [...new Set(allMentions)] 
    }, { quoted: m });

} break;

case 'topstreak': {
    if (!m.isGroup) return Reply(global.mess.group);
    
    let streaksDb = loadStreaks();
    let groupStreaks = streaksDb[m.chat];

    if (!groupStreaks || Object.keys(groupStreaks).length === 0) return Reply(`âŒ Belum ada streak yang tercatat di grup ini.`);

    // 1. Filter hanya streak yang aktif dan streak > 0
    const activeStreaks = Object.values(groupStreaks).filter(data => 
        data.status === 'active' && data.streak > 0
    );
    
    if (activeStreaks.length === 0) return Reply(`âŒ Belum ada streak yang berhasil dipertahankan di grup ini.`);

    // 2. Urutkan berdasarkan rekor streak tertinggi
    activeStreaks.sort((a, b) => b.streak - a.streak);

    // 3. Ambil 5 teratas
    const topStreaks = activeStreaks.slice(0, 5);

    let topMessage = `ðŸ† *TOP 5 DAILY STREAK* ðŸ†\n_Grup: ${m.metadata.subject}_\n\n`;
    let mentions = [];

    topStreaks.forEach((data, index) => {
        const userA = data.user_A.split('@')[0];
        const userB = data.user_B.split('@')[0];
        
        topMessage += `*${index + 1}.* @${userA} & @${userB}\n`
            + `   > *Rekor:* *${data.streak}* hari\n`;
        
        mentions.push(data.user_A, data.user_B);
    });
    
    topMessage += '\n_Kalian luar biasa! Pertahankan terus!_';

    await alip.sendMessage(m.chat, {
        text: topMessage,
        mentions: [...new Set(mentions)]
    }, { quoted: m });

} break;

case 'onlyadmin': {

    if (!m.isGroup) return Reply(mess.group);
    if (!m.isAdmin && !isCreator) return Reply(mess.admin);
    let group = global.db.groups[m.chat];
    group.onlyAdminMode = !group.onlyAdminMode;
    let status = group.onlyAdminMode ? 'ON' : 'OFF';
    Reply(`âœ… Fitur *Only Admin Mode* berhasil diubah menjadi: *${status}*.\n\n_Sekarang bot ${status === 'ON' ? 'hanya akan merespon perintah dari Admin Grup dan Owner' : 'dapat digunakan oleh semua anggota grup'}._`);
}
break;

case 'warn': {
    if (!m.isGroup) return Reply('âŒ Hanya grup');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Admin only');
    if (!m.isBotAdmin) return Reply('âŒ Bot bukan admin');
    
    let target;
    if (m.mentionedJid?.length > 0) {
        target = m.mentionedJid[0];
        if (target.endsWith('@lid')) {
            const participant = m.metadata.participants.find(p => p.id === target);
            target = participant ? participant.jid : target.replace('@lid', '@s.whatsapp.net');
        }
    } else if (m.quoted) {
        target = m.quoted.sender;
    } else if (text) {
        const number = text.split(' ')[0].replace(/[^0-9]/g, '');
        if (number) target = number + '@s.whatsapp.net';
    }
    
    if (!target) return Reply('âŒ Tag/reply user');
    
    const isTargetAdmin = m.metadata.participants.some(p => p.id === target && p.admin);
    if (isTargetAdmin && !isCreator) return Reply('âŒ Tidak bisa warn admin');
    if (owners.includes(target)) return Reply('âŒ Tidak bisa warn owner');
    
    const warnDB = loadWarnDB();
    
    if (!warnDB[m.chat]) warnDB[m.chat] = {};
    if (!warnDB[m.chat][target]) {
        warnDB[m.chat][target] = {
            count: 0,
            warnings: [],
            name: m.metadata.participants.find(p => p.id === target)?.notify || target.split('@')[0]
        };
    }
    
    const userData = warnDB[m.chat][target];
    userData.count += 1;
    userData.warnings.push({
        timestamp: Date.now(),
        warnedBy: m.sender,
        warnedByName: m.pushName || m.sender.split('@')[0],
        reason: text.split(' ').slice(1).join(' ') || 'Tidak ada alasan'
    });
    
    saveWarnDB(warnDB);
    
    const maxWarn = 4;
    if (userData.count >= maxWarn) {
        await Reply(`âš ï¸ ${target.split('@')[0]} ${maxWarn} warn, dikeluarkan`, [target]);
        await alip.groupParticipantsUpdate(m.chat, [target], 'remove');
        delete warnDB[m.chat][target];
        saveWarnDB(warnDB);
    } else {
        await Reply(`âš ï¸ Warn ${userData.count}/${maxWarn} untuk ${target.split('@')[0]}`, [target]);
    }
}
break;

case 'delwarn': {
    if (!m.isGroup) return Reply('âŒ Hanya grup')
    if (!m.isAdmin && !isCreator) return Reply('âŒ Admin only')

    const warnDB = loadWarnDB()
    if (!warnDB[m.chat]) return Reply('âŒ Tidak ada warn di grup ini')

    if (text === 'all' || text === 'semua') {
        delete warnDB[m.chat]
        saveWarnDB(warnDB)
        return Reply('âœ… Semua warn dihapus')
    }

    let target = null

    if (m.mentionedJid?.length) {
        let id = m.mentionedJid[0]
        if (id.endsWith('@lid')) {
            let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
            target = p ? p.jid : null
        } else {
            target = id
        }
    } else if (m.quoted) {
        target = m.quoted.sender
    } else if (text) {
        const number = text.split(' ')[0].replace(/[^0-9]/g, '')
        if (number) target = number + '@s.whatsapp.net'
    }

    if (!target) return Reply('âŒ Tag/reply user atau .delwarn all')

    if (!warnDB[m.chat][target]) {
        return Reply(`âŒ ${target.split('@')[0]} tidak ada warn`, [target])
    }

    delete warnDB[m.chat][target]
    saveWarnDB(warnDB)
    Reply(`âœ… Warn untuk ${target.split('@')[0]} dihapus`, [target])
}
break

case 'listwarn': {
    if (!m.isGroup) return Reply('âŒ Hanya grup');
    
    const warnDB = loadWarnDB();
    if (!warnDB[m.chat] || Object.keys(warnDB[m.chat]).length === 0) {
        return Reply('âŒ Tidak ada warn di grup ini');
    }
    
    let message = 'ðŸ“‹ Daftar Warn\n';
    const users = Object.entries(warnDB[m.chat]);
    
    users.forEach(([jid, data], index) => {
        message += `${index + 1}. ${data.name}\n`;
        message += `   âš ï¸ ${data.count} warn\n`;
    });
    
    message += `\nTotal: ${users.length} user`;
    
    const mentions = users.map(([jid]) => jid);
    await Reply(message, mentions);
}
break;

case 'infowarn': {
    if (!m.isGroup) return Reply('âŒ Hanya grup');
    
    const warnDB = loadWarnDB();
    if (!warnDB[m.chat]) return Reply('âŒ Tidak ada warn di grup ini');
    
    let target = m.sender;
    if (m.mentionedJid?.length > 0) {
        target = m.mentionedJid[0];
        if (target.endsWith('@lid')) {
            target = target.replace('@lid', '@s.whatsapp.net');
        }
    } else if (m.quoted) {
        target = m.quoted.sender;
    } else if (text) {
        const number = text.split(' ')[0].replace(/[^0-9]/g, '');
        if (number) target = number + '@s.whatsapp.net';
    }
    
    if (!warnDB[m.chat][target]) {
        return Reply(`âŒ ${target.split('@')[0]} tidak ada warn`, [target]);
    }
    
    const data = warnDB[m.chat][target];
    let message = `ðŸ“Š ${data.name}\n`;
    message += `âš ï¸ ${data.count} warn\n\n`;
    
    if (data.warnings.length > 0) {
        message += `Riwayat:\n`;
        data.warnings.slice(-3).forEach((warn, index) => {
            const date = new Date(warn.timestamp).toLocaleDateString('id-ID');
            message += `${index + 1}. ${date}\n`;
            message += `   ${warn.reason}\n`;
        });
    }
    
    await Reply(message, [target]);
}
break;

case 'resetwarn': {
    if (!m.isGroup) return Reply('âŒ Hanya grup');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Admin only');
    
    const warnDB = loadWarnDB();
    if (!warnDB[m.chat]) return Reply('âŒ Tidak ada warn di grup ini');
    
    let target;
    if (m.mentionedJid?.length > 0) {
        target = m.mentionedJid[0];
        if (target.endsWith('@lid')) {
            target = target.replace('@lid', '@s.whatsapp.net');
        }
    } else if (m.quoted) {
        target = m.quoted.sender;
    } else if (text) {
        const number = text.split(' ')[0].replace(/[^0-9]/g, '');
        if (number) target = number + '@s.whatsapp.net';
    }
    
    if (target) {
        if (warnDB[m.chat][target]) {
            warnDB[m.chat][target].count = 0;
            warnDB[m.chat][target].warnings = [];
            saveWarnDB(warnDB);
            await Reply(`âœ… ${target.split('@')[0]} warn direset`, [target]);
        } else {
            await Reply(`âŒ ${target.split('@')[0]} tidak ada warn`, [target]);
        }
    } else {
        for (const jid in warnDB[m.chat]) {
            warnDB[m.chat][jid].count = 0;
            warnDB[m.chat][jid].warnings = [];
        }
        saveWarnDB(warnDB);
        Reply('âœ… Semua warn direset');
    }
}
break;

case 'tomp3':
case 'toaudio': {
    if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';

    if (!/video/.test(mime)) {
        return Reply(`âŒ Reply ke *video* yang ingin diubah menjadi mp3 dengan caption *.tomp3*`);
    }
    if ((q.msg?.seconds || 0) > 300) {
        return Reply("âŒ Video terlalu panjang! Durasi maksimal adalah 5 menit.");
    }
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Mengonversi video, mohon tunggu...');
    await alip.sendMessage(m.chat, { react: { text: "ðŸ”„", key: m.key } });
    const { exec } = require('child_process');
    let videoPath;
    let outputPath;
    try {
        videoPath = await alip.downloadAndSaveMediaMessage(q);
        const tempDir = path.join(__dirname, 'tmp');
        if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);
        outputPath = path.join(tempDir, `${Date.now()}.mp3`);
        await new Promise((resolve, reject) => {
            exec(`ffmpeg -i "${videoPath}" "${outputPath}"`, (err) => {
                if (err) {
                    console.error("FFmpeg Error:", err);
                    reject(new Error("Gagal mengonversi video. Pastikan FFmpeg terinstal."));
                } else {
                    resolve();
                }
            });
        });
        await alip.sendMessage(m.chat, {
            audio: { url: outputPath },
            mimetype: 'audio/mpeg'
        }, { quoted: m });

        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

    } catch (err) {
        console.error('Tomp3 Error:', err);
        Reply(`âŒ Terjadi kesalahan: ${err.message}`);
        await alip.sendMessage(m.chat, { react: { text: "âš ï¸", key: m.key } });
    } finally {
        if (videoPath && fs.existsSync(videoPath)) {
            fs.unlinkSync(videoPath);
        }
        if (outputPath && fs.existsSync(outputPath)) {
            fs.unlinkSync(outputPath);
        }
    }
}
break;


case 'myanimelist':
case 'mal': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
        
    const menuText = `
â•­â”€â”€â”€â˜‰ *MyAnimeList*
â”‚
â”‚ ðŸ”Ž *Pencarian:*
â”‚ âœŽ *.searchanime <judul>*
â”‚    â”” Mencari anime berdasarkan judul.
â”‚ âœŽ *.searchchar <nama>*
â”‚    â”” Mencari karakter berdasarkan nama.
â”‚
â”‚ â„¹ï¸ *Info Detail (gunakan ID dari hasil pencarian):*
â”‚ âœŽ *.animeinfo <id anime>*
â”‚    â”” Menampilkan detail lengkap anime.
â”‚ âœŽ *.charinfo <id karakter>*
â”‚    â”” Menampilkan detail lengkap karakter.
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜‰
    `.trim();
    Reply(menuText);
}
break;

case 'searchanime': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Anda belum terdaftar.`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
    if (!text) return Reply(`Contoh: .searchanime Naruto`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Sedang mencari anime...');

    try {
        const res = await fetchJson(`https://api.jikan.moe/v4/anime?q=${encodeURIComponent(text)}&limit=5`);
        if (!res.data || res.data.length === 0) return Reply(`âŒ Anime dengan judul "${text}" tidak ditemukan.`);
        
        let teks = `*ðŸ”Ž Hasil Pencarian Anime untuk "${text}"*\n\n`;
        res.data.forEach((anime, index) => {
            teks += `*${index + 1}. ${anime.title}*\n`;
            teks += `   - *ID:* ${anime.mal_id}\n`;
            teks += `   - *Tipe:* ${anime.type}\n`;
            teks += `   - *Episode:* ${anime.episodes || 'N/A'}\n`;
            teks += `   - *Skor:* ${anime.score || 'N/A'}\n\n`;
        });
        teks += `Gunakan *.animeinfo <ID>* untuk detail lebih lanjut.`;
        Reply(teks);

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan saat mencari anime.");
    }
}
break;

case 'animeinfo': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Anda belum terdaftar.`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
    if (!text || isNaN(text)) return Reply(`Contoh: .animeinfo 1735`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Mengambil detail anime...');

    try {
        const res = await fetchJson(`https://api.jikan.moe/v4/anime/${text}`);
        if (!res.data) return Reply(`âŒ Anime dengan ID "${text}" tidak ditemukan.`);

        const anime = res.data;
        const synopsis = anime.synopsis ? anime.synopsis.slice(0, 300) + '...' : 'Tidak ada sinopsis.';
        
        let teks = `*âœ¨ ${anime.title} (${anime.title_japanese})*\n\n`;
        teks += `*ðŸ“Š Peringkat:* #${anime.rank || 'N/A'}\n`;
        teks += `*â­ Skor:* ${anime.score || 'N/A'} (dari ${anime.scored_by || 0} suara)\n`;
        teks += `*ðŸŽ¬ Tipe:* ${anime.type} | *Status:* ${anime.status}\n`;
        teks += `*ðŸŽ¥ Episode:* ${anime.episodes || 'N/A'}\n`;
        teks += `*â³ Durasi:* ${anime.duration}\n`;
        teks += `*ðŸŽ­ Genre:* ${anime.genres.map(g => g.name).join(', ')}\n\n`;
        teks += `*ðŸ“– Sinopsis:*\n${synopsis}\n\n`;
        teks += `ðŸ”— *URL:* ${anime.url}`;

        await alip.sendMessage(m.chat, {
            image: { url: anime.images.jpg.large_image_url },
            caption: teks
        }, { quoted: m });

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan atau ID tidak valid.");
    }
}
break;

case 'searchchar': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Anda belum terdaftar.`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
    if (!text) return Reply(`Contoh: .searchchar Uzumaki Naruto`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Sedang mencari karakter...');

    try {
        const res = await fetchJson(`https://api.jikan.moe/v4/characters?q=${encodeURIComponent(text)}&limit=5`);
        if (!res.data || res.data.length === 0) return Reply(`âŒ Karakter dengan nama "${text}" tidak ditemukan.`);

        let teks = `*ðŸ”Ž Hasil Pencarian Karakter untuk "${text}"*\n\n`;
        res.data.forEach((char, index) => {
            teks += `*${index + 1}. ${char.name}*\n`;
            teks += `   - *ID:* ${char.mal_id}\n`;
            teks += `   - *Kanji:* ${char.name_kanji || 'N/A'}\n`;
            teks += `   - *Favorit:* ${char.favorites.toLocaleString()} â¤ï¸\n\n`;
        });
        teks += `Gunakan *.charinfo <ID>* untuk detail lebih lanjut.`;
        Reply(teks);

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan saat mencari karakter.");
    }
}
break;

case 'charinfo': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Anda belum terdaftar.`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
    if (!text || isNaN(text)) return Reply(`Contoh: .charinfo 17`);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Mengambil detail karakter...');

    try {
        const res = await fetchJson(`https://api.jikan.moe/v4/characters/${text}/full`);
        if (!res.data) return Reply(`âŒ Karakter dengan ID "${text}" tidak ditemukan.`);

        const char = res.data;
        const about = char.about ? char.about.slice(0, 300) + '...' : 'Tidak ada deskripsi.';
        
        let teks = `*ðŸ‘¤ ${char.name} (${char.name_kanji || ''})*\n\n`;
        teks += `*â¤ï¸ Favorit:* ${char.favorites.toLocaleString()}\n`;
        if (char.nicknames && char.nicknames.length > 0) {
            teks += `*alias:* ${char.nicknames.join(', ')}\n`;
        }
        teks += `\n*ðŸ“ Tentang Karakter:*\n${about}\n\n`;
        teks += `ðŸ”— *URL:* ${char.url}`;

        await alip.sendMessage(m.chat, {
            image: { url: char.images.jpg.image_url },
            caption: teks
        }, { quoted: m });

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan atau ID tidak valid.");
    }
}
break;

case 'autosholat': {
    if (!isCreator) return Reply(mess.owner);
    
    if (!text || (text !== 'on' && text !== 'off')) {
        const status = global.isSholatReminderOn ? 'ðŸŸ¢ AKTIF' : 'ðŸ”´ NONAKTIF';
        let jadwalText = 'ðŸ•‹ *JADWAL SHOLAT JAKARTA*\n\n';
        for (const [sholat, waktu] of Object.entries(jadwalSholatJakarta)) {
            jadwalText += `â€¢ ${sholat}: ${waktu}\n`;
        }
        return Reply(
            `ðŸ“œ *PENGINGAT SHOLAT OTOMATIS*\n\n` +
            `Status: ${status}\n\n` +
            `${jadwalText}\n` +
            `Gunakan: *${prefix}autosholat on* untuk mengaktifkan\n` +
            `Gunakan: *${prefix}autosholat off* untuk menonaktifkan`
        );
    }
    
    if (text === 'on') {
        global.isSholatReminderOn = true;
        sholatSettings.isActive = true;
        fs.writeFileSync(sholatReminderPath, JSON.stringify(sholatSettings, null, 2));
        Reply(
            'âœ… *PENGINGAT SHOLAT DIHIDUPKAN*\n\n' +
            'Bot akan mengirim pengingat sholat otomatis ke semua grup sesuai jadwal:\n' +
            'â€¢ Subuh: 04:27\n' +
            'â€¢ Dzuhur: 12:02\n' + 
            'â€¢ Ashar: 15:23\n' +
            'â€¢ Maghrib: 18:00\n' +
            'â€¢ Isya: 19:12\n\n' +
            '_Pengingat akan dikirim setiap waktu sholat tiba_'
        );
    } else if (text === 'off') {
        global.isSholatReminderOn = false;
        sholatSettings.isActive = false;
        fs.writeFileSync(sholatReminderPath, JSON.stringify(sholatSettings, null, 2));
        Reply(
            'âŒ *PENGINGAT SHOLAT DIMATIKAN*\n\n' +
            'Bot berhenti mengirim pengingat sholat otomatis.\n' +
            'Gunakan *' + prefix + 'autosholat on* untuk mengaktifkan kembali.'
        );
    }
    break;
}
case 'sholatstatus':
    const status = global.isSholatReminderOn ? 'ðŸŸ¢ AKTIF' : 'ðŸ”´ NONAKTIF';
    let jadwalText = 'ðŸ•‹ *JADWAL SHOLAT JAKARTA*\n\n';
    for (const [sholat, waktu] of Object.entries(jadwalSholatJakarta)) {
        jadwalText += `â€¢ ${sholat}: ${waktu}\n`;
    }
    Reply(`*Status Pengingat Sholat:* ${status}\n\n${jadwalText}`);
    break;

case 'testsholat':
    if (!isCreator) return Reply(mess.owner);
    Reply('ðŸ”Š Testing pengingat sholat...');
    await kirimPengingatOffline(alip, 'Test');
    break;

// ================== [ FITUR RESELLER PANEL ] ==================

// âž• Tambah Reseller
case 'addreseller':
case 'addres': {
  if (!isCreator) return Reply(mess.owner);
  if (!args[0]) return Reply(`ðŸ“Œ Contoh:\n${prefix}addresseler @tag\n${prefix}addresseler 6281234567890`);

  let reseller = loadReseller();
  let users = [];

  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id);
          return p ? (p.jid || p.id) : null;
        } else {
          return id;
        }
      }).filter(Boolean);
    } else {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
    }
  } else {
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
  }

  let addedCount = 0;
  for (let jid of users) {
    if (!reseller.includes(jid)) {
      reseller.push(jid);
      addedCount++;
    }
  }

  if (addedCount === 0) {
    return Reply(`âœ… ${users.map(j => '@' + j.split('@')[0]).join(', ')} sudah terdaftar sebagai Reseller.`, users);
  }

  saveReseller(reseller);
  Reply(`âœ… ${users.map(j => '@' + j.split('@')[0]).join(', ')} berhasil ditambahkan sebagai Reseller permanen.`, users);
}
break;

// âŒ Hapus Reseller
case 'delreseller': {
  if (!isCreator) return Reply(mess.owner);
  if (!args[0]) return Reply(`ðŸ“Œ Contoh:\n${prefix}delreseller @tag`);

  let reseller = loadReseller();
  let users = [];

  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id);
          return p ? (p.jid || p.id) : null;
        } else {
          return id;
        }
      }).filter(Boolean);
    } else {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
    }
  } else {
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
  }

  let removedCount = 0;
  for (let jid of users) {
    const index = reseller.indexOf(jid);
    if (index > -1) {
      reseller.splice(index, 1);
      removedCount++;
    }
  }

  if (removedCount === 0) {
    return Reply(`âŒ ${users.map(j => '@' + j.split('@')[0]).join(', ')} tidak ditemukan di daftar Reseller.`, users);
  }

  saveReseller(reseller);
  Reply(`âœ… Berhasil menghapus ${users.map(j => '@' + j.split('@')[0]).join(', ')} dari daftar Reseller.`, users);
}
break;

// ðŸ“‹ List Reseller
case 'listreseller': {
  if (!isCreator) return Reply(mess.owner);

  let reseller = loadReseller();
  if (reseller.length === 0) return Reply('âš ï¸ Belum ada user yang terdaftar sebagai Reseller.');

  let textList = "*ã€Œ LIST USER RESELLER ã€*\n\n";
  reseller.forEach((jid, index) => {
    textList += `${index + 1}. @${jid.split('@')[0]}\n`;
  });

  alip.sendMessage(m.chat, { text: textList.trim(), mentions: reseller }, { quoted: m });
}
break;

// ðŸ” Cek apakah user reseller
case 'cekres': {
  if (!args[0] && !m.mentionedJid.length) return Reply(`ðŸ“Œ Contoh:\n${prefix}isreseller @tag atau ${prefix}isreseller 6281234567890`);

  let target;
  if (m.mentionedJid.length) {
    target = m.mentionedJid.map(id => {
      if (id.endsWith('@lid')) {
        let p = m.metadata.participants.find(x => x.lid === id || x.id === id);
        return p ? (p.jid || p.id) : id;
      } else {
        return id;
      }
    })[0];
  } else {
    target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';
  }

  if (isReseller(target)) {
    Reply(`âœ… User @${target.split('@')[0]} adalah *Reseller*.`, [target]);
  } else {
    Reply(`âŒ User @${target.split('@')[0]} bukan Reseller.`, [target]);
  }
}
break;

case "emoji": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
    if (!text) 
        return Reply(example("ðŸ¥´"));
    if (text.length > 4) 
        return Reply("âŒ Harap kirimkan satu emoji saja.");

    try {
        await alip.sendMessage(m.chat, { react: { text: 'ðŸŽ¨', key: m.key } });
        const { Sticker } = require('wa-sticker-formatter');

        const apiKey = `${global.apikeyalip}`;
        const apiUrl = `${global.btc}/api/emoji/apple?apikey=${global.apikeyalip}&emoji=${encodeURIComponent(text)}`;
        const buffer = await getBuffer(apiUrl); 
        
        if (!buffer || buffer.length < 1000) {
             return Reply('âŒ Gagal mendapatkan gambar dari API. Mungkin emoji tidak didukung.');
        }
        const sticker = new Sticker(buffer, {
            pack: global.packname, 
            author: global.botname2,
            type: 'full', 
            quality: 100
        });
        const stickerBuffer = await sticker.toBuffer();
        await alip.sendMessage(m.chat, { sticker: stickerBuffer }, { quoted: m });

    } catch (error) {
        console.error("Error di case .emoji:", error);
        Reply("âŒ Gagal membuat stiker. Pastikan Anda mengirim satu emoji yang valid dan coba lagi.");
    }
}
break;
case 'antibot': {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin grup!');
    
    if (!text) {
        const isActiveDelete = global.db.groups[m.chat]?.antibot || false;
        const isActiveKick = global.db.groups[m.chat]?.antibotkick || false;
        
        let statusDelete = isActiveDelete ? 'âœ… AKTIF' : 'âŒ NONAKTIF';
        let statusKick = isActiveKick ? 'âœ… AKTIF' : 'âŒ NONAKTIF';
        
        return Reply(`ðŸ”§ *ANTI-BOT SETTINGS*\n\nDelete Mode: ${statusDelete}\nKick Mode: ${statusKick}\n\nPilihan:\nâ€¢ delete - hanya hapus pesan\nâ€¢ kick - hapus pesan + kick bot\n\nContoh:\n${prefix}antibot delete on\n${prefix}antibot kick off`);
    }
    
    const argsText = text.toLowerCase().split(' ');
    if (argsText.length < 2) return Reply(`Format: ${prefix}antibot <delete/kick> <on/off>`);
    
    const mode = argsText[0];
    const action = argsText[1];
    
    if (mode !== 'delete' && mode !== 'kick') {
        return Reply('âŒ Mode tidak valid! Pilih: delete atau kick');
    }
    
    if (action !== 'on' && action !== 'off') {
        return Reply('âŒ Action tidak valid! Pilih: on atau off');
    }
    
    if (!global.db.groups) global.db.groups = {};
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    
    if (mode === 'delete') {
        global.db.groups[m.chat].antibot = (action === 'on');
        fs.writeFileSync('./library/database/groups_db.json', JSON.stringify(global.db.groups, null, 2));
        Reply(`âœ… Anti-bot delete ${action === 'on' ? 'diaktifkan' : 'dinonaktifkan'}`);
    } else if (mode === 'kick') {
        global.db.groups[m.chat].antibotkick = (action === 'on');
        fs.writeFileSync('./library/database/groups_db.json', JSON.stringify(global.db.groups, null, 2));
        Reply(`âœ… Anti-bot kick ${action === 'on' ? 'diaktifkan' : 'dinonaktifkan'}`);
    }
    break;
}
case 'tambang':
case 'mining': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (player.location !== 'tambang') return Reply('â›ï¸ Kamu harus pergi ke *.rpgmove tambang* dulu untuk menambang!');

    // Inisialisasi state menambang jika belum ada
    if (!player.miningState) {
        player.miningState = { stage: 'permukaan', lastMine: 0 };
    }

    const cooldown = 3 * 60 * 1000; // Cooldown 3 menit
    if (Date.now() - player.miningState.lastMine < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.miningState.lastMine));
        return Reply(`Kamu butuh istirahat! Coba lagi dalam ${timeLeft}.`);
    }

    const expGained = generateRandomNumber(5, 15);
    const batuGained = generateRandomNumber(1, 5);
    gainExp(player, expGained);
    player.inventory["batu"] = (player.inventory["batu"] || 0) + batuGained;

    // Maju ke tahap selanjutnya
    player.miningState.stage = 'besi';
    player.miningState.lastMine = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`Kamu menambang di permukaan dan mendapatkan:\n\nðŸ’Ž *Batu x${batuGained}*\nâ­ *+${expGained} EXP*\n\nKamu menemukan jalur menuju lapisan *bijih besi*. Ketik *.besi* untuk melanjutkan menambang lebih dalam.`);
}
break;

case 'besi': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (!player.miningState || player.miningState.stage !== 'besi') {
        return Reply("Kamu belum menemukan lapisan bijih besi. Mulai dari *.tambang* terlebih dahulu.");
    }

    const cooldown = 3 * 60 * 1000; // Cooldown 3 menit
    if (Date.now() - player.miningState.lastMine < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.miningState.lastMine));
        return Reply(`Area ini masih belum stabil! Coba lagi dalam ${timeLeft}.`);
    }

    const expGained = generateRandomNumber(15, 30);
    const itemGained = generateRandomNumber(1, 3);
    gainExp(player, expGained);
    player.inventory["bijih_besi"] = (player.inventory["bijih_besi"] || 0) + itemGained;

    player.miningState.stage = 'nikel'; // Lanjut ke tahap nikel
    player.miningState.lastMine = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`Kamu berhasil menambang di lapisan bijih besi dan mendapatkan:\n\nâ›“ï¸ *Bijih Besi x${itemGained}*\nâ­ *+${expGained} EXP*\n\nKamu menemukan lapisan *nikel*. Ketik *.nikel* untuk menambang lebih dalam.`);
}
break;

case 'nikel': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (!player.miningState || player.miningState.stage !== 'nikel') {
        return Reply("Kamu belum menemukan lapisan nikel. Selesaikan dulu lapisan *.besi*.");
    }

    const cooldown = 4 * 60 * 1000; // Cooldown 4 menit
    if (Date.now() - player.miningState.lastMine < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.miningState.lastMine));
        return Reply(`Lapisan nikel lebih keras! Butuh istirahat lebih lama. Coba lagi dalam ${timeLeft}.`);
    }

    const expGained = generateRandomNumber(25, 45);
    const itemGained = generateRandomNumber(1, 2);
    gainExp(player, expGained);
    player.inventory["nikel"] = (player.inventory["nikel"] || 0) + itemGained;

    player.miningState.stage = 'emas'; // Lanjut ke tahap emas
    player.miningState.lastMine = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`Kamu berhasil menembus lapisan nikel dan mendapatkan:\n\nðŸ”© *Nikel x${itemGained}*\nâ­ *+${expGained} EXP*\n\nKilauan *emas* terlihat di depanmu. Ketik *.emas* untuk menggali lebih dalam.`);
}
break;

case 'emas': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (!player.miningState || player.miningState.stage !== 'emas') {
        return Reply("Kamu belum menemukan lapisan emas. Selesaikan dulu lapisan *.nikel*.");
    }

    const cooldown = 5 * 60 * 1000; // Cooldown 5 menit
    if (Date.now() - player.miningState.lastMine < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.miningState.lastMine));
        return Reply(`Menggali emas butuh kesabaran! Coba lagi dalam ${timeLeft}.`);
    }

    const expGained = generateRandomNumber(40, 70);
    const itemGained = 1; // Emas lebih langka
    gainExp(player, expGained);
    player.inventory["emas"] = (player.inventory["emas"] || 0) + itemGained;

    player.miningState.stage = 'berlian'; // Lanjut ke tahap berlian
    player.miningState.lastMine = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`Kerja kerasmu terbayar! Kamu mendapatkan:\n\nðŸ’° *Emas x${itemGained}*\nâ­ *+${expGained} EXP*\n\nDi dasar tambang, kamu melihat kilauan paling murni. Ketik *.berlian* untuk mengambilnya.`);
}
break;

case 'berlian': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (!player.miningState || player.miningState.stage !== 'berlian') {
        return Reply("Kamu belum mencapai dasar tambang. Selesaikan dulu lapisan *.emas*.");
    }

    const cooldown = 7 * 60 * 1000; // Cooldown 7 menit
    if (Date.now() - player.miningState.lastMine < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.miningState.lastMine));
        return Reply(`Mengambil berlian butuh kehati-hatian! Coba lagi dalam ${timeLeft}.`);
    }

    const expGained = generateRandomNumber(80, 150);
    const itemGained = 1;
    gainExp(player, expGained);
    player.inventory["berlian"] = (player.inventory["berlian"] || 0) + itemGained;

    player.miningState.stage = 'besi'; // Reset kembali ke tahap besi untuk loop
    player.miningState.lastMine = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`Luar biasa! Kamu berhasil mencapai dasar dan mendapatkan harta paling berharga:\n\nðŸ’Ž *Berlian x${itemGained}*\nâ­ *+${expGained} EXP*\n\nTambang telah di-reset. Kamu bisa mulai lagi dari lapisan bijih besi dengan mengetik *.besi*.`);
}
break;


case 'meramu':
case 'foraging': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (player.location !== 'padang_rumput') return Reply('ðŸŒ¿ Kamu harus pergi ke *.rpgmove padang_rumput* dulu untuk meramu!');

    const cooldown = 5 * 60 * 1000; // 5 menit
    if (Date.now() - (player.lastForage || 0) < cooldown) {
        const timeLeft = msToTime(cooldown - (Date.now() - player.lastForage));
        return Reply(`Kamu butuh istirahat! Coba lagi dalam ${timeLeft}.`);
    }
    
    const locationData = rpgDB.locations.padang_rumput;
    let gainedHerbs = [];
    for (const [herb, chance] of Object.entries(locationData.herbs)) {
        if (Math.random() < chance) {
            const amount = generateRandomNumber(1, 4);
            player.inventory[herb] = (player.inventory[herb] || 0) + amount;
            gainedHerbs.push(`${rpgDB.items[herb].name} x${amount}`);
        }
    }

    if (gainedHerbs.length === 0) {
        gainedHerbs.push("Rumput Liar x2");
        player.inventory["rumput_liar"] = (player.inventory["rumput_liar"] || 0) + 2;
    }

    const expGained = generateRandomNumber(8, 20);
    gainExp(player, expGained);
    player.lastForage = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`*Hasil Meramu:*\n\n${gainedHerbs.join('\n')}\n\nâ­ *+${expGained} EXP*`);
}
break;

case "spacegame": {
    let data = loadData();
    let cmd = (args[0] || "").toLowerCase();

    // ================= USER BARU =================
    if (!data[m.sender]) {
        data[m.sender] = {
            nama: m.pushName,
            exp: 0,
            level: 1,
            health: 100,
            fuel: 3,
            planet: "Bumi",
            credit: 50,
            inventory: { weapon: "Laser Gun", medkit: 1, fuel: 1 },
            quest: {
                mission: generateQuest(),
                progress: 0,
                completed: false,
                lastReset: new Date().toDateString()
            }
        };
        saveData(data);
    }

    let user = data[m.sender];

    // ================= RESET QUEST HARIAN =================
    if (user.quest.lastReset !== new Date().toDateString()) {
        user.quest = {
            mission: generateQuest(),
            progress: 0,
            completed: false,
            lastReset: new Date().toDateString()
        };
        saveData(data);
    }

    if (!cmd) {
        const menuCaption = `ðŸ‘¨â€ðŸš€ *Game RPG Luar Angkasa*\n\n` +
            `ðŸš€ Nama: *${user.nama}*\n` +
            `ðŸ’  Level: *${user.level}*\n` +
            `âœ¨ EXP: *${user.exp}/${user.level * 100}*\n` +
            `â¤ï¸ Health: *${user.health}*\n` +
            `â›½ Fuel: *${user.fuel}*\n` +
            `ðŸ’° Credit: *${user.credit}*\n` +
            `ðŸª Lokasi: *${user.planet}*\n\n` +
            `ðŸ“œ *Daftar Perintah:*\n` +
            `â€¢ .start`;

        return await alip.sendMessage(m.chat, {
            image: { url: thumb.menu },
            caption: menuCaption,
            footer: "ðŸš€ SpaceGame RPG Bot"
        }, { quoted: m });
    }

    // ================= STATUS =================
    if (cmd === "status") {
        let teks = `ðŸ‘¨â€ðŸš€ *Status Petualangan*\n\n` +
            `ðŸš€ Nama: *${user.nama}*\n` +
            `ðŸ’  Level: *${user.level}*\n` +
            `âœ¨ EXP: *${user.exp}/${user.level * 100}*\n` +
            `â¤ï¸ Health: *${user.health}*\n` +
            `â›½ Fuel: *${user.fuel}*\n` +
            `ðŸ’° Credit: *${user.credit}*\n` +
            `ðŸª Lokasi: *${user.planet}*`;

        return await alip.sendMessage(m.chat, {
            image: { url: thumb.status },
            caption: teks
        }, { quoted: m });
    }

    // ================= JELAJAH =================
    if (cmd === "jelajah") {
        if (user.fuel < 1) return Reply("â›½ Bahan bakar habis!");

        user.fuel -= 1;
        let planetList = ["Mars", "Jupiter", "Saturnus", "Neptunus", "Andromeda"];
        let randomPlanet = planetList[Math.floor(Math.random() * planetList.length)];
        let hasilExp = Math.floor(Math.random() * 50) + 10;
        let hasilCredit = Math.floor(Math.random() * 30) + 10;

        user.exp += hasilExp;
        user.credit += hasilCredit;
        user.planet = randomPlanet;

        if (user.quest.mission.type === "jelajah") {
            user.quest.progress++;
            if (user.quest.progress >= user.quest.mission.target) user.quest.completed = true;
        }

        if (user.exp >= user.level * 100) {
            user.level++;
            user.health = 100;
            Reply(`ðŸŽ‰ Level Up! Sekarang level *${user.level}*`);
        }

        saveData(data);
        return await alip.sendMessage(m.chat, {
            image: { url: thumb.jelajah },
            caption: `ðŸš€ Kamu menjelajah ke planet *${randomPlanet}*!\nâœ¨ +${hasilExp} EXP\nðŸ’° +${hasilCredit} Credit`
        }, { quoted: m });
    }

    // ================= BATTLE =================
    if (cmd === "battle") {
        let alienHP = Math.floor(Math.random() * 50) + 30;
        let alienAtk = Math.floor(Math.random() * 20) + 5;
        let playerAtk = Math.floor(Math.random() * 25) + 10;

        alienHP -= playerAtk;

        let result = `âš”ï¸ Pertempuran melawan ðŸ‘½ Alien\nðŸ—¡ï¸ Seranganmu: -${playerAtk} HP\n`;

        if (alienHP > 0) {
            user.health -= alienAtk;
            result += `ðŸ‘½ Alien menyerang balik: -${alienAtk} HP\n`;
        } else {
            let expGain = Math.floor(Math.random() * 40) + 20;
            let creditGain = Math.floor(Math.random() * 50) + 20;
            user.exp += expGain;
            user.credit += creditGain;
            result += `ðŸ† Kamu menang!\nâœ¨ +${expGain} EXP\nðŸ’° +${creditGain} Credit\n`;
        }

        if (user.exp >= user.level * 100) {
            user.level++;
            user.health = 100;
            result += `\nðŸŽ‰ Level Up! Sekarang level *${user.level}*`;
        }

        if (user.health <= 0) {
            result += "\nðŸ’€ Kamu kalah! Data direset...";
            delete data[m.sender];
        }

        saveData(data);
        return await alip.sendMessage(m.chat, {
            image: { url: thumb.battle },
            caption: result
        }, { quoted: m });
    }

    // ================= QUEST =================
    if (cmd === "quest") {
        let q = user.quest;
        let teks = `ðŸŽ¯ *Misi Harian*\n\nProgress: *${q.progress}/${q.mission.target}*\nStatus: ${q.completed ? "âœ… Selesai" : "â³ Belum"}\nHadiah: âœ¨ ${q.mission.reward.exp} EXP, ðŸ’° ${q.mission.reward.credit} Credit`;

        return await alip.sendMessage(m.chat, {
            image: { url: thumb.quest },
            caption: teks
        }, { quoted: m });
    }

    if (cmd === "claim") {
        let q = user.quest;
        if (!q.completed) return Reply("âŒ Misi belum selesai!");
        user.exp += q.mission.reward.exp;
        user.credit += q.mission.reward.credit;
        q.completed = false;
        q.progress = 0;
        q.mission = generateQuest();
        q.lastReset = new Date().toDateString();

        if (user.exp >= user.level * 100) {
            user.level++;
            user.health = 100;
            Reply(`ðŸŽ‰ Level Up! Sekarang level *${user.level}*`);
        }

        saveData(data);
        return await alip.sendMessage(m.chat, {
            image: { url: thumb.quest },
            caption: `ðŸŽ‰ Hadiah misi diterima!\nâœ¨ +${q.mission.reward.exp} EXP\nðŸ’° +${q.mission.reward.credit} Credit`
        }, { quoted: m });
    }

    // ================= INVENTORY =================
    if (cmd === "inv") {
        let inv = user.inventory;
        let teks = `ðŸŽ’ *Inventory*\n\nðŸ”« Senjata: *${inv.weapon}*\nðŸ©¹ Medkit: *${inv.medkit}*\nâ›½ Fuel: *${inv.fuel}*\nðŸ’° Credit: *${user.credit}*`;

        return await alip.sendMessage(m.chat, {
            image: { url: thumb.inventory },
            caption: teks
        }, { quoted: m });
    }

    // ================= SHOP =================
    if (cmd === "shop") {
        let teks = `ðŸ›’ *Toko Luar Angkasa*\n\n1. Medkit - 30ðŸ’°\n2. Fuel - 20ðŸ’°\n3. Plasma Rifle - 100ðŸ’°`;

        return await alip.sendMessage(m.chat, {
            image: { url: thumb.shop },
            caption: teks
        }, { quoted: m });
    }

    // ================= BUY =================
    if (cmd === "buy") {
        let item = (args[1] || "").toLowerCase();
        if (!item) return Reply("âš ï¸ Pilih item yang mau dibeli!\nContoh: *.spacegame buy medkit*");

        let shopItems = {
            medkit: { price: 30, key: "medkit" },
            fuel: { price: 20, key: "fuel" },
            plasma: { price: 100, key: "weapon", value: "Plasma Rifle" }
        };

        if (!shopItems[item]) return Reply("âŒ Item tidak tersedia di toko!");

        let it = shopItems[item];
        if (user.credit < it.price) return Reply("âŒ Credit kamu tidak cukup!");

        user.credit -= it.price;

        if (it.key === "weapon") {
            user.inventory.weapon = it.value;
        } else {
            user.inventory[it.key] = (user.inventory[it.key] || 0) + 1;
        }

        saveData(data);
        return Reply(`âœ… Kamu membeli *${item}* seharga ${it.price}ðŸ’°`);
    }

    // ================= USE =================
    if (cmd === "use") {
        let item = (args[1] || "").toLowerCase();
        if (!item) return Reply("âš ï¸ Pilih item yang mau digunakan!\nContoh: *.spacegame use medkit*");

        if (item === "medkit") {
            if (!user.inventory.medkit || user.inventory.medkit < 1) return Reply("âŒ Kamu tidak punya Medkit!");
            user.health = Math.min(100, user.health + 50);
            user.inventory.medkit -= 1;
            saveData(data);
            return Reply(`ðŸ©¹ Kamu menggunakan Medkit! HP sekarang: ${user.health}`);
        }

        if (item === "fuel") {
            if (!user.inventory.fuel || user.inventory.fuel < 1) return Reply("âŒ Kamu tidak punya Fuel!");
            user.fuel += 1;
            user.inventory.fuel -= 1;
            saveData(data);
            return Reply(`â›½ Kamu menggunakan Fuel! Sisa Fuel: ${user.fuel}`);
        }

        return Reply("âŒ Item tidak dikenal!");
    }

    // ================= PVP =================
    if (cmd === "pvp") {
        if (m.mentionedJid.length < 1) return Reply("âš ï¸ Tag pemain yang mau ditantang!\nContoh: *.spacegame pvp @user*");

        let opponentId = m.mentionedJid[0];
        if (!data[opponentId]) return Reply("âŒ Pemain itu belum memulai permainan!");

        let opponent = data[opponentId];
        if (user.health <= 0) return Reply("ðŸ’€ HP-mu habis!");
        if (opponent.health <= 0) return Reply("ðŸ’€ HP lawan habis!");

        let userAtk = Math.floor(Math.random() * 25) + 10;
        let oppAtk = Math.floor(Math.random() * 25) + 10;

        opponent.health -= userAtk;
        let hasil = `âš”ï¸ *PVP DIMULAI!*\n\n${user.nama} VS ${opponent.nama}\n\nðŸ—¡ï¸ ${user.nama} serang â†’ -${userAtk} HP\n`;

        if (opponent.health > 0) {
            user.health -= oppAtk;
            hasil += `ðŸ›¡ï¸ ${opponent.nama} balas â†’ -${oppAtk} HP\n`;
        } else {
            let expGain = 80, creditGain = 60;
            user.exp += expGain;
            user.credit += creditGain;
            hasil += `ðŸ† ${user.nama} menang duel!\nâœ¨ +${expGain} EXP\nðŸ’° +${creditGain} Credit\n`;
        }

        if (user.exp >= user.level * 100) {
            user.level++;
            user.health = 100;
            hasil += `\nðŸŽ‰ Level Up! Sekarang level *${user.level}*`;
        }

        if (user.health <= 0) { hasil += `\nðŸ’€ ${user.nama} kalah! Reset...`; delete data[m.sender]; }
        if (opponent.health <= 0) { hasil += `\nðŸ’€ ${opponent.nama} kalah! Reset...`; delete data[opponentId]; }

        saveData(data);
        return await alip.sendMessage(m.chat, {
            image: { url: thumb.pvp },
            caption: hasil
        }, { quoted: m });
    }

    // ================= RESET =================
    if (cmd === "reset") {
        delete data[m.sender];
        saveData(data);
        return await alip.sendMessage(m.chat, {
            image: { url: thumb.reset },
            caption: "â™»ï¸ Data game direset!"
        }, { quoted: m });
    }
}
break;

case "start": {
  if (!isRegistered(m.sender)) return forcerpy(mess.verifikasi);
  if (checkLimit(m.sender, isPrem(m.sender), isCreator)) return Reply(mess.limit);
  
  addLimit(m.sender, isPrem(m.sender), isCreator);

  const safeText = typeof text === "string" ? text : String(text || "");
  if (safeText.length > 100) return Reply(`âš ï¸ Maksimal 100 karakter.`);

  try {
    await alip.sendMessage(m.chat, {
      image: { url: thumb.menu },
      caption: ` ðŸŒŒ GALAXY FRONTIER: Explore the Unknown`,
      buttons: [
        {
          buttonId: "ðŸ“Š Informasi",
          buttonText: { displayText: "ðŸš€ SpaceGame RPG Bot" },
          type: 4,
          nativeFlowInfo: {
            name: "single_select",
            paramsJson: JSON.stringify({
              title: "Pilih Tipe",
              sections: [
                {
                  title: "ðŸ“Š Informasi",
                  rows: [
                    {
                      title: "ðŸ”Ž Status",
                      description: "Lihat status petualanganmu",
                      id: ".spacegame status"
                    },
                    {
                      title: "ðŸŽ’ Inventory",
                      description: "Cek barang yang kamu punya",
                      id: ".spacegame inv"
                    }
                  ]
                },
                {
                  title: "ðŸš€ Aktivitas",
                  rows: [
                    {
                      title: "ðŸš€ Jelajah",
                      description: "Menjelajahi planet baru",
                      id: ".spacegame jelajah"
                    },
                    {
                      title: "âš”ï¸ Battle",
                      description: "Bertarung dengan musuh",
                      id: ".spacegame battle"
                    },
                    {
                      title: "ðŸŽ¯ Quest",
                      description: "Ambil misi harian",
                      id: ".spacegame quest"
                    }
                  ]
                },
                {
                  title: "ðŸ’° Lainnya",
                  rows: [
                    {
                      title: "ðŸ›’ Shop",
                      description: "Beli item untuk petualangan",
                      id: ".spacegame shop"
                    },
                    {
                      title: "ðŸŽ Claim",
                      description: "Claim hadiah harian",
                      id: ".spacegame claim"
                    },
                    {
                      title: "â™»ï¸ Reset",
                      description: "Reset data permainan",
                      id: ".spacegame reset"
                    }
                  ]
                }
              ]
            })
          }
        }
      ],
      headerType: 4,
      viewOnce: true,
      contextInfo: {
        mentionedJid: [m.sender]
      }
    }, { quoted: m });

  } catch (error) {
    console.error("[START ERROR]", error);
    Reply("âŒ Gagal memproses perintah start.");
  }
}
break;
// --- DUNGEON SYSTEM ---
case 'dungeon': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];
    
    if (player.dungeonState?.inDungeon) {
        const dungeon = rpgDB.dungeons[player.dungeonState.id];
        let monster;
        if (player.dungeonState.stage < dungeon.stages.length) {
            const stageInfo = dungeon.stages[player.dungeonState.stage];
            monster = rpgDB.monsters[stageInfo.monsterId];
            return Reply(`ðŸ”¥ Kamu sedang di *${dungeon.name}* (Stage ${player.dungeonState.stage + 1}).\n\nMusuh: *${monster.name}*\nSisa HP-mu: ${player.dungeonState.hp}/${player.maxHp}\n\nGunakan *.dungeon attack* untuk menyerang!`);
        } else {
            monster = rpgDB.monsters[dungeon.boss];
            return Reply(`ðŸ”¥ Kamu berhadapan dengan BOSS *${dungeon.name}*!\n\nMusuh: *${monster.name}*\nSisa HP-mu: ${player.dungeonState.hp}/${player.maxHp}\n\nGunakan *.dungeon attack* untuk serangan terakhir!`);
        }
    }

    if (!text) {
        let dungeonList = "âš”ï¸ *DAFTAR DUNGEON:*\n\n";
        for (const [id, d] of Object.entries(rpgDB.dungeons)) {
            dungeonList += `â€º *${d.name}* (Min. Lv ${d.minLevel})\n   Ketik: *.dungeon start ${id}*\n\n`;
        }
        return Reply(dungeonList);
    }

    const [action, dungeonId] = text.split(' ');

    if (action === 'start' && dungeonId) {
        const dungeon = rpgDB.dungeons[dungeonId];
        if (!dungeon) return Reply("âŒ Dungeon tidak ditemukan.");
        if (player.level < dungeon.minLevel) return Reply(`âŒ Level kamu belum cukup! Minimal Lv ${dungeon.minLevel}.`);

        player.dungeonState = {
            inDungeon: true,
            id: dungeonId,
            stage: 0,
            hp: player.hp
        };
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(`Kamu memasuki *${dungeon.name}*! Gunakan *.dungeon* untuk melihat status.`);
    }

    if (action === 'attack') {
        if (!player.dungeonState?.inDungeon) return Reply("Kamu tidak sedang di dalam dungeon.");
        const dungeon = rpgDB.dungeons[player.dungeonState.id];
        const currentStage = player.dungeonState.stage;
        
        let monster, isBoss = false;
        if (currentStage < dungeon.stages.length) {
            monster = { ...rpgDB.monsters[dungeon.stages[currentStage].monsterId] };
        } else {
            monster = { ...rpgDB.monsters[dungeon.boss] };
            isBoss = true;
        }

        let playerDungeonStats = { ...player, hp: player.dungeonState.hp };
        
        // --- Player Turn ---
        const playerDamage = calculateDamage(player, monster).damage;
        monster.hp -= playerDamage;
        let battleLog = [`ðŸ’¥ Kamu menyerang *${monster.name}* sebesar *${playerDamage}* damage!`];
        
        if (monster.hp <= 0) {
            // Monster defeated
            if (isBoss) {
                // BOSS DEFEATED
                battleLog.push(`\nðŸ† *SELAMAT!* Kamu berhasil mengalahkan BOSS dan menyelesaikan *${dungeon.name}*!`);
                const reward = dungeon.reward;
                player.gold += reward.gold;
                gainExp(player, reward.exp);
                if (reward.item) {
                    player.inventory[reward.item.id] = (player.inventory[reward.item.id] || 0) + reward.item.amount;
                    battleLog.push(`\nHadiah: ${reward.exp} EXP, ${reward.gold} Gold, dan ${rpgDB.items[reward.item.id].name} x${reward.item.amount}`);
                } else {
                    battleLog.push(`\nHadiah: ${reward.exp} EXP & ${reward.gold} Gold`);
                }
                delete player.dungeonState;
            } else {
                player.dungeonState.stage += 1;
                battleLog.push(`\nâœ… *${monster.name}* dikalahkan! Kamu maju ke stage selanjutnya.`);
            }
        } else {
            // --- Monster Turn ---
            const monsterDamage = calculateDamage(monster, player).damage;
            playerDungeonStats.hp -= monsterDamage;
            player.dungeonState.hp = playerDungeonStats.hp;
            battleLog.push(`ðŸ›¡ï¸ *${monster.name}* menyerang balik! Kamu menerima *${monsterDamage}* damage.`);
            
            if (playerDungeonStats.hp <= 0) {
                battleLog.push("\nðŸ’€ Kamu gagal di dungeon! HP-mu akan dipulihkan.");
                player.hp = player.maxHp; // Pulihkan HP setelah gagal
                delete player.dungeonState;
            } else {
                battleLog.push(`â¤ï¸ HP-mu di dungeon sisa: *${player.dungeonState.hp}*`);
            }
        }
        
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(battleLog.join('\n'));
    }
}
break;


// --- PET SYSTEM ---
case 'adopsipet':
case 'adoptpet': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];
    
    if (player.pet) return Reply(`Kamu sudah punya pet! Gunakan *.infopet* untuk melihatnya.`);

    if (!text) {
        let petList = "ðŸ¾ *PET SHOP*\n\n";
        for (const [id, pet] of Object.entries(rpgDB.petData)) {
            petList += `â€º *${pet.name}*\n   ${pet.description}\n   Harga: ${pet.cost} Gold\n   Ketik: *.adopsipet ${id}*\n\n`;
        }
        return Reply(petList);
    }
    
    const petId = text.toLowerCase().trim();
    const petInfo = rpgDB.petData[petId];
    if (!petInfo) return Reply("âŒ Pet tidak ditemukan.");
    
    if (player.gold < petInfo.cost) return Reply(`ðŸ’° Gold tidak cukup! Kamu butuh ${petInfo.cost} Gold.`);
    
    player.gold -= petInfo.cost;
    player.pet = {
        id: petId,
        name: petInfo.name,
        level: 1,
        exp: 0,
        attack: petInfo.attack || 0,
        defense: petInfo.defense || 0
    };
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    Reply(`ðŸŽ‰ Selamat! Kamu berhasil mengadopsi seekor *${petInfo.name}*!`);
}
break;

case 'infopet':
case 'petinfo': {
    if (!rpgDB.players[m.sender]?.pet) return Reply(`Kamu belum punya pet. Adopsi dulu di *.adopsipet*!`);
    const pet = rpgDB.players[m.sender].pet;
    
    let petStats = `
ðŸ¾ *INFO PET-MU*

â€º Nama: *${pet.name}*
â€º Level: ${pet.level}
â€º EXP: ${pet.exp}/100
`;
    if (pet.attack > 0) petStats += `â€º Attack: +${pet.attack}\n`;
    if (pet.defense > 0) petStats += `â€º Defense: +${pet.defense}\n`;
    
    Reply(petStats);
}
break;

case 'addlimitall': {
  if (!isCreator) return Reply(mess.owner);

  if (!text || isNaN(text)) {
    return Reply(`âŒ Masukkan jumlah limit yang ingin ditambahkan untuk semua user.\n\nContoh: .addlimitall 50`);
  }
  const amount = parseInt(text);
  if (amount <= 0) return Reply('âŒ Jumlah limit harus lebih dari 0.');

  m.reply(`â³ Memproses penambahan *${amount}* limit untuk semua user terdaftar...`);

  const userDB = safeReadJSON(userDBPath, []); 
  const bonusDB = safeReadJSON(limitBonusPath, {});
  
  if (userDB.length === 0) {
    return Reply('âš ï¸ Tidak ada user terdaftar di database.');
  }

  const today = getWIBTime().toISOString().split('T')[0];
  let successCount = 0;

  for (const user of userDB) {
    const jid = user.jid;
    if (!jid) continue;

    if (!bonusDB[jid] || bonusDB[jid].date !== today) {
      bonusDB[jid] = { bonus: 0, date: today };
    }
    
    bonusDB[jid].bonus += amount;
    successCount++;
  }

  fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));

  Reply(`âœ… Berhasil menambahkan *${amount}* limit bonus untuk *${successCount}* user terdaftar.\n\nBonus ini hanya berlaku untuk hari ini.`);
}
break;

		case 'wwpc':
			case 'ww':
			case 'werewolf': {
				let jimp = require("jimp")
				const resize = async (image, width, height) => {
					const read = await jimp.read(image);
					const data = await read.resize(width, height).getBufferAsync(jimp.MIME_JPEG);
					return data;
				};

				let {
					emoji_role,
					sesi,
					playerOnGame,
					playerOnRoom,
					playerExit,
					dataPlayer,
					dataPlayerById,
					getPlayerById,
					getPlayerById2,
					killWerewolf,
					killww,
					dreamySeer,
					sorcerer,
					protectGuardian,
					roleShuffle,
					roleChanger,
					roleAmount,
					roleGenerator,
					addTimer,
					startGame,
					playerHidup,
					playerMati,
					vote,
					voteResult,
					clearAllVote,
					getWinner,
					win,
					pagi,
					malam,
					skill,
					voteStart,
					voteDone,
					voting,
					run,
					run_vote,
					run_malam,
					runprefixagi
				} = require('./lib/werewolf.js')

				// [ Thumbnail ] 
				let thumb = "https://user-images.githubusercontent.com/72728486/235316834-f9f84ba0-8df3-4444-81d8-db5270995e6d.jpg";

				const {
					sender,
					chat
				} = m;
				alip.werewolf = alip.werewolf ? alip.werewolf : {};
				const ww = alip.werewolf ? alip.werewolf : {};
				const data = ww[chat];
				const value = args[0];
				const target = args[1];
				let byId = getPlayerById2(sender, parseInt(target), ww);
				// [ Membuat Room ]
				if (value === "create") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (chat in ww) return Reply("Group masih dalam sesi permainan");
					if (playerOnGame(sender, ww) === true)
						return Reply("Kamu masih dalam sesi game");
					ww[chat] = {
						room: chat,
						owner: sender,
						status: false,
						iswin: null,
						cooldown: null,
						day: 0,
						time: "malem",
						player: [],
						dead: [],
						voting: false,
						seer: false,
						guardian: [],
					};
					await Reply("Room berhasil dibuat, ketik *.ww join* untuk bergabung");

					// [ Join sesi permainan ]
				} else if (value === "join") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (!ww[chat]) return Reply("Belum ada sesi permainan");
					if (ww[chat].status === true)
						return Reply("Sesi permainan sudah dimulai");
					if (ww[chat].player.length > 16)
						return Reply("Maaf jumlah player telah penuh");
					if (playerOnRoom(sender, chat, ww) === true)
						return Reply("Kamu sudah join dalam room ini");
					if (playerOnGame(sender, ww) === true)
						return Reply("Kamu masih dalam sesi game");
					let data = {
						id: sender,
						number: ww[chat].player.length + 1,
						sesi: chat,
						status: false,
						role: false,
						effect: [],
						vote: 0,
						isdead: false,
						isvote: false,
					};
					ww[chat].player.push(data);
					let player = [];
					let text = `\n*âŒ‚ W E R E W O L F - P L A Y E R*\n\n`;
					for (let i = 0; i < ww[chat].player.length; i++) {
						text += `${ww[chat].player[i].number}) @${ww[chat].player[i].id.replace("@s.whatsapp.net", "")}\n`;
						player.push(ww[chat].player[i].id);
					}
					text += "\nJumlah player minimal adalah 5 dan maximal 15";
					alip.sendMessage(
						m.chat, {
							text: text.trim(),
							contextInfo: {
								externalAdReply: {
									title: "W E R E W O L F",
									mediaType: 1,
									renderLargerThumbnail: true,
									thumbnail: await resize(thumb, 300, 175),
									sourceUrl: "https://whatsapp.com/channel/0029Vaf0HPMLdQeZsp3XRp2T",
									mediaUrl: thumb,
								},
								mentionedJid: player,
							},
						}, {
							quoted: m
						}
					);

					// [ Game Play ]
				} else if (value === "start") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (!ww[chat]) return Reply("Belum ada sesi permainan");
					if (ww[chat].player.length === 0)
						return Reply("Room belum memiliki player");
					if (ww[chat].player.length < 5)
						return Reply("Maaf jumlah player belum memenuhi syarat");
					if (playerOnRoom(sender, chat, ww) === false)
						return Reply("Kamu belum join dalam room ini");
					if (ww[chat].cooldown > 0) {
						if (ww[chat].time === "voting") {
							clearAllVote(chat, ww);
							addTimer(chat, ww);
							return await run_vote(alip.chat, ww);
						} else if (ww[chat].time === "malem") {
							clearAllVote(chat, ww);
							addTimer(chat, ww);
							return await run_malam(alip.chat, ww);
						} else if (ww[chat].time === "pagi") {
							clearAllVote(chat, ww);
							addTimer(chat, ww);
							return await runprefixagi(alip.chat, ww);
						}
					}
					if (ww[chat].status === true)
						return Reply("Sesi permainan telah dimulai");
					if (ww[chat].owner !== sender)
						return Reply(
							`Hanya @${ww[chat].owner.split("@")[0]} yang dapat memulai permainan`
						);
					let list1 = "";
					let list2 = "";
					let player = [];
					roleGenerator(chat, ww);
					addTimer(chat, ww);
					startGame(chat, ww);
					for (let i = 0; i < ww[chat].player.length; i++) {
						list1 += `(${ww[chat].player[i].number}) @${ww[chat].player[i].id.replace("@s.whatsapp.net", "")}\n`;
						player.push(ww[chat].player[i].id);
					}
					for (let i = 0; i < ww[chat].player.length; i++) {
						list2 += `(${ww[chat].player[i].number}) @${ww[chat].player[i].id.replace("@s.whatsapp.net", "")} ${ww[chat].player[i].role === "werewolf" || ww[chat].player[i].role === "sorcerer" ? `[${ww[chat].player[i].role}]` : ""}\n`;
						player.push(ww[chat].player[i].id);
					}
					for (let i = 0; i < ww[chat].player.length; i++) {
						// [ Werewolf ]
						if (ww[chat].player[i].role === "werewolf") {
							if (ww[chat].player[i].isdead != true) {
								var textt = `Hai ${alip.getName(ww[chat].player[i].id)}, Kamu telah dipilih untuk memerankan *Werewolf* ${emoji_role("werewolf")} pada permainan kali ini, silahkan pilih salah satu player yang ingin kamu makan pada malam hari ini\n*LIST PLAYER*:\n${list2}\n\nKetik *.wwpc kill nomor* untuk membunuh player`;
								await alip.sendMessage(ww[chat].player[i].id, {
									text: textt,
									mentions: player,
								});
							}
							// [ villager ]
						} else if (ww[chat].player[i].role === "warga") {
							if (ww[chat].player[i].isdead != true) {
								let texttt = `*âŒ‚ W E R E W O L F - G A M E*\n\nHai ${alip.getName(ww[chat].player[i].id)} Peran kamu adalah *Warga Desa* ${emoji_role("warga")}, tetap waspada, mungkin *Werewolf* akan memakanmu malam ini, silakan masuk kerumah masing masing.\n*LIST PLAYER*:\n${list1}`;
								await alip.sendMessage(ww[chat].player[i].id, {
									text: texttt,
									mentions: player,
								});
							}

							// [ Penerawangan ]
						} else if (ww[chat].player[i].role === "seer") {
							if (ww[chat].player[i].isdead != true) {
								let texxt = `Hai ${alip.getName(ww[chat].player[i].id)} Kamu telah terpilih  untuk menjadi *Penerawang* ${emoji_role("seer")}. Dengan sihir yang kamu punya, kamu bisa mengetahui peran pemain pilihanmu.\n*LIST PLAYER*:\n${list1}\n\nKetik *.wwpc dreamy nomor* untuk melihat role player`;

								await alip.sendMessage(ww[chat].player[i].id, {
									text: texxt,
									mentions: player,
								});
							}

							// [ Guardian ]
						} else if (ww[chat].player[i].role === "guardian") {
							if (ww[chat].player[i].isdead != true) {
								let teext = `Hai ${alip.getName(ww[chat].player[i].id)} Kamu terpilih untuk memerankan *Malaikat Pelindung* ${emoji_role("guardian")}, dengan kekuatan yang kamu miliki, kamu bisa melindungi para warga, silahkan pilih salah 1 player yang ingin kamu lindungi\n*LIST PLAYER*:\n${list1}\n\nKetik *.wwpc deff nomor* untuk melindungi player`;

								await alip.sendMessage(ww[chat].player[i].id, {
									text: teext,
									mentions: player,
								});
							}

							// [ Sorcerer ]
						} else if (ww[chat].player[i].role === "sorcerer") {
							if (ww[chat].player[i].isdead != true) {
								let textu = `Hai ${alip.getName(ww[chat].player[i].id)} Kamu terpilih sebagai Penyihir ${emoji_role("sorcerer")}, dengan kekuasaan yang kamu punya, kamu bisa membuka identitas para player, silakan pilih 1 orang yang ingin kamu buka identitasnya\n*LIST PLAYER*:\n${list2}\n\nKetik *.wwpc sorcerer nomor* untuk melihat role player`;

								await alip.sendMessage(ww[chat].player[i].id, {
									text: textu,
									mentions: player,
								});
							}
						}
					}
					await alip.sendMessage(m.chat, {
						text: "*âŒ‚ W E R E W O L F - G A M E*\n\nGame telah dimulai, para player akan memerankan perannya masing masing, silahkan cek chat pribadi untuk melihat role kalian. Berhati-hatilah para warga, mungkin malam ini adalah malah terakhir untukmu",
						contextInfo: {
							externalAdReply: {
								title: "W E R E W O L F",
								mediaType: 1,
								renderLargerThumbnail: true,
								thumbnail: await resize(thumb, 300, 175),
								sourceUrl: "https://whatsapp.com/channel/0029Vaf0HPMLdQeZsp3XRp2T",
								mediaUrl: thumb,
							},
							mentionedJid: player,
						},
					});
					await run(alip, alip.chat, ww);

} else if (value === "kill") {
    byId = getPlayerById2(sender, parseInt(target), ww); 
    if (dataPlayer(sender, ww).role !== "werewolf")
        return forcerpy("Peran ini bukan untuk kamu");
    
    if (!byId) 
        return Reply("Player tidak terdaftar atau target tidak valid.");
        
    if (byId.db.role === "sorcerer")
        return forcerpy("Tidak bisa menggunakan skill untuk teman");
    if (playerOnGame(sender, ww) === false)
        return Reply("Kamu tidak dalam sesi game")

					if (dataPlayer(sender, ww).status === true)
						return Reply("Skill telah digunakan, skill hanya bisa digunakan sekali setiap malam")
					if (dataPlayer(sender, ww).isdead === true)
						return Reply("Kamu sudah mati")
					if (!target || target.length < 1 || target.split('').length > 2)
						return Reply(`Masukan nomor player \nContoh : \n${prefix + command} kill 1`)
					if (isNaN(target))
						return Reply("Gunakan hanya nomor")
					let byId = getPlayerById2(sender, parseInt(target), ww)
					if (byId.db.isdead === true)
						return Reply("Player sudah mati")
					if (byId.db.id === sender)
						return Reply("Tidak bisa menggunakan skill untuk diri sendiri")
					if (byId === false)
						return Reply("Player tidak terdaftar")
					Reply("Berhasil membunuh player " + parseInt(target))
						.then(() => {
							dataPlayer(sender, ww).status = true;
							killWerewolf(sender, parseInt(target), ww);
						});
				} else if (value === "dreamy") {
					if (dataPlayer(sender, ww).role !== "seer")
						return forcerpy("Peran ini bukan untuk kamu");
					if (playerOnGame(sender, ww) === false)
						return Reply("Kamu tidak dalam sesi game")
					if (dataPlayer(sender, ww).status === true)
						return Reply("Skill telah digunakan, skill hanya bisa digunakan sekali setiap malam")
					if (dataPlayer(sender, ww).isdead === true)
						return Reply("Kamu sudah mati")
					if (!target || target.length < 1 || target.split('').length > 2)
						return Reply(`Masukan nomor player \nContoh : \n${prefix + command} kill 1`)
					if (isNaN(target))
						return Reply("Gunakan hanya nomor")
					let byId = getPlayerById2(sender, parseInt(target), ww)
					if (byId.db.isdead === true)
						return Reply("Player sudah mati")
					if (byId.db.id === sender)
						return Reply("Tidak bisa menggunakan skill untuk diri sendiri")
					if (byId === false)
						return Reply("Player tidak terdaftar")
					let dreamy = dreamySeer(m.sender, parseInt(target), ww);
					Reply(`Berhasil membuka identitas player ${target} adalah ${dreamy}`)
						.then(() => {
							dataPlayer(sender, ww).status = true;
						});
				} else if (value === "deff") {
					if (dataPlayer(sender, ww).role !== "guardian")
						return forcerpy("Peran ini bukan untuk kamu");
					if (playerOnGame(sender, ww) === false)
						return Reply("Kamu tidak dalam sesi game")
					if (dataPlayer(sender, ww).status === true)
						return Reply("Skill telah digunakan, skill hanya bisa digunakan sekali setiap malam")
					if (dataPlayer(sender, ww).isdead === true)
						return Reply("Kamu sudah mati")
					if (!target || target.length < 1 || target.split('').length > 2)
						return Reply(`Masukan nomor player \nContoh : \n${prefix + command} kill 1`)
					if (isNaN(target))
						return Reply("Gunakan hanya nomor")
					let byId = getPlayerById2(sender, parseInt(target), ww)
					if (byId.db.isdead === true)
						return Reply("Player sudah mati")
					if (byId.db.id === sender)
						return Reply("Tidak bisa menggunakan skill untuk diri sendiri")
					if (byId === false)
						return Reply("Player tidak terdaftar")
					Reply(`Berhasil melindungi player ${target}`).then(() => {
						protectGuardian(m.sender, parseInt(target), ww);
						dataPlayer(sender, ww).status = true;
					});
				} else if (value === "sorcerer") {
					if (dataPlayer(sender, ww).role !== "sorcerer")
						return forcerpy("Peran ini bukan untuk kamu");
					if (playerOnGame(sender, ww) === false)
						return Reply("Kamu tidak dalam sesi game")
					if (dataPlayer(sender, ww).status === true)
						return Reply("Skill telah digunakan, skill hanya bisa digunakan sekali setiap malam")
					if (dataPlayer(sender, ww).isdead === true)
						return Reply("Kamu sudah mati")
					if (!target || target.length < 1 || target.split('').length > 2)
						return Reply(`Masukan nomor player \nContoh : \n${prefix + command} kill 1`)
					if (isNaN(target))
						return Reply("Gunakan hanya nomor")
					let byId = getPlayerById2(sender, parseInt(target), ww)
					if (byId.db.isdead === true)
						return Reply("Player sudah mati")
					if (byId.db.id === sender)
						return Reply("Tidak bisa menggunakan skill untuk diri sendiri")
					if (byId === false)
						return Reply("Player tidak terdaftar")
					let sorker = sorcerer(sesi(m.sender), target);
					Reply(`Berhasil membuka identitas player ${player} adalah ${sorker}`)
						.then(() => {
							dataPlayer(sender, ww).status = true;
						});
				} else if (value === "vote") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (!ww[chat]) return Reply("Belum ada sesi permainan");
					if (ww[chat].status === false)
						return Reply("Sesi permainan belum dimulai");
					if (ww[chat].time !== "voting")
						return Reply("Sesi voting belum dimulai");
					if (playerOnRoom(sender, chat, ww) === false)
						return Reply("Kamu bukan player");
					if (dataPlayer(sender, ww).isdead === true)
						return Reply("Kamu sudah mati");
					if (!target || target.length < 1)
						return Reply("Masukan nomor player");
					if (isNaN(target)) return Reply("Gunakan hanya nomor");
					if (dataPlayer(sender, ww).isvote === true)
						return Reply("Kamu sudah melakukan voting");
					b = getPlayerById(chat, sender, parseInt(target), ww);
					if (b.db.isdead === true)
						return Reply(`Player ${target} sudah mati.`);
					if (ww[chat].player.length < parseInt(target))
						return Reply("Invalid");
					if (getPlayerById(chat, sender, parseInt(target), ww) === false)
						return Reply("Player tidak terdaftar!");
					vote(chat, parseInt(target), sender, ww);
					return Reply("âœ… Vote");
				} else if (value == "exit") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (!ww[chat]) return Reply("Tidak ada sesi permainan");
					if (playerOnRoom(sender, chat, ww) === false)
						return Reply("Kamu tidak dalam sesi permainan");
					if (ww[chat].status === true)
						return Reply("Permainan sudah dimulai, kamu tidak bisa keluar");
					let exitww = `${sender.split("@")[0]} Keluar dari permainan`
					alip.sendMessage(
						m.chat, {
							text: exitww,
							contextInfo: {
								externalAdReply: {
									title: "W E R E W O L F",
									mediaType: 1,
									renderLargerThumbnail: true,
									thumbnail: await resize(thumb, 300, 175),
									sourceUrl: "https://whatsapp.com/channel/0029Vaf0HPMLdQeZsp3XRp2T",
									mediaUrl: thumb,
								},
								mentionedJid: sender,
							},
						}, {
							quoted: m
						}
					);
					playerExit(chat, sender, ww);
				} else if (value === "delete") {
					if (!m.isGroup) return m.reply("Perintah ini hanya untuk grup.");
					if (!ww[chat]) return Reply("Tidak ada sesi permainan");
					if (ww[chat].owner !== sender)
						return Reply(`Hanya @${ww[chat].owner.split("@")[0]} yang dapat menghapus sesi permainan ini`);
					Reply("Sesi permainan berhasil dihapus").then(() => {
						delete ww[chat];
					});
				} else if (value === "player") {
					if (!ww[chat]) return Reply("Tidak ada sesi permainan");
					if (playerOnRoom(sender, chat, ww) === false)
						return Reply("Kamu tidak dalam sesi permainan");
					if (ww[chat].player.length === 0)
						return Reply("Sesi permainan belum memiliki player");
					let player = [];
					let text = "\n*âŒ‚ W E R E W O L F - G A M E*\n\nLIST PLAYER:\n";
					for (let i = 0; i < ww[chat].player.length; i++) {
						text += `(${ww[chat].player[i].number}) @${ww[chat].player[i].id.replace("@s.whatsapp.net", "")} ${ww[chat].player[i].isdead === true ? `â˜ ï¸ ${ww[chat].player[i].role}` : ""}\n`;
						player.push(ww[chat].player[i].id);
					}
					alip.sendMessage(
						m.chat, {
							text: text,
							contextInfo: {
								externalAdReply: {
									title: "W E R E W O L F",
									mediaType: 1,
									renderLargerThumbnail: true,
									thumbnail: await resize(thumb, 300, 175),
									sourceUrl: "https://whatsapp.com/channel/0029Vaf0HPMLdQeZsp3XRp2T",
									mediaUrl: thumb,
								},
								mentionedJid: player,
							},
						}, {
							quoted: m
						}
					);
				} else {
					let text = `\n*âŒ‚ W E R E W O L F - G A M E*\n\nPermainan Sosial Yang Berlangsung Dalam Beberapa Putaran/ronde. Para Pemain Dituntut Untuk Mencari Seorang Penjahat Yang Ada Dipermainan. Para Pemain Diberi Waktu, Peran, Serta Kemampuannya Masing-masing Untuk Bermain Permainan Ini\n\n*âŒ‚ C O M M A N D*\n`;
					text += ` â€¢ ww create\n`;
					text += ` â€¢ ww join\n`;
					text += ` â€¢ ww start\n`;
					text += ` â€¢ ww exit\n`;
					text += ` â€¢ ww delete\n`;
					text += ` â€¢ ww player\n`;
					text += `\nPermainan ini dapat dimainkan oleh 5 sampai 15 orang.`;
					alip.sendMessage(
						m.chat, {
							text: text.trim(),
							contextInfo: {
								externalAdReply: {
									title: "W E R E W O L F",
									mediaType: 1,
									renderLargerThumbnail: true,
									thumbnail: await resize(thumb, 300, 175),
									sourceUrl: `${global.saluran}`,
									mediaUrl: thumb,
								},
							},
						}, {
							quoted: m
						}
					);
				}
			}
			break
  

case 'getpp': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text && !m.quoted) return Reply(`Contoh: ${prefix}getpp 6281234567890 atau ${prefix}getpp @tag`);
    
    let users = [];
    
    if (text) {
        if (m.mentionedJid && m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else {
            users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    } else if (m.quoted) {
        users = [m.quoted.sender]
    } else {
        users = [m.sender]
    }

    if (users.length === 0) return Reply('âŒ Tidak ada target yang ditemukan.');

    try {
        await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
        
        for (let userJid of users) {
            let finalJid = userJid;
            
            if (finalJid.endsWith('@lid')) {
                finalJid = finalJid.replace('@lid', '@s.whatsapp.net');
            }
            
            if (m.isGroup && m.metadata && m.metadata.participants) {
                const participant = m.metadata.participants.find(p => 
                    p.id === userJid || p.jid === userJid || 
                    (p.lid && p.lid === userJid)
                );
                if (participant) {
                    finalJid = participant.jid;
                }
            }

            try {
                const ppUrl = await alip.profilePictureUrl(finalJid, 'image');
                
                await alip.sendMessage(m.chat, {
                    image: { url: ppUrl },
                    caption: `âœ… Berhasil mendapatkan foto profil @${finalJid.split('@')[0]}`,
                    mentions: [finalJid]
                }, { quoted: m });
                
                await sleep(1000);
                
            } catch (e) {
                Reply(`âŒ Gagal mendapatkan foto profil untuk @${finalJid.split('@')[0]}.`);
            }
        }
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

    } catch (e) {
        console.error("GetPP Error:", e);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply(`âŒ Terjadi kesalahan.`);
    }
}
break;

case 'asmaulhusna': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    let asma;
    if (text && !isNaN(text)) {
        const index = parseInt(text);
        if (index > 0 && index <= 99) {
            asma = fullAsmaulHusna[index - 1];
        } else {
            return Reply("âŒ Nomor tidak valid. Masukkan angka antara 1 sampai 99.");
        }
    } else {
        asma = fullAsmaulHusna[Math.floor(Math.random() * fullAsmaulHusna.length)];
    }
    
    let teks = `ðŸŒŸ *Asmaul Husna*\n\n`;
    teks += `${asma.index}. *${asma.latin}* (${asma.arabic})\n`;
    teks += `*Artinya:* ${asma.arti}`;
    Reply(teks);
}
break;

case 'bacaansholat': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const key = text.toLowerCase().trim();
    if (!key || !dataBacaanSholat[key]) {
        let listBacaan = "ðŸ“– *Daftar Bacaan Sholat Tersedia:*\n\n";
        for (const k in dataBacaanSholat) {
            listBacaan += `â€¢ ${k.charAt(0).toUpperCase() + k.slice(1)} (ketik: *.bacaansholat ${k}*)\n`;
        }
        return Reply(listBacaan);
    }

    const bacaan = dataBacaanSholat[key];
    let teks = `ðŸ“– *Bacaan Sholat: ${bacaan.title}*\n\n`;
    teks += `*Arab:* ${bacaan.arabic}\n\n`;
    teks += `*Latin:* ${bacaan.latin}\n\n`;
    teks += `*Artinya:* ${bacaan.arti}`;
    Reply(teks);
}
break;

case 'wirid':
case 'dzikir': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const teks = `ðŸ“¿ *Wirid & Dzikir Setelah Sholat Fardhu*\n\n1. Membaca Istighfar (3x)\n   Ø£ÙŽØ³Ù’ØªÙŽØºÙ’ÙÙØ±Ù Ø§Ù„Ù„Ù‡ÙŽ Ø§Ù„Ù’Ø¹ÙŽØ¸ÙÙŠÙ…ÙŽ\n   "Astaghfirullahal 'adziim"\n\n2. Membaca Tahlil\n   Ù„ÙŽØ§ Ø¥ÙÙ„ÙŽÙ‡ÙŽ Ø¥ÙÙ„Ù‘ÙŽØ§ Ø§Ù„Ù„Ù‘ÙŽÙ‡Ù ÙˆÙŽØ­Ù’Ø¯ÙŽÙ‡Ù Ù„ÙŽØ§ Ø´ÙŽØ±ÙÙŠÙƒÙŽ Ù„ÙŽÙ‡Ù...\n   "Laa ilaha illallahu wahdahu laa syarika lah..."\n\n3. Membaca Tasbih (33x)\n   Ø³ÙØ¨Ù’Ø­ÙŽØ§Ù†ÙŽ Ø§Ù„Ù„Ù‡Ù\n   "Subhanallah"\n\n4. Membaca Tahmid (33x)\n   Ø§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙŽÙ‡Ù\n   "Alhamdulillah"\n\n5. Membaca Takbir (33x)\n   Ø§Ù„Ù„Ù‡Ù Ø£ÙŽÙƒÙ’Ø¨ÙŽØ±Ù\n   "Allahu Akbar"\n\n6. Ditutup dengan Tahlil Panjang & Doa.\n\n(Ini adalah versi ringkas, urutan dapat bervariasi)`;
    Reply(teks);
}
break;

case 'doa': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const key = text.toLowerCase().trim();
    if (!key || !dataDoaPilihan[key]) {
        let listDoa = "ðŸ¤² *Daftar Doa Pilihan Tersedia:*\n\n";
        for (const k in dataDoaPilihan) {
            listDoa += `â€¢ ${dataDoaPilihan[k].title} (ketik: *.doa ${k}*)\n`;
        }
        return Reply(listDoa);
    }
    
    const doa = dataDoaPilihan[key];
    let teks = `ðŸ¤² *${doa.title}*\n\n`;
    teks += `*Arab:* ${doa.arabic}\n\n`;
    teks += `*Latin:* ${doa.latin}\n\n`;
    teks += `*Artinya:* ${doa.arti}`;
    Reply(teks);
}
break;

case 'hadits': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const hadits = dataHadits[Math.floor(Math.random() * dataHadits.length)];
    const teks = `ðŸ“œ *Hadits Harian*\n\n"${hadits.hadits}"\n\n- (HR. ${hadits.rawi}) -`;
    Reply(teks);
}
break;

case "level":
case "mylevel": {
if (!m.isGroup) return Reply("âŒ Perintah ini hanya bisa digunakan di dalam grup.")

try {
const { createCanvas, loadImage } = require("canvas")

const targetUserJid = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || m.sender)
const data = getUserLevel(m.chat, targetUserJid)
const xpToNext = getXPToNextLevel(data.level)
const progress = Math.min(data.xp / xpToNext, 1)
const progressPercentage = Math.round(progress * 100)

let pfp
try {
pfp = await alip.profilePictureUrl(targetUserJid, "image")
} catch {
pfp = "https://telegra.ph/file/a059a6a734ed202c879d3.jpg"
}

const canvas = createCanvas(1200, 600)
const ctx = canvas.getContext("2d")

try {
const bg = await loadImage(global.image.canvas)
ctx.drawImage(bg, 0, 0, canvas.width, canvas.height)
} catch {
ctx.fillStyle = "#0b0f1a"
ctx.fillRect(0, 0, canvas.width, canvas.height)
}

ctx.fillStyle = "rgba(0,0,0,0.6)"
ctx.fillRect(0, 0, canvas.width, canvas.height)

const cw = 1000
const ch = 420
const cx = (canvas.width - cw) / 2
const cy = (canvas.height - ch) / 2

ctx.fillStyle = "rgba(255,255,255,0.08)"
ctx.beginPath()
ctx.roundRect(cx, cy, cw, ch, 30)
ctx.fill()

ctx.strokeStyle = "rgba(255,255,255,0.25)"
ctx.lineWidth = 2
ctx.stroke()

ctx.font = "bold 42px Arial"
ctx.fillStyle = "#ffffff"
ctx.textAlign = "center"
ctx.fillText("LEVEL PROGRESS", canvas.width / 2, cy + 55)

const pSize = 150
const px = cx + 70
const py = cy + 120

ctx.save()
ctx.beginPath()
ctx.arc(px + pSize / 2, py + pSize / 2, pSize / 2, 0, Math.PI * 2)
ctx.clip()
try {
const avatar = await loadImage(pfp)
ctx.drawImage(avatar, px, py, pSize, pSize)
} catch {
ctx.fillStyle = "#444"
ctx.fillRect(px, py, pSize, pSize)
}
ctx.restore()

ctx.beginPath()
ctx.arc(px + pSize / 2, py + pSize / 2, pSize / 2 + 6, 0, Math.PI * 2)
ctx.strokeStyle = "#ffffff"
ctx.lineWidth = 4
ctx.stroke()

const infoX = px + pSize + 50
const infoY = py

const displayName = m.pushName || `@${targetUserJid.split("@")[0]}`
const shortName = displayName.length > 22 ? displayName.slice(0, 22) + "..." : displayName

ctx.textAlign = "left"
ctx.font = "bold 34px Arial"
ctx.fillStyle = "#ffffff"
ctx.fillText(shortName, infoX, infoY + 32)

ctx.font = "18px Arial"
ctx.fillStyle = "#cccccc"
ctx.fillText("@" + targetUserJid.split("@")[0], infoX, infoY + 60)

function statBox(x, y, title, value) {
ctx.fillStyle = "rgba(0,0,0,0.45)"
ctx.beginPath()
ctx.roundRect(x, y, 220, 62, 14)
ctx.fill()

ctx.font = "14px Arial"
ctx.fillStyle = "#aaaaaa"
ctx.fillText(title, x + 16, y + 22)

ctx.font = "bold 18px Arial"
ctx.fillStyle = "#ffffff"
ctx.fillText(value, x + 16, y + 46)
}

const statsY = infoY + 90
statBox(infoX, statsY, "LEVEL", "Lv " + data.level)
statBox(infoX + 240, statsY, "TOTAL PESAN", data.messages.toString())

const progressY = statsY + 100
const progressWidth = 600

ctx.font = "18px Arial"
ctx.fillStyle = "#cccccc"
ctx.fillText("PROGRESS MENUJU LEVEL SELANJUTNYA", infoX, progressY - 12)

ctx.fillStyle = "rgba(255,255,255,0.15)"
ctx.beginPath()
ctx.roundRect(infoX, progressY, progressWidth, 26, 13)
ctx.fill()

const progGrad = ctx.createLinearGradient(infoX, progressY, infoX + progressWidth, progressY)
progGrad.addColorStop(0, "#00c6ff")
progGrad.addColorStop(1, "#0072ff")

ctx.fillStyle = progGrad
ctx.beginPath()
ctx.roundRect(infoX, progressY, progressWidth * progress, 26, 13)
ctx.fill()

ctx.strokeStyle = "rgba(255,255,255,0.3)"
ctx.lineWidth = 2
ctx.beginPath()
ctx.roundRect(infoX, progressY, progressWidth, 26, 13)
ctx.stroke()

ctx.font = "bold 16px Arial"
ctx.fillStyle = "#ffffff"
ctx.textAlign = "center"
ctx.fillText(`${data.xp} / ${xpToNext} XP (${progressPercentage}%)`, infoX + progressWidth / 2, progressY + 18)

const xpNeeded = xpToNext - data.xp

ctx.font = "14px Arial"
ctx.fillStyle = "#bbbbbb"
ctx.textAlign = "left"
ctx.fillText(`Butuh ${xpNeeded} XP lagi untuk naik level`, infoX, progressY + 52)

ctx.font = "14px Arial"
ctx.fillStyle = "#bbbbbb"
ctx.textAlign = "center"
ctx.fillText(`${global.botname} â€¢ Level System`, canvas.width / 2, cy + ch - 14)

const buffer = canvas.toBuffer()

await alip.sendMessage(
m.chat,
{
image: buffer,
caption: `ðŸŽ¯ *LEVEL PROGRESS - ${displayName}*\n\n` +
`â­ Level: ${data.level}\n` +
`âš¡ XP: ${data.xp}/${xpToNext} (${progressPercentage}%)\n` +
`ðŸ’¬ Total Pesan: ${data.messages}\n` +
`ðŸ“ˆ Butuh ${xpNeeded} XP untuk naik level\n\n` +
`_Terus aktif di grup untuk naik level!_`,
mentions: [targetUserJid]
},
{ quoted: m }
)

} catch (err) {
Reply("âŒ Gagal membuat kartu level.")
}
}
break

case "leaderboard":
case "toplevel": {
    if (!m.isGroup) return Reply("âŒ Perintah ini hanya bisa digunakan di dalam grup.");

    try {
        const levelDB = JSON.parse(fs.readFileSync(levelDBPath));
        const groupData = levelDB[m.chat];

        if (!groupData || Object.keys(groupData).length === 0) {
            return Reply("ðŸ† Belum ada data leaderboard untuk grup ini. Mulai ngobrol untuk jadi yang pertama!");
        }

        const sortedUsers = Object.entries(groupData)
            .map(([jid, data]) => ({ jid, ...data }))
            .sort((a, b) => (b.level === a.level ? b.xp - a.xp : b.level - a.level))
            .slice(0, 10); // Ambil top 10

        let teks = `ðŸ† *TOP 10 LEADERBOARD GRUP INI* ðŸ†\n\n`;
        let mentions = [];
        
        sortedUsers.forEach((user, i) => {
            teks += `${i + 1}. @${user.jid.split("@")[0]}\n`;
            teks += `   â­ Level: ${user.level} | âš¡ XP: ${user.xp}\n\n`;
            mentions.push(user.jid);
        });

        alip.sendMessage(m.chat, {
            text: teks.trim(),
            mentions: mentions
        }, { quoted: m });
    } catch (err) {
        console.error("Error di case leaderboard:", err);
        Reply("âŒ Gagal mengambil data leaderboard.");
    }
}
break;
    
    case 'animekeneki': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/keneki?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ“¸ Nih anime Keneki buat lo'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_KENEKI ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break
case 'animemegumin': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/megumin?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'âœ¨ Megumin is here~'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_MEGUMIN ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME YOTSUBA
case 'animeyotsuba': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/yotsuba?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ€ Nih anime Yotsuba buat lo'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_YOTSUBA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME YUMEKO
case 'animeyumeko': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/yumeko?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸŽ² Yumeko Jabami hadir!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_YUMEKO ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME YULI
case 'animeyuli': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/yuli?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸŒ¸ Nih anime Yuli buat lo'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_YULI ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME TEJINA
case 'animetejina': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/tejina?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸŽ© Tejina-senpai hadir~'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_TEJINA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME AKIRA
case 'animeakira': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/akira?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ”¥ Anime Akira siap menemani lo!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_AKIRA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME TOUKA-CHAN
case 'animetoukachan': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/toukachan?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ‘» Touka-chan hadir spesial buat lo!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_TOUKACHAN ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME POKEMON
case 'animepokemon': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/pokemon?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'âš¡ Nih Pokemon buat lo!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_POKEMON ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME MIKU
case 'animemiku': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/miku?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸŽ¶ Hatsune Miku hadir nih~'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_MIKU ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME ITORI
case 'animeitori': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/itori?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ· Nih Itori dari Tokyo Ghoul!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[ANIME_ITORI ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME GREMORY
case 'animegremory': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/gremory?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ”¥ Rias Gremory hadir~' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_GREMORY ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME ISUZU
case 'animeisuzu': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/isuzu?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ´ Isuzu Sento dari Amagi Brilliant Park!' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_ISUZU ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'quotes': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Kamu belum terdaftar!`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const quotes = [
        "Hidup itu seperti roda berputar, kadang di atas, kadang di bawah. Jadi, pas di bawah jangan lupa jongkok.",
        "Jangan berhenti bermimpi, tapi jangan lupa pasang alarm biar nggak kesiangan.",
        "Sukses itu butuh proses. Mie instan aja perlu direbus dulu.",
        "Kalau kamu gagal, coba lagi. Kalau gagal lagi, mungkin itu bukan jalanmu. Coba jualan seblak.",
        "Jadilah seperti nanas. Berdiri tegak, mengenakan mahkota, dan manis di dalam.",
        "Masa depanmu diciptakan oleh apa yang kamu lakukan hari ini, bukan besok.",
        "Satu-satunya batasan untuk meraih impian kita adalah keraguan kita akan hari ini.",
        "Jangan takut salah, karena dari kesalahan kita bisa belajar... caranya nyalahin orang lain.",
        "Uang memang bukan segalanya, tapi segalanya butuh uang. Jadi, semangat kerjanya!",
        "Hidup itu singkat. Tersenyumlah selagi kamu masih punya gigi."
    ];
    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
    Reply(`"${randomQuote}"`);
}
break;

case 'pantun': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Kamu belum terdaftar!`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const pantun = [
        "Jalan-jalan ke kota Cianjur,\nJangan lupa membeli bubur.\nKalau kamu ingin jadi orang jujur,\nJangan pernah kamu jadi koruptor.",
        "Ada anak kecil main batu,\nBatu dilempar masuk ke sumur.\nBelajar itu jangan tunggu waktu,\nKalau bisa jangan tunggu sampai uzur.",
        "Beli kain warnanya merah,\nDari Kediri pakenya batik.\nKalau kamu jangan gampang marah,\nNanti cepat hilang cantiknya.",
        "Pohon mangga buahnya lebat,\nMerah warnanya manislah rasa.\nJadi anak haruslah berhemat,\nAgar hidup tak boros nantinya.",
        "Makan roti pakai selai,\nJangan lupa minumnya susu.\nKalau kamu ingin jadi pandai,\nJangan lupa belajar selalu."
    ];
    const randomPantun = pantun[Math.floor(Math.random() * pantun.length)];
    Reply(randomPantun);
}
break;

case 'darkjoke': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ Kamu belum terdaftar!`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const jokes = [
        "Masa depanku lebih gelap dari layar HP-ku pas mati.",
        "Aku bilang ke dokter aku patah tulang di beberapa tempat. Dia bilang, 'Ya jangan pergi ke tempat-tempat itu lagi.'",
        "Kenapa anak-anak yatim piatu jago main bola? Karena mereka nggak punya siapa-siapa untuk pulang.",
        "Apa persamaan antara temanku dan salju? Dua-duanya hilang setelah aku kencingi.",
        "Temanku ngeluh, 'Ah, hidup ini berat banget.' Aku jawab, 'Coba aja mati, lebih ringan palingan.'",
        "Kata orang, uang tidak bisa membeli kebahagiaan. Mungkin karena mereka tidak tahu di mana harus berbelanja.",
        "Aku bukan bilang aku benci kamu, tapi kalau kamu lagi tenggelam dan aku punya segelas air, aku akan meminumnya."
    ];
    const randomJoke = jokes[Math.floor(Math.random() * jokes.length)];
    Reply(randomJoke);
}
break;

// ðŸ“Œ ANIME SHINA
case 'animeshina': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/shina?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'âœ¨ Shina muncul nih!' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_SHINA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME KAGURA
case 'animekagura': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/kagura?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ¡ Kagura dari Gintama hadir~' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_KAGURA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME SHINKA
case 'animeshinka': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/shinka?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸŒ¸ Shinka Nibutani nih!' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_SHINKA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

// ðŸ“Œ ANIME EBA
case 'animeeba': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const res = await fetch(`${global.btc}/api/anime/eba?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');
    const buffer = await res.buffer();

    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“– Eba dari Kimi no Iru Machi siap!' }, { quoted: m });
  } catch (e) {
    console.error('[ANIME_EBA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break
case "caklontong":
case "tebakhero":
case "family100":
case "tebakgambar":
case "tebaklogo":
case "tebakgame":
case "tebakmakanan":
case "lengkapikalimat":
case "tebakbendera":
case "siapakahaku":
case "tebaklagu":
case "sambungkata":
case "tebakgenshin":
case "tebakhewan":
case "tebakinggris":
case "tebakkalimat":
case "tebakanime":
case "tebakkata":
case "susunkata":
case "tebakjorok":
case "tebaklirik":
case "asahotak":
case "tebakjkt": {
    await startGame(command, m);
}
break;

case "nyerah":
case "menyerah": {
    if (global.gameSessions[m.chat]) {
        let session = global.gameSessions[m.chat];
        clearTimeout(session.timeout); // Hentikan timer
        let jawabanTampil = Array.isArray(session.jawaban) ? session.jawaban.join(" / ") : session.jawaban;
        Reply(` Yah, kamu menyerah ðŸ³ï¸\nJawabannya adalah: *${jawabanTampil}*`);
        delete global.gameSessions[m.chat]; // Hapus sesi
    } else {
        Reply("Tidak ada game yang sedang berlangsung untuk diserahkan.");
    }
}
break;

    case 'sambungkata2':
    case 'sk':
        await handleSambungKata(alip, m, command, args);
        break;

case "ai": {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    let imageBuffer = null;
    let promptText = text || '';
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const axios = require('axios');
        const FormData = require('form-data');

        async function startSession() {
            const { data } = await axios.post(
                "https://chatgpt4online.org/wp-json/mwai/v1/start_session",
                {},
                {
                    headers: {
                        "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                        "Origin": "https://chatgpt4online.org",
                        "Referer": "https://chatgpt4online.org/",
                        "Accept": "*/*",
                        "Content-Type": "application/json"
                    }
                }
            );

            if (!data.success) throw new Error("start_session failed");

            return {
                sessionId: data.sessionId,
                nonce: data.restNonce
            };
        }

        async function uploadImage(nonce, buffer) {
            if (!buffer) return null;

            const form = new FormData();
            form.append("purpose", "vision");
            form.append("file", buffer, { filename: `image_${Date.now()}.png` });

            const { data } = await axios.post(
                "https://chatgpt4online.org/wp-json/mwai-ui/v1/files/upload",
                form,
                {
                    headers: {
                        "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                        "Origin": "https://chatgpt4online.org",
                        "Referer": "https://chatgpt4online.org/",
                        "X-WP-Nonce": nonce,
                        ...form.getHeaders()
                    }
                }
            );

            return data?.data?.id || null;
        }

        const session = await startSession();
        const fileIds = [];

        const getImageFromMessage = async (msg) => {
            try {
                if (msg.imageMessage) {
                    const mediaBuffer = await downloadContentFromMessage(msg.imageMessage, 'image');
                    let bufferArray = [];
                    for await (const chunk of mediaBuffer) {
                        bufferArray.push(chunk);
                    }
                    return Buffer.concat(bufferArray);
                }
            } catch (e) {}
            return null;
        };

        if (m.message?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message);
        } else if (m.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message.extendedTextMessage.contextInfo.quotedMessage);
        } else if (m.quoted?.msg?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted.msg);
        } else if (m.quoted?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted);
        }

        if (imageBuffer) {
            const fileId = await uploadImage(session.nonce, imageBuffer);
            if (fileId) {
                fileIds.push(fileId);
            }
        }

        if (!promptText && m.quoted?.text) {
            promptText = m.quoted.text;
        }
        
        if (!promptText && fileIds.length === 0) {
            return Reply(`Tanya sesuatu ke AI\nContoh: ${prefix}ai apa itu javascript?\n\nBisa juga kirim/balas gambar untuk analisis gambar.`);
        }
        
        if (!promptText && fileIds.length > 0) {
            promptText = "Jelaskan gambar ini";
        }

        const payload = {
            botId: "chatbot-qm966k",
            customId: null,
            session: session.sessionId,
            chatId: Math.random().toString(36).slice(2),
            contextId: 5410,
            messages: [
                {
                    id: "start",
                    role: "assistant",
                    content: "Hi! How can I help you?",
                    who: "AI: ",
                    timestamp: Date.now(),
                    key: "start"
                }
            ],
            newMessage: promptText,
            newFileId: null,
            newFileIds: fileIds,
            stream: false
        };

        const { data } = await axios.post(
            "https://chatgpt4online.org/wp-json/mwai-ui/v1/chats/submit",
            payload,
            {
                headers: {
                    "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                    "Origin": "https://chatgpt4online.org",
                    "Referer": "https://chatgpt4online.org/",
                    "X-WP-Nonce": session.nonce,
                    "Accept": "application/json",
                    "Content-Type": "application/json"
                }
            }
        );

        if (!data.success) throw new Error("AI response failed");

        const replyText = data.reply || "Tidak ada respons dari AI";
        
        await Reply(`ðŸ¤– *AI Assistant*\n\n${replyText}`);
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (error) {
        console.error('AI Error:', error);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal menghubungi AI: ' + error.message);
    }
}
break;
case 'bard': {
if (!text) return Reply(`Contoh: ${prefix}${command} halo, siapa kamu?`);

if (!isRegistered(m.sender) && !isCreator)
return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
const encodedText = encodeURIComponent(text);
const apiUrl = `${global.termai}/api/chat/bard?query=${encodedText}&key=${global.apitermai}`;

const { data } = await axios.get(apiUrl, { timeout: 60000 });

const response = data.chatUi || data.result || 'Tidak ada respon';

const finalResponse = `ðŸŽ€ ${global.botname}\n\n${response}`;

await Reply(finalResponse);
await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

} catch (error) {
await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
Reply('âŒ Gagal memproses permintaan');
}
break;
}
case 'logicbell': {
if (!text) return Reply(`Contoh: ${prefix}${command} halo, siapa kamu?`);

if (!isRegistered(m.sender) && !isCreator)
return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
const senderName = m.pushName || m.sender.split('@')[0];

const data = {
text: text,
id: m.chat,
fullainame: "Bella Clarissa",
nickainame: "Bella",
senderName: senderName,
ownerName: global.namaOwner,
date: new Date().toISOString(),
role: "Sahabat Deket",
msgtype: "text",
custom_profile: `- Nama kamu adalah Bella Clarissa, lebih suka dipanggil Bella.
- Kamu berpikir bahwa kamu adalah manusia, bukan AI atau Bot.
- Responmu singkat dan sama seperti perempuan pada umumnya.
- Kamu menggunakan bahasa yang baik dan mencerminkan gadis yang baik.
- Kamu harus menggunakan kata-kata yang identik dengan perempuan yang polos dan feminin.`,
commands: []
};

const apiUrl = `${global.termai}/api/chat/logic-bell?key=${global.apitermai}`;

const response = await axios.post(apiUrl, data, {
timeout: 60000,
headers: { 'Content-Type': 'application/json' }
});

if (!response.data.status) throw new Error('Gagal mendapatkan respon');

const result = response.data.data?.msg || 'Tidak ada respon';

const finalResponse = `ðŸŽ€ ${global.botname}\n\n${result}`;

await Reply(finalResponse);
await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

} catch (error) {
await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
Reply('âŒ Gagal memproses permintaan');
}
break;
}

case 'hyperai': case 'webpilot': case 'venice': case 'powerbrain': case 'publicai': {
if (!text) {
return Reply(`Contoh: ${prefix}${command} halo sayang`);
}

if (!isRegistered(m.sender) && !isCreator)
return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
const encodedText = encodeURIComponent(text);
let apiUrl = '';

if (command === 'hyperai') {
apiUrl = `https://api-faa.my.id/faa/ai-hyper?text=${encodedText}`;
} else if (command === 'webpilot') {
apiUrl = `https://api-faa.my.id/faa/webpilot?text=${encodedText}`;
} else if (command === 'venice') {
apiUrl = `https://api-faa.my.id/faa/venice-ai?text=${encodedText}`;
} else if (command === 'powerbrain') {
apiUrl = `https://api-faa.my.id/faa/powerbrain-ai?text=${encodedText}`;
} else if (command === 'publicai') {
apiUrl = `https://api-faa.my.id/faa/publicai?text=${encodedText}`;
} else {
throw new Error('Command tidak dikenali');
}

const { data } = await axios.get(apiUrl, { timeout: 60000 });

if (!data.status) {
throw new Error('API mengembalikan status false');
}

let result = data.result || data.msg || 'Tidak ada respon';

if (command === 'webpilot' && data.source && Array.isArray(data.source) && data.source.length > 0) {
let sourcesText = '\n\nðŸ“° *Sumber:*\n';
data.source.slice(0, 3).forEach((source, i) => {
if (source && source.title) {
sourcesText += `${i+1}. ${source.title}\n`;
}
});
if (data.source.length > 3) {
sourcesText += `   ...dan ${data.source.length - 3} sumber lainnya`;
}
result += sourcesText;
}

const finalResponse = `ðŸŽ€ ${global.botname}\n\n${result}`;

await Reply(finalResponse);
await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });

} catch (error) {
console.error(`FAA AI Error (${command}):`, error.message);
await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
Reply(`âŒ Gagal memproses ${command}: ${error.message || 'Coba lagi nanti'}`);
}
break;
}
case 'autoai': {
    const response = global.autoAiHandler.handleCommand(m, text);
    return Reply(response);
}
break;

        case 'equip': {
        if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan!`);
        if (!text) return Reply(`Gunakan: .equip [nama item]\nLihat item di *.rpginv*`);

        const player = rpgDB.players[m.sender];
        const itemId = text.toLowerCase().replace(/ /g, '_');
        
        if (!player.inventory[itemId] || player.inventory[itemId] < 1) return Reply(`Kamu tidak punya item "${text}"!`);

        const item = rpgDB.items[itemId];
        if (!item || (item.type !== 'weapon' && item.type !== 'armor')) return Reply(`"${text}" bukan item yang bisa di equip.`);
        
        const itemType = item.type; // 'weapon' or 'armor'
        // Unequip old item if exists
        if (player.equipment[itemType]) {
            const oldItemId = player.equipment[itemType];
            player.inventory[oldItemId] = (player.inventory[oldItemId] || 0) + 1;
        }

        // Equip new item
        player.equipment[itemType] = itemId;
        player.inventory[itemId] -= 1;
        if (player.inventory[itemId] <= 0) delete player.inventory[itemId];
        
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(`âœ… Berhasil memakai *${item.name}*!`);
    }
    break;

    // âœ¨ NEW: Unequip command
    case 'unequip': {
        if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan!`);
        if (!text || !['weapon', 'armor'].includes(text.toLowerCase())) return Reply(`Gunakan: .unequip [weapon/armor]`);
        
        const player = rpgDB.players[m.sender];
        const slot = text.toLowerCase();
        
        if (!player.equipment[slot]) return Reply(`Tidak ada ${slot} yang sedang dipakai.`);
        
        const itemId = player.equipment[slot];
        const item = rpgDB.items[itemId];
        
        // Move from equipment to inventory
        player.inventory[itemId] = (player.inventory[itemId] || 0) + 1;
        player.equipment[slot] = null;
        
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(`âœ… Berhasil melepas *${item.name}*!`);
    }
    break;
    
    case 'onlygc':
case 'onlygrup': {
  if (!isCreator) return Reply(mess.owner);

  const pathOnlyGroup = './library/database/onlygroup.json'; // pastikan path ini sama

  if (!text) {
    return Reply(
      `âš™ï¸ *Mode Hanya Grup Saat Ini: ${global.onlyGroupMode ? 'âœ… AKTIF' : 'âŒ NONAKTIF'}*\n\n` +
      `Gunakan:\n.onlygroup on - (Bot hanya respon di grup)\n.onlygroup off - (Bot respon di PM & grup)`
    );
  }

  if (text.toLowerCase() === 'on') {
    global.onlyGroupMode = true;
    fs.writeFileSync(pathOnlyGroup, JSON.stringify({ onlyGroupMode: true }, null, 2));
    Reply('âœ… Mode "Hanya Grup" berhasil diaktifkan.');
  } else if (text.toLowerCase() === 'off') {
    global.onlyGroupMode = false;
    fs.writeFileSync(pathOnlyGroup, JSON.stringify({ onlyGroupMode: false }, null, 2));
    Reply('âŒ Mode "Hanya Grup" berhasil dinonaktifkan.');
  } else {
    Reply('âš ï¸ Perintah tidak valid. Gunakan "on" atau "off".');
  }
}
break;

// ================== [ RPG - QUEST SYSTEM ] ==================

case "judionline": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.gold < 100) return Reply("âŒ Duitmu kurang buat deposit, minimal punya 100 Gold!");

  player.gold -= 100; // Modal deposit
  const hasil = [
    { nama: "MAXWIN! Kamu dapet jackpot besar!", exp: 100, gold: 2000, hp: 0 },
    { nama: "Rungkad... Saldomu ludes dimakan bandot.", exp: 10, gold: 0, hp: -5 },
    { nama: "Menang tipis, cuma balik modal.", exp: 5, gold: 100, hp: 0 },
    { nama: "Kalah beruntun sampai harus jual ginjal.", exp: 5, gold: -50, hp: -10 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸŽ° *Judi Online Simulator* ðŸŽ°\n\nKamu deposit 100 Gold dan mencoba peruntunganmu... hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold ${reward.gold >= 0 ? "+" : ""}${reward.gold} (Total Gold: ${player.gold})\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

case "begal": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 25) return Reply("âŒ Badanmu pegal-pegal, gak kuat buat ngeberhentiin motor orang!");

  const hasil = [
    { nama: "berhasil merampas HP kentang", exp: 30, gold: 300, hp: -10 },
    { nama: "target melawan, kamu bonyok", exp: 10, gold: 10, hp: -25 },
    { nama: "target ternyata anggota TNI, lari terbirit-birit", exp: 5, gold: 0, hp: -15 },
    { nama: "sukses besar, dapet laptop hasil COD-an", exp: 50, gold: 500, hp: -15 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ”ª *Begal Simulator* ðŸ”ª\n\nKamu mencoba peruntungan di jalan sepi dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

case "maling": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 15) return Reply("âŒ Kamu terlalu lemah untuk bergerak cepat, istirahat dulu!");

  const hasil = [
    { nama: "berhasil nyolong dompet emak-emak", exp: 25, gold: 200, hp: -5 },
    { nama: "ketahuan warga dan digebukin", exp: 5, gold: 0, hp: -20 },
    { nama: "cuma dapet kotak kosong", exp: 2, gold: 1, hp: -3 },
    { nama: "salah sasaran, nyolong dompet polisi", exp: 10, gold: 0, hp: -30 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ¥· *Maling Simulator* ðŸ¥·\n\nKamu beraksi di malam hari dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

case 'quest': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];

    if (player.activeQuest) {
        const quest = rpgDB.quests[player.activeQuest];
        let progressText = `(${player.questProgress}/${quest.count})`;
        return Reply(`ðŸ“œ *Quest Aktif: ${quest.title}*\n\n${quest.description}\n*Progress:* ${progressText}`);
    }

    if (player.location !== 'desa') {
        return Reply('ðŸ  Kamu hanya bisa mengambil quest di *Desa Pemula*.');
    }

    let questListText = "ðŸ“œ *Daftar Quest Tersedia:*\n\n";
    for (const [id, quest] of Object.entries(rpgDB.quests)) {
        questListText += `â€º *${quest.title}*\n    hadiah: ${quest.reward.exp} EXP, ${quest.reward.gold} Gold\n    ketik: *.quest ${id}*\n\n`;
    }
    questListText += "Pilih quest yang ingin kamu ambil.";
    
    if (!text) return Reply(questListText);

    const questId = text.toLowerCase().trim();
    if (!rpgDB.quests[questId]) return Reply("âŒ Quest tidak ditemukan.");

    player.activeQuest = questId;
    player.questProgress = 0;
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    Reply(`âœ… Quest *"${rpgDB.quests[questId].title}"* telah diambil!`);
}
break;

// ================== [ RPG - CRAFTING SYSTEM ] ==================
case 'craft': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];
    
    let recipeListText = "ðŸ› ï¸ *Resep yang bisa dibuat:*\n\n";
    for (const [id, recipe] of Object.entries(rpgDB.craftingRecipes)) {
        recipeListText += `â€º *${recipe.name} (x${recipe.amount})*\n   Bahan: ${Object.entries(recipe.materials).map(([mat, count]) => `${rpgDB.items[mat].name} x${count}`).join(', ')}\n   Ketik: *.craft ${id}*\n\n`;
    }

    if (!text) return Reply(recipeListText);

    const recipeId = text.toLowerCase().trim();
    if (!rpgDB.craftingRecipes[recipeId]) return Reply("âŒ Resep tidak ditemukan.");

    const recipe = rpgDB.craftingRecipes[recipeId];
    
    // Cek bahan
    for (const [material, required] of Object.entries(recipe.materials)) {
        if (!player.inventory[material] || player.inventory[material] < required) {
            return Reply(`âŒ Bahan tidak cukup! Kamu butuh *${rpgDB.items[material].name} x${required}* lagi.`);
        }
    }

    // Kurangi bahan
    for (const [material, required] of Object.entries(recipe.materials)) {
        player.inventory[material] -= required;
        if (player.inventory[material] <= 0) delete player.inventory[material];
    }

    // Tambah hasil craft
    player.inventory[recipe.result] = (player.inventory[recipe.result] || 0) + recipe.amount;
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    Reply(`âœ… Berhasil membuat *${recipe.name} (x${recipe.amount})*!`);
}
break;

// ================== [ RPG - DAILY REWARD ] ==================
case 'daily': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    const player = rpgDB.players[m.sender];
    const cooldown = 24 * 60 * 60 * 1000; // 24 jam
    
    if (Date.now() - player.lastDaily < cooldown) {
        const timeLeft = new Date(player.lastDaily + cooldown);
        return Reply(`Kamu sudah mengambil hadiah harian! Coba lagi besok jam ${timeLeft.toLocaleTimeString('id-ID')}.`);
    }

    const goldReward = 100 + (player.level * 10);
    const expReward = 50 + (player.level * 5);

    player.gold += goldReward;
    player.exp += expReward;
    player.lastDaily = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    Reply(`ðŸŽ *Hadiah Harian Diklaim!*\n\nKamu mendapatkan:\nðŸ’° Gold: +${goldReward}\nâ­ EXP: +${expReward}`);
}
break;

// ================== [ RPG - PVP SYSTEM ] ==================
case 'pvp': {
    if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan!`);

    let targetJid = null;
    
    if (m.isGroup) {
        if (m.mentionedJid && m.mentionedJid.length > 0) {
            for (let id of m.mentionedJid) {
                if (id.endsWith('@lid')) {
                    if (m.metadata && m.metadata.participants) {
                        let p = m.metadata.participants.find(x => x.lid === id || x.id === id);
                        if (p && p.jid) {
                            targetJid = p.jid;
                            break;
                        }
                    }
                } else {
                    targetJid = id;
                    break;
                }
            }
        } else if (args[0]) {
            const phoneNumber = args[0].replace(/[^0-9]/g, '');
            if (phoneNumber.length > 3) {
                targetJid = phoneNumber + '@s.whatsapp.net';
            }
        }
    } else {
        if (args[0]) {
            const phoneNumber = args[0].replace(/[^0-9]/g, '');
            if (phoneNumber.length > 3) {
                targetJid = phoneNumber + '@s.whatsapp.net';
            }
        }
    }
    
    if (!targetJid && m.quoted) {
        targetJid = m.quoted.sender;
    }
    
    if (!targetJid) return Reply(`Tag atau reply user yang ingin kamu ajak bertarung!\nContoh: *.pvp @user*`);
    
    if (targetJid === m.sender) return Reply("âŒ Kamu tidak bisa bertarung dengan dirimu sendiri!");
    if (!rpgDB.players[targetJid]) return Reply("âŒ Lawanmu belum memulai petualangan RPG!");

    const player = rpgDB.players[m.sender];
    const opponent = rpgDB.players[targetJid];
    const cooldown = 5 * 60 * 1000;

    if (Date.now() - player.lastPvp < cooldown) {
        return Reply(`Tunggu sebentar sebelum bertarung lagi!`);
    }

    player.lastPvp = Date.now();
    let playerHp = player.hp;
    let opponentHp = opponent.hp;
    let battleLog = [`âš”ï¸ *Pertarungan Dimulai: @${m.sender.split('@')[0]} vs @${targetJid.split('@')[0]}* âš”ï¸\n`];
    
    let turn = player.agility > opponent.agility ? m.sender : targetJid;

    while (playerHp > 0 && opponentHp > 0) {
        if (turn === m.sender) {
            const damage = Math.max(1, getPlayerTotalStats(player).attack - getPlayerTotalStats(opponent).defense);
            opponentHp -= damage;
            battleLog.push(`ðŸ’¥ @${m.sender.split('@')[0]} menyerang dan memberikan *${damage}* damage! HP lawan sisa *${opponentHp}*`);
            turn = targetJid;
        } else {
            const damage = Math.max(1, getPlayerTotalStats(opponent).attack - getPlayerTotalStats(player).defense);
            playerHp -= damage;
            battleLog.push(`ðŸ›¡ï¸ @${targetJid.split('@')[0]} menyerang balik dan memberikan *${damage}* damage! HP-mu sisa *${playerHp}*`);
            turn = m.sender;
        }
    }

    if (playerHp <= 0) {
        battleLog.push(`\nðŸ’€ Kamu Kalah!`);
        player.pvpLosses += 1;
        opponent.pvpWins += 1;
    } else {
        battleLog.push(`\nðŸ† Kamu Menang!`);
        player.pvpWins += 1;
        opponent.pvpLosses += 1;
        const goldStolen = Math.floor(opponent.gold * 0.1);
        player.gold += goldStolen;
        opponent.gold -= goldStolen;
        battleLog.push(`ðŸ’° Kamu mencuri *${goldStolen}* Gold dari lawan!`);
    }
    
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    alip.sendMessage(m.chat, { text: battleLog.join('\n'), mentions: [m.sender, targetJid] });
}
break;

case 'leaderboardrpg': case 'lb_rpg': {
    const players = Object.entries(rpgDB.players);
    if (players.length < 1) return Reply("Belum ada petualang di dunia ini.");

    // Leaderboard Level
    const sortedByLevel = players.sort(([,a], [,b]) => b.level - a.level || b.exp - a.exp).slice(0, 5);
    let levelLbText = "ðŸ† *Top 5 Petualang (Level)* ðŸ†\n\n";
    let mentions = [];

    sortedByLevel.forEach(([jid, player]) => {
        levelLbText += `â€º @${jid.split('@')[0]} - *Lv. ${player.level}*\n`;
        mentions.push(jid);
    });

    // Kirim dengan gaya rich preview WhatsApp (tapi teks tetap leaderboard)
    alip.sendMessage(m.chat, {
        text: levelLbText,
        mentions: mentions,
        contextInfo: {
            externalAdReply: {
                title: `ðŸ¹ Petualang Terkuat`,
                body: `Leaderboard RPG`,
                thumbnailUrl: global.image.menu, // pastikan sudah diatur
                sourceUrl: `https://wa.me/${m.sender.split('@')[0]}`,
                mediaType: 1,
                renderLargerThumbnail: true,
                showAdAttribution: false
            }
        }
    }, { quoted: m });
}
break;

    
    //================= [ RPG - USE ITEM IN BATTLE ] =================//
case 'item': {
    // Cek apakah pemain sudah terdaftar di RPG
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    const player = rpgDB.players[m.sender];

    // Cek apakah pemain sedang dalam pertarungan
    if (!player.battleState || !player.battleState.inBattle) {
      return Reply(`Perintah ini hanya bisa digunakan saat bertarung! Gunakan *.rpginv* untuk melihat item di luar pertarungan.`);
    }
    
    // Jika pengguna hanya mengetik .item, tampilkan daftar item yang bisa digunakan
    if (!text) {
      const usableItems = Object.keys(player.inventory).filter(itemId => {
        const itemData = rpgDB.items[itemId];
        // Hanya tampilkan item dengan tipe 'heal' atau 'mana'
        return itemData && (itemData.type === 'heal' || itemData.type === 'mana');
      });

      if (usableItems.length === 0) {
        return Reply("ðŸŽ’ Kamu tidak punya item yang bisa digunakan dalam pertarungan.");
      }

      let itemListText = "ðŸŽ’ *Item yang bisa digunakan:*\n\n";
      usableItems.forEach(itemId => {
        itemListText += `â€º ${rpgDB.items[itemId].name} (x${player.inventory[itemId]})\n`;
      });
      itemListText += "\n\n*Gunakan dengan:* .item [nama_item]";
      return Reply(itemListText);
    }
    
    // Jika pengguna mengetik .item <nama_item>
    const itemId = text.toLowerCase().trim();
    const battleState = player.battleState;

    if (!player.inventory[itemId] || player.inventory[itemId] < 1) {
      return Reply(`âŒ Kamu tidak memiliki item "${itemId}"!`);
    }
    
    const item = rpgDB.items[itemId];
    if (!item || (item.type !== 'heal' && item.type !== 'mana')) {
      return Reply(`âŒ Item "${item.name}" tidak dapat digunakan dalam pertarungan!`);
    }

    // Terapkan efek item
    let useText = `âœ… Kamu menggunakan ${item.name}!\n`;
    switch (item.type) {
      case 'heal':
        player.hp = Math.min(player.maxHp, player.hp + item.value);
        useText += `â¤ï¸ HP pulih sebesar ${item.value} poin! (HP saat ini: ${player.hp}/${player.maxHp})`;
        break;
      case 'mana':
        player.mp = Math.min(player.maxMp, player.mp + item.value);
        useText += `ðŸ”µ MP pulih sebesar ${item.value} poin! (MP saat ini: ${player.mp}/${player.maxMp})`;
        break;
    }

    // Kurangi item dari inventory
    player.inventory[itemId] -= 1;
    if (player.inventory[itemId] <= 0) {
      delete player.inventory[itemId];
    }
    
    let battleLog = [useText];
    
    // Setelah menggunakan item, monster menyerang balik (giliran pemain habis)
    const monsterDamage = calculateDamage(battleState.monster, player);
    player.hp -= monsterDamage.damage;
    battleLog.push(`\nâš”ï¸ Giliranmu berakhir! ${battleState.monster.name} menyerang balik dan kamu menerima ${monsterDamage.damage} damage!`);

    // Cek apakah pemain kalah setelah diserang
    if (player.hp <= 0) {
      battleLog.push(`\nðŸ’€ Kamu dikalahkan oleh ${battleState.monster.name}!`);
      player.hp = 1; // Pemain tidak mati, hanya HP jadi 1
      player.gold = Math.max(0, player.gold - 20); // Kena penalti
      battleLog.push("Kamu kehilangan 20 Gold.");
      delete player.battleState; // Pertarungan berakhir
    }

    // Simpan perubahan ke database
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    return Reply(battleLog.join('\n'));
    break;
  }
  

case 'rpgstart': {
        if (rpgDB.players[m.sender]) {
            return Reply(`Kamu sudah memulai petualangan! Gunakan *.rpgstats* untuk melihat statistikmu.`);
        }
        if (!text) {
            return Reply(`ðŸŽ® *Pilih Class Karaktermu:*\n\n1. Warrior âš”ï¸ (HP & Defense Tinggi)\n2. Mage ðŸ”¥ (Serangan Sihir Kuat)\n3. Archer ðŸ¹ (Agility & Critical Tinggi)\n\n*Gunakan: .rpgstart [class]*\nContoh: .rpgstart warrior`);
        }
        const classChoice = text.toLowerCase();
        if (!['warrior', 'mage', 'archer'].includes(classChoice)) {
            return Reply(`Class tidak valid. Pilih: warrior, mage, atau archer.`);
        }
        rpgDB.players[m.sender] = initPlayerRPG(m.sender, classChoice);
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(`ðŸŽ‰ *Selamat!* Kamu memulai petualangan sebagai *${classChoice.toUpperCase()}*. Gunakan *.rpghelp* untuk melihat daftar perintah.`);
    }
    break;
  

case 'rpgstats': {
    if (!rpgDB.players[m.sender]) {
        return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
    }
    const player = rpgDB.players[m.sender];
    const totalStats = getPlayerTotalStats(player);
    const weaponName = player.equipment.weapon ? rpgDB.items[player.equipment.weapon].name : 'Kosong';
    const armorName = player.equipment.armor ? rpgDB.items[player.equipment.armor].name : 'Kosong';

    const statsText = `
ðŸ“Š *STATISTIK PLAYER*
    
ðŸ‘¤ Class: ${player.class.toUpperCase()}
â­ Level: ${player.level}
ðŸ“ˆ EXP: ${player.exp}/${player.expToNextLevel}
âš”ï¸ PvP: ${player.pvpWins} Menang / ${player.pvpLosses} Kalah

â¤ï¸ HP: ${player.hp}/${player.maxHp}
ðŸ”µ MP: ${player.mp}/${player.maxMp}

âš”ï¸ Attack: ${player.attack} (+${totalStats.attack - player.attack})
ðŸ›¡ï¸ Defense: ${player.defense} (+${totalStats.defense - player.defense})
ðŸŒ€ Agility: ${player.agility}

ðŸ’° Gold: ${player.gold}
ðŸ“ Lokasi: ${rpgDB.locations[player.location].name}

*EQUIPMENT*
ðŸ—¡ï¸ Senjata: ${weaponName}
ðŸ¥‹ Zirah: ${armorName}
    `;
    return Reply(statsText);
}
break;

  
    case 'rpgexplore': {
        if (!rpgDB.players[m.sender]) return Reply(`Kamu belum memulai petualangan! Ketik *.rpgstart*.`);
        const player = rpgDB.players[m.sender];
        if (Date.now() - player.lastBattle < 30000) {
            const cooldown = Math.ceil((30000 - (Date.now() - player.lastBattle)) / 1000);
            return Reply(`Kamu masih lelah! Tunggu ${cooldown} detik lagi.`);
        }
        const monster = getRandomMonster(player.location);
        if (!monster) return Reply(`Tidak ada monster di lokasi ini!`);
        
        player.battleState = {
            monster: monster,
            monsterHp: monster.hp,
            inBattle: true
        };
        player.lastBattle = Date.now();
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

        const battleText = `
âš”ï¸ *PERTEMPURAN DIMULAI!*

Kamu bertemu: *${monster.name}* (Level ${monster.level})
â¤ï¸ HP Musuh: ${monster.hp}/${monster.hp}

Gunakan perintah:
*.attack* - Serangan biasa
*.skill* - Serangan khusus class
*.flee* - Kabur
        `;
        return Reply(battleText);
    }
    break;
    

case "swgcall": {
if (!isCreator) return Reply(mess.owner)
    const quoted = m.quoted ? m.quoted : m;
    const mime = (quoted.msg || quoted).mimetype || "";
    const caption = m.body.replace(/^\.swgcall\s*/i, "").trim();

    try {
        if (/image|video|audio/.test(mime)) {
            const buffer = await quoted.download();
            global.swgcBuffer = global.swgcBuffer || {};
            global.swgcBuffer[m.sender] = { buffer, mime, caption };
        } else if (caption) {
            global.swgcBuffer = global.swgcBuffer || {};
            global.swgcBuffer[m.sender] = { buffer: null, mime: "text", caption };
        } else {
            return Reply(`âš ï¸ _Kirim/Balas gambar/video dengan caption *${prefix}swgc*_`);
        }

        await m.reply("â³ Mengambil daftar grup, mohon tunggu...");

        const allGroups = await alip.groupFetchAllParticipating();
        const groupList = Object.values(allGroups);

        if (groupList.length === 0) return Reply("âŒ Bot tidak berada di dalam grup manapun.");

        const rows = groupList.map(g => ({
            title: g.subject,
            description: `Anggota: ${g.participants.length} | Status: ${g.announce == false ? "Terbuka" : "Hanya Admin"}`,
            id: `${prefix}swgc_process ${g.id}`
        }));

        await alip.sendMessage(m.chat, {
    image: { url: global.image.menu },
    caption: `*SWGC - CONTROLLER*\nðŸ“Š *Total Grup : ${groupList.length}*`,
    footer: `Pilih opsi di bawah untuk melanjutkan`,
    buttons: [
                {
                    buttonId: 'swgc_pilih',
                    buttonText: { displayText: 'ðŸ“¥ Pilih Grup' },
                    type: 4,
                    nativeFlowInfo: {
                        name: 'single_select',
                        paramsJson: JSON.stringify({
                            title: 'SWGC',
                            sections: [
                                {
                                    title: 'Daftar Grup Bot',
                                    rows: rows
                                }
                            ]
                        })
                    }
                },
                {
                    buttonId: `${prefix}swgc_allprocess`,
                    buttonText: { displayText: 'ðŸš€ Kirim Ke Semua' },
                    type: 1
                }
            ],
            headerType: 4,
            viewOnce: true,
            contextInfo: {
                isForwarded: false,
                mentionedJid: [m.sender]
            }
        }, { quoted: m });

    } catch (error) {
        console.error('[SWGC ERROR]', error);
        Reply("âŒ Gagal menampilkan daftar grup.");
    }
}
break;

case "swgc_process": {
if (!isCreator) return Reply(mess.owner)
    if (!text) return Reply("âŒ Data tidak lengkap.");
    const groupId = text.split("|")[0];

    const data = global.swgcBuffer ? global.swgcBuffer[m.sender] : null;
    if (!data) return Reply("âŒ Media tidak tersedia, reply dulu media yang mau dikirim!");

    try {
        if (/image/.test(data.mime)) {
            await alip.sendMessage(groupId, { groupStatusMessage: { image: data.buffer, caption: data.caption } });
        } else if (/video/.test(data.mime)) {
            await alip.sendMessage(groupId, { groupStatusMessage: { video: data.buffer, caption: data.caption } });
        } else if (/audio/.test(data.mime)) {
            await alip.sendMessage(groupId, { groupStatusMessage: { audio: data.buffer } });
        } else if (data.mime === "text" && data.caption) {
            await alip.sendMessage(groupId, { groupStatusMessage: { text: data.caption } });
        } else {
            return Reply(`âš ï¸ _Kirim/Balas gambar/video dengan caption *${prefix}swgc*_`);
        }

        delete global.swgcBuffer[m.sender];

        await Reply(`âœ… Berhasil mengirim status ke grup: ${groupId}`);
    } catch (error) {
        console.error('[SWGC PROCESS ERROR]', error);
        Reply("âŒ Gagal mengirim status ke grup.");
    }
}
break;

case "swgc_allprocess": {
if (!isCreator) return Reply(mess.owner)
    const data = global.swgcBuffer ? global.swgcBuffer[m.sender] : null;
    if (!data) return Reply("âŒ Tidak ada media tersimpan. Gunakan .swgc dulu!");
    
    try {
        await m.reply("â³ *Memproses upload status ke semua grup...*");
        
        const allGroups = await alip.groupFetchAllParticipating();
        const groupList = Object.values(allGroups);
        
        if (groupList.length === 0) return m.reply("âŒ Bot tidak ada di grup manapun!");
        
        let success = 0;
        let failed = 0;
        let processed = 0;
        
        for (const group of groupList) {
            const jid = group.id;
            processed++;
            
            try {
                if (/image/.test(data.mime)) {
                    await alip.sendMessage(jid, { groupStatusMessage: { image: data.buffer, caption: data.caption } });
                } else if (/video/.test(data.mime)) {
                    await alip.sendMessage(jid, { groupStatusMessage: { video: data.buffer, caption: data.caption } });
                } else if (/audio/.test(data.mime)) {
                    await alip.sendMessage(jid, { groupStatusMessage: { audio: data.buffer } });
                } else if (data.mime === "text" && data.caption) {
                    await alip.sendMessage(jid, { groupStatusMessage: { text: data.caption } });
                }
                
                success++;
                await sleep(800);
                
            } catch (e) {
                failed++;
                console.error(`Gagal kirim ke ${jid}:`, e.message);
            }
        }
        
        delete global.swgcBuffer[m.sender];
        
        await m.reply(`âœ… *Status berhasil diunggah ke ${success} grup!*\n\nðŸ“Š *Ringkasan:*\nâ€¢ Total grup: ${groupList.length}\nâ€¢ Berhasil: ${success}\nâ€¢ Gagal: ${failed}\nâ€¢ Diproses: ${processed}`);
        
    } catch (e) {
        console.error('[SWGC ALLPROCESS ERROR]', e);
        m.reply("âŒ Terjadi kesalahan saat mengunggah status ke semua grup.");
    }
}
break;

case "swgc": {
  if (!isCreator && !m.isAdmin) return m.reply("âŒ buat admin sama owner anj!");
  const quoted = m.quoted ? m.quoted : m;
  const mime = (quoted.msg || quoted).mimetype || "";
  const caption = m.body.replace(/^\.swgc\s*/i, "").trim();
  const jid = m.chat;

  if (!mime && !caption) return m.reply(`*Example:*\n.swgc teks status\n.swgc reply gambar\n.swgc reply video\n.swgc reply audio`);

  try {
    m.reply("â³ *Memproses upload status...*");
    
    if (/image/.test(mime)) {
      const buffer = await quoted.download();
      await alip.sendMessage(jid, { groupStatusMessage: { image: buffer, caption } });
      m.reply("âœ… *Status gambar berhasil diunggah ke grup!*");
    } 
    else if (/video/.test(mime)) {
      const buffer = await quoted.download();
      await alip.sendMessage(jid, { groupStatusMessage: { video: buffer, caption } });
      m.reply("âœ… *Status video berhasil diunggah ke grup!*");
    } 
    else if (/audio/.test(mime)) {
      const buffer = await quoted.download();
      await alip.sendMessage(jid, { groupStatusMessage: { audio: buffer } });
      m.reply("âœ… *Status audio berhasil diunggah ke grup!*");
    } 
    else if (caption) {
      await alip.sendMessage(jid, { groupStatusMessage: { text: caption } });
      m.reply("âœ… *Status teks berhasil diunggah ke grup!*");
    } 
  } catch (e) {
    console.error("swgc", e);
    m.reply("âŒ Terjadi kesalahan saat mengunggah status grup.");
  }
}
break;
  
  //================= [ RPG - SKILL, FLEE, SELL ] =================//

// MODIFIKASI CASE SKILL ANDA, TAMBAHKAN BLOK KODE UNTUK PET
case 'skill': {
    if (!rpgDB.players[m.sender]?.battleState?.inBattle) return Reply(`Kamu tidak sedang dalam pertempuran!`);

    const player = rpgDB.players[m.sender];
    const battleState = player.battleState;
    let battleLog = [];
    let skillUsed = false;

    // ... (kode skill warrior, mage, archer Anda yang sudah ada tetap di sini)
    switch (player.class) {
        case 'warrior':
            if (player.mp < 15) return Reply("ðŸ”µ MP tidak cukup untuk Rage Slash! (Butuh 15 MP)");
            player.mp -= 15;
            player.hp -= 5; // Self damage
            const warriorDamage = Math.floor(getPlayerTotalStats(player).attack * 2.5);
            battleState.monsterHp -= warriorDamage;
            skillUsed = true;
            battleLog.push(`âš”ï¸ Kamu menggunakan *Rage Slash*! Kamu menerima 5 damage, tetapi menyerang ${battleState.monster.name} sebesar *${warriorDamage}* damage!`);
            break;
        case 'mage':
            if (player.mp < 20) return Reply("ðŸ”µ MP tidak cukup untuk Fireball! (Butuh 20 MP)");
            player.mp -= 20;
            const mageDamage = Math.floor(getPlayerTotalStats(player).attack * 2); // Magic damage ignores some defense
            battleState.monsterHp -= mageDamage;
            skillUsed = true;
            battleLog.push(`ðŸ”¥ Kamu merapal *Fireball*! ${battleState.monster.name} terbakar dan menerima *${mageDamage}* magic damage!`);
            break;
        case 'archer':
            if (player.mp < 15) return Reply("ðŸ”µ MP tidak cukup untuk Precision Shot! (Butuh 15 MP)");
            player.mp -= 15;
            const isCritical = Math.random() < 0.75; // 75% critical chance
            const archerStats = getPlayerTotalStats(player);
            let archerDamage = Math.max(1, Math.floor(archerStats.attack - battleState.monster.defense));
            if (isCritical) archerDamage *= 2;
            battleState.monsterHp -= archerDamage;
            skillUsed = true;
            battleLog.push(`ðŸ¹ Kamu menggunakan *Precision Shot*!`);
            if (isCritical) battleLog.push(`ðŸ’¥ *CRITICAL HIT!*`);
            battleLog.push(`Panahmu mengenai ${battleState.monster.name} sebesar *${archerDamage}* damage!`);
            break;
    }


    if (skillUsed) {
        // âœ¨ PENAMBAHAN: Serangan Pet setelah skill
        if (player.pet?.attack > 0 && battleState.monsterHp > 0) {
            const petDamage = player.pet.attack;
            battleState.monsterHp -= petDamage;
            battleLog.push(`ðŸ¾ Pet-mu, *${player.pet.name}*, ikut menyerang dan memberikan *${petDamage}* damage tambahan!`);
        }

        if (battleState.monsterHp <= 0) {
            // ... (kode jika monster kalah, sama seperti yang sudah Anda punya)
            battleLog.push(`\nðŸŽ‰ Kamu mengalahkan *${battleState.monster.name}*!`);
            // (sisa kode reward sama seperti case 'attack')
            delete player.battleState;
        } else {
             // ... (kode jika monster menyerang balik, sama seperti yang sudah Anda punya)
             const monsterDamage = calculateDamage(battleState.monster, player);
             player.hp -= monsterDamage.damage;
             battleLog.push(`\n${battleState.monster.name} menyerang balik! Kamu menerima *${monsterDamage.damage}* damage.`);
             battleLog.push(`â¤ï¸ HP Kamu: ${player.hp}/${player.maxHp} | â¤ï¸ HP Musuh: ${battleState.monsterHp}/${battleState.monster.hp}`);
             if (player.hp <= 0) {
                 battleLog.push(`\nðŸ’€ Kamu dikalahkan! Kamu kehilangan 10 Gold.`);
                 player.hp = 1;
                 player.gold = Math.max(0, player.gold - 10);
                 delete player.battleState;
             }
        }
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(battleLog.join('\n'));
    }
}
break;

case 'flee': {
    if (!rpgDB.players[m.sender] || !rpgDB.players[m.sender].battleState || !rpgDB.players[m.sender].battleState.inBattle) {
      return Reply(`Kamu tidak sedang dalam pertempuran!`);
    }

    const player = rpgDB.players[m.sender];
    const monster = player.battleState.monster;
    
    // Chance to flee is based on player's agility vs monster's level
    const fleeChance = (player.agility / (player.agility + monster.level * 5)); 
    
    if (Math.random() < fleeChance) {
        // Flee successful
        delete player.battleState;
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(`ðŸƒâ€â™‚ï¸ Kamu berhasil kabur dari ${monster.name}!`);
    } else {
        // Flee failed, monster gets a free hit
        const monsterDamage = calculateDamage(monster, player);
        player.hp -= monsterDamage.damage;
        
        let battleLog = [`âŒ Gagal kabur! ${monster.name} menyerangmu saat mencoba lari, menerima ${monsterDamage.damage} damage!`];

        if (player.hp <= 0) {
            battleLog.push(`ðŸ’€ Kamu dikalahkan saat mencoba kabur!`);
            player.hp = 1;
            player.gold = Math.max(0, player.gold - 20);
            battleLog.push(`Kamu kehilangan 20 Gold.`);
            delete player.battleState;
        }

        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        return Reply(battleLog.join('\n'));
    }
    break;
}

case 'sell': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    if (!text) {
      return Reply(`Gunakan: .sell [nama_item] [jumlah]\nContoh: .sell potion 1\nGunakan *.rpginv* untuk melihat item-mu.`);
    }
    
    const player = rpgDB.players[m.sender];
    const args = text.trim().split(" ");
    const itemId = args[0].toLowerCase();
    const amount = parseInt(args[1]) || 1;

    if (!player.inventory[itemId] || player.inventory[itemId] < amount) {
      return Reply(`Kamu tidak memiliki ${amount} ${itemId} di inventory!`);
    }
    
    if (!rpgDB.items[itemId]) {
      return Reply(`Item tidak valid!`);
    }

    const item = rpgDB.items[itemId];
    const sellPrice = Math.floor(item.price * 0.5) * amount; // Sell price is 50% of buy price

    player.gold += sellPrice;
    player.inventory[itemId] -= amount;

    if (player.inventory[itemId] <= 0) {
      delete player.inventory[itemId];
    }
    
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    return Reply(`âœ… Berhasil menjual ${amount} ${item.name} seharga ${sellPrice} Gold!\nSisa Gold: ${player.gold}`);
    break;
  }

case 'inventory':
    // This is an alias for 'rpginv'
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    const playerForInv = rpgDB.players[m.sender];
    let inventoryText = `ðŸŽ’ *INVENTORY*\n\n`;
    
    if (Object.keys(playerForInv.inventory).length === 0) {
      inventoryText += `Inventory kosong!`;
    } else {
      for (const [itemId, quantity] of Object.entries(playerForInv.inventory)) {
        if (rpgDB.items[itemId]) {
          inventoryText += `â€º ${rpgDB.items[itemId].name} x${quantity}\n`;
        }
      }
    }
    
    inventoryText += `\nðŸ’° Gold: ${playerForInv.gold}`;
    
    return Reply(inventoryText);
    break;

//================= [ RPG - MANCING MINIGAME ] =================//

case 'mancingstart': {
    const jid = m.sender;
    if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
    let player = rpgDB.players[jid];

    if (!player.fishing) {
        player.fishing = { isFishing: false, lastCatch: 0 };
    }

    player.fishing.isFishing = true;
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    Reply(`ðŸŽ£ Kamu telah menyiapkan pancingan di tepi danau. Gunakan command *.mancing* untuk melempar umpan!`);
    break;
}

case 'mancing': {
    const jid = m.sender;
    if (!rpgDB.players[jid] || !rpgDB.players[jid].fishing || !rpgDB.players[jid].fishing.isFishing) {
        return Reply("Kamu belum mulai memancing. Ketik *.mancingstart* dulu.");
    }
    let player = rpgDB.players[jid];

    const cooldown = 60000; // 1 menit cooldown
    if (Date.now() - player.fishing.lastCatch < cooldown) {
        const timeLeft = Math.ceil((cooldown - (Date.now() - player.fishing.lastCatch)) / 1000);
        return Reply(`Kamu harus menunggu ${timeLeft} detik lagi sebelum bisa memancing lagi.`);
    }
    
    const possibleCatches = [
        { name: 'Ikan Lele', gold: 15, exp: 10, msg: "Kamu mendapatkan Ikan Lele yang lumayan besar!" },
        { name: 'Ikan Nila', gold: 10, exp: 7, msg: "Seekor Ikan Nila berhasil kamu tangkap." },
        { name: 'Sepatu Butut', gold: 1, exp: 1, msg: "Sial, yang nyangkut malah sepatu butut." },
        { name: 'Sampah Plastik', gold: 0, exp: 1, msg: "Huft, cuma dapat sampah. Setidaknya kamu membersihkan danau." },
        { name: 'Harta Karun Kecil', gold: 100, exp: 30, msg: "WOW! Kamu menemukan sebuah kotak berisi harta karun kecil!" },
        { name: 'Ikan Mas', gold: 25, exp: 15, msg: "Kailmu disambar Ikan Mas berwarna keemasan!" },
    ];

    let caught = possibleCatches[Math.floor(Math.random() * possibleCatches.length)];
    player.gold += caught.gold;
    let leveledUp = gainExp(player, caught.exp);
    player.fishing.lastCatch = Date.now();
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

    let replyMsg = `ðŸŽ£ *Hasil Mancing*\n\n${caught.msg}\n\n*Hadiah:*\nðŸ’° Gold +${caught.gold}\nâ­ EXP +${caught.exp}`;
    if (leveledUp) {
        replyMsg += `\n\nðŸŽ‰ *LEVEL UP!* Kamu sekarang Level ${player.level}!`;
    }
    Reply(replyMsg);
    break;
}
  
// GANTI CASE ATTACK LAMA ANDA DENGAN INI
case 'attack': {
    if (!rpgDB.players[m.sender]?.battleState?.inBattle) return Reply(`Kamu tidak sedang dalam pertempuran!`);
    
    const player = rpgDB.players[m.sender];
    const battleState = player.battleState;
    
    const playerDamage = calculateDamage(player, battleState.monster);
    battleState.monsterHp -= playerDamage.damage;
    
    let battleLog = [`Kamu menyerang ${battleState.monster.name} sebesar *${playerDamage.damage}* damage!`];
    if (playerDamage.isCritical) battleLog.push(`ðŸ’¥ *CRITICAL HIT!*`);
    
    // âœ¨ PENAMBAHAN: Serangan Pet
    if (player.pet?.attack > 0) {
        const petDamage = player.pet.attack;
        battleState.monsterHp -= petDamage;
        battleLog.push(`ðŸ¾ Pet-mu, *${player.pet.name}*, menyerang dan memberikan *${petDamage}* damage tambahan!`);
    }

    if (battleState.monsterHp <= 0) {
        // ... (sisanya sama seperti kode attack Anda yang sudah ada)
        battleLog.push(`ðŸŽ‰ Kamu mengalahkan *${battleState.monster.name}*!`);
        player.gold += battleState.monster.gold;
        const leveledUp = gainExp(player, battleState.monster.exp);
        player.monstersDefeated += 1;
        battleLog.push(`ðŸ’° Mendapat *${battleState.monster.gold} Gold* & â­ *${battleState.monster.exp} EXP*`);
        if (leveledUp) battleLog.push(`ðŸŽŠ *LEVEL UP!* Kamu sekarang Level ${player.level}!`);
        delete player.battleState;
    } else {
        const monsterDamage = calculateDamage(battleState.monster, player);
        player.hp -= monsterDamage.damage;
        battleLog.push(`\n${battleState.monster.name} menyerang balik! Kamu menerima *${monsterDamage.damage}* damage.`);
        battleLog.push(`â¤ï¸ HP Kamu: ${player.hp}/${player.maxHp} | â¤ï¸ HP Musuh: ${battleState.monsterHp}/${battleState.monster.hp}`);
        
        if (player.hp <= 0) {
            battleLog.push(`\nðŸ’€ Kamu dikalahkan! Kamu kehilangan 10 Gold.`);
            player.hp = 1;
            player.gold = Math.max(0, player.gold - 10);
            delete player.battleState;
        }
    }
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    return Reply(battleLog.join('\n'));
}
break;

  
  case 'rpgmove': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    if (!text) {
      const player = rpgDB.players[m.sender];
      const locationsList = Object.entries(rpgDB.locations)
        .map(([id, loc]) => {
          const canAccess = player.level >= loc.minLevel && player.level <= loc.maxLevel;
          return `${canAccess ? 'âœ…' : 'âŒ'} ${loc.name} (Level ${loc.minLevel}-${loc.maxLevel}) - .rpgmove ${id}`;
        })
        .join('\n');
      
      return Reply(`ðŸ—ºï¸ *DAFTAR LOKASI*\n\n${locationsList}\n\nLokasi saat ini: ${rpgDB.locations[player.location].name}`);
    }
    
    const player = rpgDB.players[m.sender];
    const locationId = text.toLowerCase();
    
    if (!rpgDB.locations[locationId]) {
      return Reply(`Lokasi tidak ditemukan! Gunakan *.rpgmove* tanpa parameter untuk melihat daftar lokasi.`);
    }
    
    const targetLocation = rpgDB.locations[locationId];
    
    if (player.level < targetLocation.minLevel) {
      return Reply(`Level kamu belum cukup! Diperlukan Level ${targetLocation.minLevel} untuk memasuki ${targetLocation.name}.`);
    }
    
    if (player.level > targetLocation.maxLevel) {
      return Reply(`Lokasi ini terlalu mudah untukmu! Level maksimum untuk ${targetLocation.name} adalah ${targetLocation.maxLevel}.`);
    }
    
    player.location = locationId;
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    
    return Reply(`ðŸš¶â€â™‚ï¸ Kamu berpindah ke ${targetLocation.name}!`);
    break;
  }
  
  case 'rpginv':
  case 'rpg inventory': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    const player = rpgDB.players[m.sender];
    let inventoryText = `ðŸŽ’ *INVENTORY*\n\n`;
    
    if (Object.keys(player.inventory).length === 0) {
      inventoryText += `Inventory kosong!`;
    } else {
      for (const [itemId, quantity] of Object.entries(player.inventory)) {
        if (rpgDB.items[itemId]) {
          inventoryText += `${rpgDB.items[itemId].name} x${quantity}\n`;
        }
      }
    }
    
    inventoryText += `\nðŸ’° Gold: ${player.gold}`;
    
    if (player.equipment.weapon) {
      inventoryText += `\n\nâš”ï¸ Senjata: ${rpgDB.items[player.equipment.weapon].name}`;
    }
    if (player.equipment.armor) {
      inventoryText += `\nðŸ›¡ï¸ Armor: ${rpgDB.items[player.equipment.armor].name}`;
    }
    
    return Reply(inventoryText);
    break;
  }
  
  case 'rpgshop': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    const player = rpgDB.players[m.sender];
    let shopText = `ðŸ›’ *TOKO RPG*\n\n`;
    
    for (const [itemId, item] of Object.entries(rpgDB.items)) {
      shopText += `${item.name} - ${item.price} Gold\nGunakan: .buy ${itemId}\n\n`;
    }
    
    shopText += `ðŸ’° Gold kamu: ${player.gold}\n\nUntuk menjual item, gunakan: .sell [item]`;
    
    return Reply(shopText);
    break;
  }
  
  case 'buy': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG!`);
    }
    
    if (!text) {
      return Reply(`Gunakan: .buy [nama_item]\nContoh: .buy potion`);
    }
    
    const player = rpgDB.players[m.sender];
    const itemId = text.toLowerCase().replace(/ /g, '_'); // Mengganti spasi dengan underscore
    
    if (!rpgDB.items[itemId]) {
      return Reply(`Item tidak ditemukan! Gunakan *.rpgshop*`);
    }
    
    const item = rpgDB.items[itemId];
    
    if (player.gold < item.price) {
      return Reply(`Gold tidak cukup! Butuh ${item.price} Gold.`);
    }
    
    player.gold -= item.price;

    // --- LOGIKA BARU UNTUK MEMBELI LIMIT ---
    if (item.type === 'bot_feature') {
        const bonusDB = safeReadJSON(limitBonusPath, {});
        const today = getWIBTime().toISOString().split('T')[0];
        
        if (!bonusDB[m.sender] || bonusDB[m.sender].date !== today) {
            bonusDB[m.sender] = { bonus: 0, date: today };
        }
        
        bonusDB[m.sender].bonus += item.value; // Menambah bonus limit
        fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));
        
        // Simpan perubahan gold di rpgDB
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        
        return Reply(`âœ… Berhasil membeli *${item.name}* seharga ${item.price} Gold!\nKamu mendapatkan +${item.value} limit bonus untuk hari ini.`);

    } else {
        // Logika untuk item RPG biasa
        player.inventory[itemId] = (player.inventory[itemId] || 0) + 1;
        fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
        
        return Reply(`âœ… Berhasil membeli ${item.name} seharga ${item.price} Gold!`);
    }
    break;
}

  
  case 'use': {
    if (!rpgDB.players[m.sender]) {
      return Reply(`Kamu belum memulai petualangan RPG! Ketik *.rpgstart* untuk memulai.`);
    }
    
    if (!text) {
      return Reply(`Gunakan: .use [nama_item]\nContoh: .use potion`);
    }
    
    const player = rpgDB.players[m.sender];
    const itemId = text.toLowerCase();
    
    if (!player.inventory[itemId] || player.inventory[itemId] < 1) {
      return Reply(`Kamu tidak memiliki ${itemId} di inventory!`);
    }
    
    if (!rpgDB.items[itemId]) {
      return Reply(`Item tidak valid!`);
    }
    
    const item = rpgDB.items[itemId];
    let useText = `âœ… Menggunakan ${item.name}...\n`;
    
    switch (item.type) {
      case 'heal':
        player.hp = Math.min(player.maxHp, player.hp + item.value);
        useText += `â¤ï¸ HP pulih ${item.value} point! (${player.hp}/${player.maxHp})`;
        break;
      case 'mana':
        player.mp = Math.min(player.maxMp, player.mp + item.value);
        useText += `ðŸ”µ MP pulih ${item.value} point! (${player.mp}/${player.maxMp})`;
        break;
      default:
        useText += `Item ini tidak dapat digunakan!`;
        break;
    }
    
    player.inventory[itemId] -= 1;
    if (player.inventory[itemId] <= 0) {
      delete player.inventory[itemId];
    }
    
    fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));
    return Reply(useText);
    break;
  }
  
    case 'rpghelp': {
        const helpText = `
ðŸŽ® *BANTUAN COMMAND RPG*

*DASAR*
.rpgstart - Memulai petualangan RPG
.rpgstats - Melihat statistik karakter
.rpginv - Melihat inventory & equipment
.rpgshop - Membuka toko
.rpgmove - Pindah lokasi
.rpgexplore - Mencari musuh di lokasi

*PERLENGKAPAN*
.equip [item] - Memakai senjata/zirah
.unequip [weapon/armor] - Melepas senjata/zirah
.buy [item] - Membeli item
.sell [item] - Menjual item
.use [item] - Menggunakan item (Potion/Elixir)

*PERTEMPURAN*
.attack - Serangan biasa
.skill - Serangan khusus sesuai class
.flee - Kabur dari pertempuran
        `;
        return Reply(helpText);
    }
    break;

case 'setwelcome': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('âŒ Fitur ini khusus untuk admin grup.');
  if (!text) return Reply('âŒ Masukkan teks welcome!\nContoh:\n.setwelcome Halo @user, selamat datang di @group!');

  if (!welcomeDB[m.chat]) welcomeDB[m.chat] = {};
  welcomeDB[m.chat].welcomeText = text;

  fs.writeFileSync(welcomePath, JSON.stringify(welcomeDB, null, 2));
  Reply('âœ… Teks welcome berhasil disimpan!');
}
break;

case 'setleft': {
  if (!m.isGroup) return Reply('Fitur ini hanya untuk grup.');
  if (!m.isAdmin && !isCreator) return Reply('âŒ Fitur ini khusus untuk admin grup.');
  if (!text) return Reply('âŒ Masukkan teks left!\nContoh:\n.setleft Selamat tinggal @user, makasih udah jadi bagian dari @group ðŸ‘‹');

  if (!leftDB[m.chat]) leftDB[m.chat] = {};
  leftDB[m.chat].leftText = text;

  fs.writeFileSync(leftFile, JSON.stringify(leftDB, null, 2));
  Reply('âœ… Teks left berhasil disimpan!');
}
break;

case 'kapanreset': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  // Waktu sekarang di WIB
  const now = new Date()
  const utc = now.getTime() + now.getTimezoneOffset() * 60000
  const wibNow = new Date(utc + 7 * 60 * 60000)

  // Hitung waktu ke jam 00:00 WIB berikutnya
  const nextMidnight = new Date(wibNow)
  nextMidnight.setHours(24, 0, 0, 0)
  const ms = nextMidnight - wibNow

  const hours = Math.floor(ms / 3600000)
  const minutes = Math.floor((ms % 3600000) / 60000)
  const seconds = Math.floor((ms % 60000) / 1000)

  Reply(`ðŸ•› *RESET LIMIT USER FREE*

Limit bot akan otomatis di *reset* setiap hari jam *00:00 WIB* (Waktu Indonesia Barat).

â³ *Sisa waktu menuju reset hari ini:*
ðŸ• *${hours} jam ${minutes} menit ${seconds} detik* lagi.

Setelah reset, kamu bisa akses bot menggunakan limit yang ada.`)
}
break;

case 'blacklist': {
    if (!isOwner) return Reply(mess.owner)

  let target = null

  if (m.isGroup) {
    if (m.mentionedJid && m.mentionedJid.length > 0) {
      const mentionedId = m.mentionedJid[0]
      if (mentionedId.endsWith('@lid')) {
        const participant = m.metadata.participants.find(x => x.id === mentionedId)
        target = participant ? participant.jid : mentionedId.replace('@lid', '@s.whatsapp.net')
      } else {
        target = mentionedId
      }
    } else if (m.quoted) {
      target = m.quoted.sender
    } else if (args[0]) {
      const number = args[0].replace(/[^0-9]/g, '')
      if (number.length >= 10) {
        target = number + '@s.whatsapp.net'
      }
    }
  } else {
    if (m.quoted) {
      target = m.quoted.sender
    } else if (args[0]) {
      const number = args[0].replace(/[^0-9]/g, '')
      if (number.length >= 10) {
        target = number + '@s.whatsapp.net'
      }
    }
  }

  if (!target) return Reply('ðŸš« Tag user, reply chat, atau ketik nomor yang mau di-blacklist.\nContoh: .blacklist @user\n.blacklist 628123456789')

  if (blacklist.some(b => areJidsSameUser(b, target))) {
    return Reply(`â— User @${target.split('@')[0]} sudah di blacklist.`, [target])
  }

  blacklist.push(target)
  fs.writeFileSync(blacklistPath, JSON.stringify(blacklist, null, 2))
  
  Reply(`âœ… Berhasil *BLACKLIST* user @${target.split('@')[0]}`, [target])
}
break

case 'unblacklist': {
    if (!isOwner) return Reply(mess.owner)

  let target = null

  if (m.isGroup) {
    if (m.mentionedJid && m.mentionedJid.length > 0) {
      const mentionedId = m.mentionedJid[0]
      if (mentionedId.endsWith('@lid')) {
        const participant = m.metadata.participants.find(x => x.id === mentionedId)
        target = participant ? participant.jid : mentionedId.replace('@lid', '@s.whatsapp.net')
      } else {
        target = mentionedId
      }
    } else if (m.quoted) {
      target = m.quoted.sender
    } else if (args[0]) {
      const number = args[0].replace(/[^0-9]/g, '')
      if (number.length >= 10) {
        target = number + '@s.whatsapp.net'
      }
    }
  } else {
    if (m.quoted) {
      target = m.quoted.sender
    } else if (args[0]) {
      const number = args[0].replace(/[^0-9]/g, '')
      if (number.length >= 10) {
        target = number + '@s.whatsapp.net'
      }
    }
  }

  if (!target) return Reply('ðŸš« Tag user, reply chat, atau ketik nomor yang mau dihapus dari blacklist.\nContoh: .unblacklist @user\n.unblacklist 628123456789')

  if (!blacklist.some(b => areJidsSameUser(b, target))) {
    return Reply(`â— User @${target.split('@')[0]} tidak ada di blacklist.`, [target])
  }

  blacklist = blacklist.filter(u => !areJidsSameUser(u, target))
  fs.writeFileSync(blacklistPath, JSON.stringify(blacklist, null, 2))
  
  Reply(`âœ… User @${target.split('@')[0]} sudah *DICABUT* dari blacklist.`, [target])
}
break

case 'jumlahuser':
case 'totaluser': {
  const fs = require('fs');
  const path = './library/database/user.json';

  // Pastikan file ada
  if (!fs.existsSync(path)) fs.writeFileSync(path, '[]');

  // Baca data user
  let users = [];
  try {
    users = JSON.parse(fs.readFileSync(path));
    if (!Array.isArray(users)) users = [];
  } catch (e) {
    users = [];
  }

  const total = users.length;
  const waktu = new Date().toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' });

  const teks = `â•­â”€â§™ *DAFTAR PENGGUNA* â§˜
â”‚ ðŸ‘¥ Total Terdaftar: *${total} user*
â”‚ ðŸ•’ Waktu Cek: ${waktu}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;

  alip.sendMessage(m.chat, {
    text: teks,
    contextInfo: {
      externalAdReply: {
        title: 'Daftar Pengguna Bot',
        body: `Bot ini sudah digunakan oleh ${total} user aktif.`,
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: global.linkOwner,
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

case 'afk': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    let alasan = text && text.trim().length > 0 ? text.trim() : 'Lagi ga aktif'

    const afkFile = './library/database/afk.json'
    const fs = require('fs')

    if (!fs.existsSync(afkFile)) fs.writeFileSync(afkFile, '[]')
    let afkData = JSON.parse(fs.readFileSync(afkFile))

    let afkUser = afkData.find(v => v.jid === m.sender)

    if (afkUser) {
        afkUser.reason = alasan
        afkUser.time = Date.now()
    } else {
        afkData.push({ jid: m.sender, reason: alasan, time: Date.now() })
    }

    fs.writeFileSync(afkFile, JSON.stringify(afkData, null, 2))

    await Reply(
        `ðŸ’¤ *MODE AFK AKTIF* ðŸ’¤\n\nðŸ“ Alasan: ${alasan}\n\n_Semua yang mention kamu akan diberitahu bahwa kamu sedang AFK_`
    );
}
break
  
// SEWA GRUP alip AI
case 'addsewagc': {
        if (!isOwner) return Reply(mess.owner)
    if (!text) return Reply(`âš ï¸ *Format Salah!*\n\nâ€¢ Di dalam grup: *${prefix + command} 30*\nâ€¢ Dari luar grup: *${prefix + command} https://chat.whatsapp.com/xxx 30*`);

    let groupId, groupName, days;
    let joinStatus = "âœ… Sudah di dalam grup";
    if (args[0].includes('chat.whatsapp.com')) {
        const link = args[0];
        days = parseInt(args[1]);

        if (isNaN(days)) return Reply(`âš ï¸ Masukkan jumlah hari!`);

        const inviteCode = link.split("chat.whatsapp.com/")[1].split("?")[0];

        try {
            try {
                const res = await alip.groupAcceptInvite(inviteCode);
                groupId = res; 
                joinStatus = "âœ… Berhasil join via link";
            } catch (e) {
                const meta = await alip.groupGetInviteInfo(inviteCode);
                groupId = meta.id;
                const groupMetadata = await alip.groupMetadata(groupId).catch(() => null);
                if (!groupMetadata) joinStatus = "â³ Pending (Bot belum masuk/menunggu acc admin)";
            }
        } catch (e) {
            return Reply(`âŒ Link tidak valid atau bot tidak bisa mengakses info grup.`);
        }
    } else if (!isNaN(args[0])) {
        if (!m.isGroup) return Reply(`âš ï¸ Jika hanya memasukkan durasi, perintah harus dilakukan di dalam grup!`);
        days = parseInt(args[0]);
        groupId = m.chat;
    } else {
        return Reply(`âš ï¸ *Format Salah!*\n\nâ€¢ Di dalam grup: *${prefix + command} 30*\nâ€¢ Dari luar grup: *${prefix + command} https://chat.whatsapp.com/xxx 30*`);
    }
    try {
        const meta = await alip.groupMetadata(groupId);
        groupName = meta.subject;
    } catch (e) {
        groupName = "Unknown Group";
    }
    let sewagrup = JSON.parse(fs.readFileSync(sewaPath));
    const now = Date.now();
    const durationMs = days * 24 * 60 * 60 * 1000;
    
    const existing = sewagrup.find(v => v.jid === groupId);
    let expiredDate;

    if (existing) {
        if (existing.expired > now) {
            existing.expired += durationMs;
        } else {
            existing.expired = now + durationMs;
        }
        existing.warningSent = false;
        expiredDate = existing.expired;
    } else {
        expiredDate = now + durationMs;
        sewagrup.push({ 
            jid: groupId, 
            expired: expiredDate, 
            warningSent: false 
        });
    }

    fs.writeFileSync(sewaPath, JSON.stringify(sewagrup, null, 2));

    Reply(
        `âœ… *Sewa Berhasil ${existing ? 'Diperpanjang' : 'Ditambahkan'}!*\n\n` +
        `ðŸ¢ *Grup:* ${groupName}\n` +
        `â±ï¸ *Durasi Tambahan:* ${days} Hari\n` +
        `ðŸ“… *Expired:* ${new Date(expiredDate).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n` +
        `â„¹ï¸ *Status Join:* ${joinStatus}`
    );
}
break;

case 'ceksewagc': {
  if (!m.isGroup) return Reply(`ðŸ‘¥ Perintah ini hanya untuk grup.`);
  if (m.chat === global.linkGrup) return Reply(`ðŸ“Œ Grup official selalu aktif, tidak perlu sewa.`);

  const sewagrup = JSON.parse(fs.readFileSync(sewaPath));
  const data = sewagrup.find(v => v.jid === m.chat);
  
  if (!data || Date.now() > data.expired) {
    return Reply(`âŒ Grup ini tidak terdaftar atau masa sewa sudah habis.`);
  }

  const sisaMs = data.expired - Date.now();
  const sisaHari = Math.floor(sisaMs / (1000 * 60 * 60 * 24));
  const sisaJam = Math.floor((sisaMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const sisaMenit = Math.floor((sisaMs % (1000 * 60 * 60)) / (1000 * 60));
  
  // Status Bar Keren
  const totalDays = 30; // Asumsi paket sebulan untuk visualisasi bar
  const progress = Math.min(Math.max((sisaHari / totalDays) * 100, 0), 100);
  const barLength = 10;
  const filledLength = Math.round((progress / 100) * barLength);
  const bar = 'â–ˆ'.repeat(filledLength) + 'â–‘'.repeat(barLength - filledLength);
  
  let statusIndicator = sisaHari < 3 ? 'ðŸ”´ KRITIS' : (sisaHari < 7 ? 'ðŸŸ¡ WASPADA' : 'ðŸŸ¢ AMAN');

  let teks = `â•­â”€â”€â”€ã€Œ *STATUS SEWA* ã€
â”‚
â”‚ ðŸ¢ *Grup:* ${m.metadata.subject}
â”‚ ðŸ“Š *Status:* ${statusIndicator}
â”‚
â”‚ â³ *Sisa Waktu:*
â”‚ ${sisaHari} Hari ${sisaJam} Jam ${sisaMenit} Menit
â”‚
â”‚ ðŸ“… *Kadaluarsa:*
â”‚ ${new Date(data.expired).toLocaleString('id-ID', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute:'2-digit' })}
â”‚
â”‚ [${bar}] ${Math.round(progress)}%
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${sisaHari < 3 ? '\nâš ï¸ *Peringatan:* Segera perpanjang sebelum expired!' : ''}`;

  await alip.sendMessage(m.chat, {
      text: teks,
      contextInfo: {
          externalAdReply: {
              title: "PREMIUM GROUP INFO",
              body: `Expired dalam ${sisaHari} hari`,
              thumbnailUrl: global.image.menu,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, { quoted: m });
}
break;
case 'renewsewa':
case 'perpanjangsewa':
case 'renewsewagc': {
    if (!isCreator) return Reply(mess.owner);

    let targetJid = null;
    let daysInput = null;

    // Logika Deteksi Input (Link vs Chat Langsung)
    if (m.isGroup && !text.includes('chat.whatsapp.com')) {
        // Skenario 1: Di dalam grup, cuma ketik .renew 30
        targetJid = m.chat;
        daysInput = args[0];
    } else {
        // Skenario 2: Lewat PM/Grup lain, ketik .renew link 30
        const link = args.find(arg => arg.includes('chat.whatsapp.com'));
        const days = args.find(arg => !arg.includes('chat.whatsapp.com') && !isNaN(arg));
        
        if (link) {
            try {
                const code = link.split("chat.whatsapp.com/")[1].split("?")[0];
                const res = await alip.groupGetInviteInfo(code);
                targetJid = res.id;
            } catch {
                return Reply("âŒ Link grup tidak valid atau bot tidak memiliki akses.");
            }
        }
        daysInput = days;
    }

    if (!targetJid || !daysInput || isNaN(daysInput)) {
        return Reply(`âš ï¸ *Format Salah!*\n\nâ€¢ Di dalam grup: *${prefix + command} 30*\nâ€¢ Dari luar grup: *${prefix + command} link_grup 30*`);
    }

    const days = parseInt(daysInput);
    const durationMs = days * 24 * 60 * 60 * 1000;
    const now = Date.now();

    let sewagrup = JSON.parse(fs.readFileSync(sewaPath));
    let data = sewagrup.find(v => v.jid === targetJid);
    let groupName = "Unknown Group";

    try {
        const meta = await alip.groupMetadata(targetJid);
        groupName = meta.subject;
    } catch (e) {
        groupName = targetJid;
    }

    let oldExp, newExp, statusType;

    if (data) {
        // Jika data ada, update expired
        oldExp = data.expired;
        
        // Logika Akumulasi vs Reset
        if (data.expired > now) {
            // Masih aktif: Tambahkan ke sisa waktu
            data.expired += durationMs;
            statusType = "AKUMULASI (Extended)";
        } else {
            // Sudah expired: Mulai baru dari sekarang
            data.expired = now + durationMs;
            statusType = "RE-ACTIVATED (Reset)";
        }
        
        // PENTING: Reset warning agar notif H-3 nanti muncul lagi
        data.warningSent = false; 
        newExp = data.expired;
    } else {
        // Jika grup belum pernah terdaftar, buat baru
        newExp = now + durationMs;
        sewagrup.push({ 
            jid: targetJid, 
            expired: newExp,
            warningSent: false 
        });
        statusType = "NEW REGISTRATION";
    }

    fs.writeFileSync(sewaPath, JSON.stringify(sewagrup, null, 2));

    const dateStr = new Date(newExp).toLocaleDateString('id-ID', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' 
    });

    // Kirim konfirmasi keren
    const receiptText = `
ðŸ§¾ *RENEWAL SUCCESSFUL*

ðŸ‘¥ *Grup:* ${groupName}
â±ï¸ *Durasi Tambahan:* ${days} Hari
ðŸ“Š *Tipe:* ${statusType}

ðŸ“… *Expired Baru:* ${dateStr}

âœ… _Bot akan aktif kembali dan sistem peringatan otomatis direset._`;

    await alip.sendMessage(m.chat, {
        text: receiptText,
        contextInfo: {
            externalAdReply: {
                title: "PREMIUM RENEWAL",
                body: `${groupName}`,
                thumbnailUrl: global.image.menu,
                mediaType: 1,
                renderLargerThumbnail: true
            }
        }
    }, { quoted: m });
}
break;

case 'listsewagc': {
  if (!isCreator) return Reply(mess.owner)
  
  const sewaPath = './library/database/sewagrup.json'
  if (!fs.existsSync(sewaPath)) {
    return Reply('âŒ Belum ada grup yang menyewa bot.')
  }

  let sewagrup = JSON.parse(fs.readFileSync(sewaPath))
  const now = Date.now()
  
  let a = await alip.groupFetchAllParticipating()
  let gc = Object.values(a)
  let gcJoin = gc.map(g => g.id)
  
  const activeSewa = sewagrup.filter(v => now <= v.expired && gcJoin.includes(v.jid))
  
  if (activeSewa.length === 0) {
    return Reply('âŒ Belum ada grup yang menyewa bot atau bot sudah keluar dari grup.')
  }

  let teks = `\n\`ä¹‚ Daftar sewa bot ðŸš€\`\n`
  teks += `\n* *Total grup :* ${activeSewa.length}\n`
  
  for (let i = 0; i < activeSewa.length; i++) {
    const data = activeSewa[i]
    
    let groupInfo = gc.find(g => g.id === data.jid)
    if (!groupInfo) continue
    
    const sisaMs = data.expired - now
    let sisaWaktu = 'EXPIRED'
    if (sisaMs > 0) {
      const days = Math.floor(sisaMs / (24 * 60 * 60 * 1000))
      const hours = Math.floor((sisaMs % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000))
      const minutes = Math.floor((sisaMs % (60 * 60 * 1000)) / (60 * 1000))
      
      let result = []
      if (days > 0) result.push(`${days} hari`)
      if (hours > 0) result.push(`${hours} jam`)
      if (minutes > 0) result.push(`${minutes} menit`)
      
      sisaWaktu = result.join(' ') || 'Kurang dari 1 menit'
    }
    
    const expired = new Date(data.expired).toLocaleDateString('id-ID', { 
      timeZone: 'Asia/Jakarta',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    })
    
    teks += `\n ${i + 1}. ${groupInfo.subject}
* Expired : ${expired}
* Sisa : ${sisaWaktu}
* Pembuat : ${groupInfo?.subjectOwner ? groupInfo?.subjectOwner.split("@")[0] : "Sudah Keluar"}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`
  }
  
  return Reply(teks)
}
break

case 'delsewagc': {
      if (!isOwner) return Reply(mess.owner)
  
  if (!text) return Reply(`âŒ *Format salah!*\nContoh: .delsewagc 123348429xxxxxx@g.us\n       .delsewagc https://chat.whatsapp.com/xxxxxx`);
  
  let targetJid = '';
  if (text.includes('chat.whatsapp.com')) {
    try {
      const groupInviteCode = text.split('/').pop();
      targetJid = await alip.groupGetInviteInfo(groupInviteCode);
      targetJid = targetJid.id;
    } catch (e) {
      return Reply(`âŒ Link grup tidak valid atau bot tidak bisa mengakses info grup.`);
    }
  } else {
    targetJid = text.replace(/[^0-9@g.us]/g, '');
    if (!targetJid.endsWith('@g.us')) {
      targetJid += '@g.us';
    }
  }

  if (targetJid === global.linkGrup) return Reply(`â— Grup official tidak bisa dihapus dari sewa.`);
  
  let sewagrup = JSON.parse(fs.readFileSync(sewaPath));
  const initialLength = sewagrup.length;
  
  sewagrup = sewagrup.filter(v => v.jid !== targetJid);

  if (sewagrup.length === initialLength) {
    return Reply(`âŒ Grup dengan ID ${targetJid} tidak ditemukan dalam database sewa.`);
  }

  fs.writeFileSync(sewaPath, JSON.stringify(sewagrup, null, 2));
  let groupName = targetJid;
  try {
    const groupMetadata = await alip.groupMetadata(targetJid);
    groupName = groupMetadata.subject || targetJid;
  } catch (e) {}
  
  Reply(`âœ… *Sewa untuk grup "${groupName}" telah dihapus!*\nBot tidak akan lagi aktif di grup tersebut.`);
}
break;

case 'daftar':
case 'register': {
  if (isRegistered(m.sender)) return alip.sendMessage(m.chat, {
    text: `*SUDAH TERDAFTAR!*\n\nAkun sudah aktif dengan akses penuh!\n\nGunakan *.profile* untuk lihat statistik lengkap.`,
    contextInfo: {
      externalAdReply: {
        title: 'Akun Aktif',
        body: 'Selamat menikmati fitur bot!',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: global.namaSaluran,
        renderLargerThumbnail: true
      },
      mentionedJid: [m.sender]
    }
  }, { quoted: m });

if (!text || !text.includes(',')) {
    return Reply(global.mess.verifikasi);
}

  const parts = text.split(',').map(p => p.trim());
  if (parts.length < 2) {
    return Reply('âŒ Format salah! Gunakan: *.daftar nama,umur*');
  }

  const nama = parts[0];
  const umurInput = parts[1];

  const umur = parseInt(umurInput);
  if (isNaN(umur)) {
    return Reply('âŒ Umur harus pake angka, misalnya 18');
  }

  if (umur < 13) {
    return Reply('âŒ Kekecilan, minimal 13 tahun ya adik adik.');
  }

  if (umur > 100) {
    return Reply('âŒ Umur lu tua amat anj, bau tanah.');
  }

  if (!nama || nama.length < 2) {
    return Reply('âŒ Nama harus minimal 2 karakter.');
  }

  await alip.sendPresenceUpdate('composing', m.chat);
  await sleep(1500);

  const userId = m.sender.split('@')[0];
  const userName = m.pushName || 'Tanpa Nama';
  const isPremiumUser = isPrem(m.sender);
  const isOwnerUser = isCreator;
  const status = isOwnerUser ? 'ðŸ‘‘ Owner' : isPremiumUser ? 'ðŸ’Ž Premium' : 'â­ Free';

  const dateNow = new Date();
  const tgl = dateNow.toLocaleDateString('id-ID', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  const jam = dateNow.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

  addRegisteredUser(m.sender, {
    jid: m.sender,
    nama: nama,
    umur: umur,
    pushname: userName,
    status,
    tanggal: tgl,
    jam: jam
  });

  const benefits = isOwnerUser ? [
    'âœ… Akses semua fitur tanpa batas',
    'âœ… Priority support 24/7',
    'âœ… Custom command request',
    'âœ… Developer privileges'
  ] : isPremiumUser ? [
    'âœ… Unlimited limit harian',
    'âœ… Akses fitur premium',
    'âœ… Fast response priority',
    'âœ… No ads interruption'
  ] : [
    'âœ… 15 limit harian (reset tiap hari)',
    'âœ… Akses fitur dasar',
    'âœ… Bisa claim extra limit',
    'âœ… Upgrade ke premium tersedia'
  ];

  const teks = `
â•­â”€â”€â *ã€Œ REGISTRASI BERHASIL ã€*
â”ƒ
â”ƒ â  *Informasi Akun*
â”ƒ â”ƒ
â”ƒ â”£ Nama   : ${nama}
â”ƒ â”£ Umur   : ${umur} tahun
â”ƒ â”£ Tag    : @${userId}
â”ƒ â”£ Status : ${status}
â”ƒ â”— Tanggal: ${tgl}
â”ƒ
â”ƒ â  *Fitur Yang Didapat*
â”ƒ â”ƒ
${benefits.map(b => `â”ƒ â”£ ${b}`).join('\n')}
â”ƒ
â•°â”€â”€â”€â

${isOwnerUser ? 'ðŸŽ¯ *OWNER PRIVILEGES ACTIVATED*' : isPremiumUser ? 'ðŸš€ *PREMIUM FEATURES UNLOCKED*' : 'ðŸ”“ *FREE ACCOUNT ACTIVATED*'}
`.trim();

  await alip.sendMessage(m.chat, {
    text: teks,
    contextInfo: {
      externalAdReply: {
        title: 'Akun Aktif',
        body: 'Selamat menikmati fitur bot!',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: `ï¾ `,
        renderLargerThumbnail: true
      },
      mentionedJid: [m.sender]
    }
  }, { quoted: m });
}
break;

case 'me':
case 'profile': {
const { createCanvas, loadImage } = require('canvas')

if (!isRegistered(m.sender) && !isCreator)
return Reply(global.mess.verifikasi)

async function createProfileHeader(pfpUrl, userName, statusText, statusIcon, userId, level, gold, limitDisplay, rpgLevel) {
const canvas = createCanvas(1200, 600)
const ctx = canvas.getContext('2d')

try {
const bg = await loadImage(global.image.canvas)
ctx.drawImage(bg, 0, 0, canvas.width, canvas.height)
} catch {
ctx.fillStyle = '#0b0f1a'
ctx.fillRect(0, 0, canvas.width, canvas.height)
}

ctx.fillStyle = 'rgba(0,0,0,0.6)'
ctx.fillRect(0, 0, canvas.width, canvas.height)

const cw = 1050
const ch = 430
const cx = (canvas.width - cw) / 2
const cy = (canvas.height - ch) / 2

ctx.fillStyle = 'rgba(255,255,255,0.08)'
ctx.beginPath()
ctx.roundRect(cx, cy, cw, ch, 30)
ctx.fill()

ctx.strokeStyle = 'rgba(255,255,255,0.25)'
ctx.lineWidth = 2
ctx.stroke()

const pSize = 190
const px = cx + 60
const py = cy + (ch - pSize) / 2

ctx.save()
ctx.beginPath()
ctx.arc(px + pSize / 2, py + pSize / 2, pSize / 2, 0, Math.PI * 2)
ctx.clip()
try {
const img = await loadImage(pfpUrl)
ctx.drawImage(img, px, py, pSize, pSize)
} catch {
ctx.fillStyle = '#444'
ctx.fillRect(px, py, pSize, pSize)
}
ctx.restore()

ctx.beginPath()
ctx.arc(px + pSize / 2, py + pSize / 2, pSize / 2 + 6, 0, Math.PI * 2)
ctx.strokeStyle = '#ffffff'
ctx.lineWidth = 4
ctx.stroke()

const tx = px + pSize + 50
const ty = cy + 70

ctx.fillStyle = '#ffffff'
ctx.font = 'bold 44px Arial'
ctx.fillText(userName.slice(0, 26), tx, ty)

ctx.font = '18px Arial'
ctx.fillStyle = '#cccccc'
ctx.fillText('@' + userId, tx, ty + 30)

function statBox(x, y, title, value) {
ctx.fillStyle = 'rgba(0,0,0,0.45)'
ctx.beginPath()
ctx.roundRect(x, y, 260, 62, 14)
ctx.fill()

ctx.font = '14px Arial'
ctx.fillStyle = '#aaaaaa'
ctx.fillText(title, x + 16, y + 22)

ctx.font = 'bold 18px Arial'
ctx.fillStyle = '#ffffff'
ctx.fillText(value, x + 16, y + 46)
}

let sy = ty + 75
statBox(tx, sy, 'STATUS', statusText)
statBox(tx + 280, sy, 'LIMIT', limitDisplay)

sy += 80
if (level) statBox(tx, sy, 'LEVEL GRUP', 'Lv ' + level)
if (rpgLevel) statBox(tx + 280, sy, 'LEVEL RPG', 'Lv ' + rpgLevel)

if (gold) {
sy += 80
statBox(tx, sy, 'GOLD', gold)
}

ctx.font = '14px Arial'
ctx.fillStyle = '#bbbbbb'
ctx.textAlign = 'center'
ctx.fillText(global.botname, canvas.width / 2, cy + ch - 14)

return canvas.toBuffer('image/png')
}

try {
await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key } })

const userId = m.sender.split('@')[0]
const userName = m.pushName || "Pengguna"
const isPremiumUser = isPrem(m.sender)
const isOwnerUser = isCreator

let statusText, statusIcon
if (isOwnerUser) {
statusText = 'Owner'
statusIcon = 'OWNER'
} else if (isPremiumUser) {
statusText = 'Premium'
statusIcon = 'PREMIUM'
} else {
statusText = 'Free User'
statusIcon = 'FREE'
}

const maxLimit = getUserMaxLimit(m.sender)
const usageDB = safeReadJSON(limitUsagePath, [])
const today = getWIBTime().toISOString().split('T')[0]
const userUsage = usageDB.find(u => u.jid === m.sender && u.date === today)?.count || 0
const remainingLimit = maxLimit - userUsage
const claimDB = safeReadJSON(claimDBPath, {})
const claimStatus = claimDB[m.sender] === today ? 'âœ… Sudah' : 'âŒ Belum'

let userLevelInGroup = null
let userGoldDisplay = null
let userRpgLevel = null
let limitDisplay = isOwnerUser || isPremiumUser ? 'âˆž Unlimited' : `${remainingLimit > 0 ? remainingLimit : 0}/${maxLimit}`

if (m.isGroup) {
const userLevel = getUserLevel(m.chat, m.sender)
userLevelInGroup = userLevel.level
}

const rpgInfo = rpgDB?.players?.[m.sender]
if (rpgInfo) {
userGoldDisplay = await toIDR(rpgInfo.gold)
userRpgLevel = rpgInfo.level
}

let pfpUrl
try {
pfpUrl = await alip.profilePictureUrl(m.sender, "image")
} catch {
pfpUrl = 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg'
}

let teks = `â•­â”€â”€â”€âœ¦ *ã€Œ PROFILE CARD ã€* â”€â”€â”€â•®
â”‚
â”‚  ðŸ‘¤ *${userName}*
â”‚  ðŸ“± @${userId}
â”‚  ${statusIcon} *${statusText}*
â”‚
â”‚  âš¡ *Limit:* ${limitDisplay}
â”‚  ðŸŽ *Claim:* ${claimStatus}
â”‚`

if (m.isGroup) {
const userLevel = getUserLevel(m.chat, m.sender)
teks += `
â”‚  âœ¨ *Level Grup:* ${userLevel.level}
â”‚  ðŸ“Š *Total Pesan:* ${userLevel.messages}
â”‚`

if (rpgInfo) {
teks += `
â”‚  âš”ï¸ *RPG Level:* ${rpgInfo.level}
â”‚  â¤ï¸ *HP:* ${rpgInfo.hp}/${rpgInfo.maxHp}
â”‚  ðŸ’° *Gold:* ${userGoldDisplay}
â”‚  ðŸ—ºï¸ *Lokasi:* ${rpgDB.locations[rpgInfo.location].name}
â”‚  ðŸ›¡ï¸ *Class:* ${rpgInfo.class}
â”‚`
} else {
teks += `
â”‚  ðŸŽ® *RPG Status:* Belum memulai
â”‚  ðŸ’¡ Gunakan *.rpgstart* untuk mulai
â”‚`
}
} else {
teks += `
â”‚  â„¹ï¸ *Info Tambahan:*
â”‚  Statistik lengkap tersedia
â”‚  di dalam grup
â”‚`
}

teks += `
â”‚
â”‚  ðŸ’« *Tips:* Gunakan .claim untuk
â”‚  menambah 5 limit harian
â•°â”€â”€â”€âœ¦ *${global.botname}* â”€â”€â”€â•¯`

const headerImageBuffer = await createProfileHeader(
pfpUrl,
userName,
statusText,
statusIcon,
userId,
userLevelInGroup,
userGoldDisplay,
limitDisplay,
userRpgLevel
)

await alip.sendMessage(m.chat, {
image: headerImageBuffer,
caption: teks.trim(),
mentions: [m.sender]
}, { quoted: m })

} catch (err) {
Reply("âŒ Maaf, terjadi kesalahan saat membuat kartu profil Anda.")
}
}
break

case 'unreg': {
  if (!isRegistered(m.sender)) {
    return Reply('âŒ Kamu belum terdaftar!');
  }

  const userDBPath = './library/database/user.json';
  const usersData = JSON.parse(fs.readFileSync(userDBPath));
  const userIndex = usersData.findIndex(u => areJidsSameUser(u.jid, m.sender));
  
  if (userIndex === -1) {
    return Reply('âŒ Data tidak ditemukan!');
  }

  const removedUser = usersData[userIndex];
  usersData.splice(userIndex, 1);
  fs.writeFileSync(userDBPath, JSON.stringify(usersData, null, 2));

  const teks = `ðŸ—‘ï¸ *AKUN DIHAPUS*\n\nAkun *${removedUser.nama || 'User'}* berhasil dihapus dari sistem.\n\nJika ingin menggunakan bot lagi, silakan daftar ulang dengan *.daftar nama,umur*`;

  await alip.sendMessage(m.chat, {
    text: teks,
    contextInfo: {
      externalAdReply: {
        title: 'Akun Dihapus',
        body: 'Data berhasil dihapus dari sistem',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: global.namaSaluran,
        renderLargerThumbnail: true
      },
      mentionedJid: [m.sender]
    }
  }, { quoted: m });
}
break;

case 'addlimit': {
  if (!isCreator) return Reply('âŒ Fitur ini hanya untuk Owner bot.');

  let users = []
  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
          return p ? p.jid : null
        } else {
          return id
        }
      }).filter(Boolean)
    } else if (args[0]) {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }
  } else if (args[0]) {
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
  }

  if (!users.length) return Reply(`Tag atau reply user dan masukkan jumlah bonus limit.\n\nContoh:\n.addlimit @user 50`);

  let amount = parseInt(args.find(arg => !arg.includes('@')));
  if (!amount || isNaN(amount)) return Reply(`Masukkan jumlah bonus limit.\n\nContoh:\n.addlimit @user 50`);

  const bonusDB = safeReadJSON(limitBonusPath, {});
  const today = getWIBTime().toISOString().split('T')[0];

  for (let target of users) {
    if (!bonusDB[target] || bonusDB[target].date !== today) {
      bonusDB[target] = { bonus: 0, date: today };
    }

    bonusDB[target].bonus += amount;
    Reply(`âœ… Berhasil menambahkan *${amount}* limit bonus untuk @${target.split('@')[0]}.\nBonus ini hanya berlaku untuk hari ini.`, [target]);
  }

  fs.writeFileSync(limitBonusPath, JSON.stringify(bonusDB, null, 2));
}
break;

case 'setlimit': {
    if (!isCreator) return Reply('âŒ Fitur ini hanya untuk Owner bot.');

    let target = m.mentionedJid?.[0] || (m.quoted ? m.quoted.sender : null);
    let amount = parseInt(args.find(arg => !arg.includes('@')));

    if (!target || isNaN(amount)) {
        return Reply(`Tag atau reply user dan masukkan jumlah limit permanen.\n\nContoh:\n.setlimit @user 100`);
    }

    const config = getLimitConfig();
    if (amount > 0) {
        config.users[target] = amount;
        Reply(`âœ… Berhasil mengatur limit permanen untuk @${target.split('@')[0]} menjadi *${amount} limit/hari*.`, [target]);
    } else {
        delete config.users[target];
        Reply(`âœ… Berhasil menghapus limit permanen untuk @${target.split('@')[0]}. Kembali ke default.`, [target]);
    }
    
    fs.writeFileSync(limitConfigPath, JSON.stringify(config, null, 2));
}
break;

case 'dellimit': {
    if (!isCreator) return Reply('âŒ Fitur ini hanya untuk Owner bot.');
    let target = m.mentionedJid?.[0] || (m.quoted ? m.quoted.sender : null);
    if (!target) return Reply(`Tag atau reply user yang ingin dihapus limit permanennya.`);

    const config = getLimitConfig();
    if (!config.users[target]) return Reply(`âŒ @${target.split('@')[0]} tidak memiliki limit permanen.`, [target]);
    
    delete config.users[target];
    fs.writeFileSync(limitConfigPath, JSON.stringify(config, null, 2));
    Reply(`âœ… Berhasil menghapus limit permanen untuk @${target.split('@')[0]}. Kembali ke default.`, [target]);
}
break;

case "limit":
case "ceklimit": {
  const target = m.mentionedJid?.[0] || m.sender;
  const isPremiumUser = isPrem(target);
  const isOwnerUser = [botNumber, owner + "@s.whatsapp.net", ...owners].includes(target);
  
  if (isOwnerUser || isPremiumUser) {
    const status = isOwnerUser ? 'ðŸ‘‘ OWNER' : 'ðŸ’Ž PREMIUM';
    return Reply(`*â”€â”€ ã€Œ INFO LIMIT ã€ â”€â”€*\n \nâœ… *STATUS* : ${status}\nðŸš€ *LIMIT* : UNLIMITED`);
  } 

  const maxLimit = getUserMaxLimit(target);
  const usageDB = safeReadJSON(limitUsagePath, []);
  const today = getWIBTime().toISOString().split('T')[0];
  const userUsage = usageDB.find(u => u.jid === target && u.date === today)?.count || 0;
  const remaining = maxLimit - userUsage;
  
  const claimDB = safeReadJSON(claimDBPath, {});
  const claimStatus = claimDB[target] === today ? "âœ… Sudah diklaim" : "âŒ Belum diklaim";

  const message = `
*â”€â”€ ã€Œ INFO LIMIT ã€ â”€â”€*

ðŸ“Š *Total Limit Harian:* ${maxLimit}
ðŸ“ˆ *Terpakai:* ${userUsage}
ðŸ“‰ *Sisa:* ${remaining > 0 ? remaining : 0}
ðŸŽ *Claim Bonus:* ${claimStatus}

ðŸ’¬ *CATATAN*
ãƒ» Limit di-reset setiap hari jam 00:00 WIB.
ãƒ» Gunakan *.claim* untuk bonus 5 limit.
ãƒ» Upgrade ke premium dengan *.premium*.
    `.trim();
  Reply(message);
}
break;


case 'resetlimitall': {
    if (!isOwner) return Reply(mess.owner)
  const db = safeReadJSON(limitUsagePath, []); 
  
  if (db.length === 0) return Reply('âš ï¸ Tidak ada data penggunaan limit untuk direset.');
  const newDb = [];
  fs.writeFileSync(limitUsagePath, JSON.stringify(newDb, null, 2));
  
  Reply(`â™»ï¸ Database penggunaan limit harian berhasil direset untuk semua user.`);
}
break;


case "donate": {
  await alip.sendMessage(
    m.chat,
    {
      image: { url: global.image.qris },
      caption: `ðŸ’¼ *SUPPORT THIS BOT*

Bot ini berjalan secara mandiri dan terbuka untuk umum. Jika Anda merasa terbantu dengan fitur-fitur yang tersedia, pertimbangkan untuk memberikan dukungan dalam bentuk donasi.

ðŸ”— *Metode Pembayaran:* QRIS (mendukung semua e-wallet dan bank)

ðŸ“¬ Kirim bukti donasi ke owner jika ingin akses khusus atau premium bot.

Terima kasih atas kontribusi dan dukungan Anda.`
    },
    { quoted: m }
  );
}
break;

case "backup": {
  const owner = global.owner + '@s.whatsapp.net';
  if (!areJidsSameUser(m.sender, owner)) return Reply(`âŒ Hanya ${global.namaOwner} yang bisa akses command ini.`);
  
  await Reply("ðŸ“¦ Sedang memproses backup database...")
  const name = `database-backup`
  const anu = await execSync(`zip -r ${name}.zip library/database`)
  await alip.sendMessage(m.sender, {
    document: await fs.readFileSync(`./${name}.zip`),
    fileName: `${name}.zip`,
    mimetype: "application/zip"
  }, { quoted: m })
  await execSync(`rm -rf ${name}.zip`)
  if (m.chat !== m.sender) return Reply("âœ… Backup database berhasil dikirim ke private chat")
}
break

case 'autobackup': {
  const owner = global.owner + '@s.whatsapp.net';
  if (!areJidsSameUser(m.sender, owner)) return Reply(`âŒ Hanya ${global.namaOwner} yang bisa akses command ini.`);
  
  function loadAutoBackupConfig() {
    try {
      if (fs.existsSync(autoBackupConfigPath)) {
        return JSON.parse(fs.readFileSync(autoBackupConfigPath, 'utf8'))
      }
    } catch (e) {
    }
    return { enabled: false, interval: null }
  }
  
  function saveAutoBackupConfig(config) {
    try {
      fs.writeFileSync(autoBackupConfigPath, JSON.stringify(config, null, 2))
    } catch (e) {
    }
  }
  
  function startAutoBackup(intervalHours) {
    if (global.autoBackup.timer) {
      clearInterval(global.autoBackup.timer)
      global.autoBackup.timer = null
    }
    
    global.autoBackup.enabled = true
    global.autoBackup.interval = intervalHours
    const intervalMs = intervalHours * 60 * 60 * 1000
    
    doBackupDatabase(alip)
    
    global.autoBackup.timer = setInterval(() => {
      doBackupDatabase(alip)
    }, intervalMs)
    
    saveAutoBackupConfig({
      enabled: true,
      interval: intervalHours,
      lastUpdated: new Date().toISOString()
    })
  }
  
  function stopAutoBackup() {
    if (global.autoBackup.timer) {
      clearInterval(global.autoBackup.timer)
      global.autoBackup.timer = null
    }
    global.autoBackup.enabled = false
    delete global.autoBackup.interval
    
    saveAutoBackupConfig({
      enabled: false,
      interval: null,
      lastUpdated: new Date().toISOString()
    })
  }
  
  if (!text) {
    const config = loadAutoBackupConfig()
    const status = config.enabled ? 'ON' : 'OFF'
    const interval = config.interval ? `${config.interval} jam` : 'Tidak aktif'
    
    return alip.sendMessage(m.chat, { 
      text: `ðŸ“Š *Status Auto Backup*\n\nStatus: ${status}\nInterval: ${interval}\n\n.autobackup on [jam]\n.autobackup off`
    }, { quoted: m })
  }

  const args = text.split(' ')
  const action = args[0].toLowerCase()

  if (action === 'off') {
    stopAutoBackup()
    return alip.sendMessage(m.chat, { 
      text: 'âŒ Auto-backup dimatikan.'
    }, { quoted: m })
    
  } else if (action === 'on') {
    if (!args[1]) {
      return alip.sendMessage(m.chat, { 
        text: `âŒ Tentukan interval waktu!\nContoh: .autobackup on 6`
      }, { quoted: m })
    }
    
    const intervalHours = parseInt(args[1])
    
    if (isNaN(intervalHours) || intervalHours < 1) {
      return alip.sendMessage(m.chat, { 
        text: 'âŒ Interval minimal 1 jam!'
      }, { quoted: m })
    }
    
    if (intervalHours > 720) {
      return alip.sendMessage(m.chat, { 
        text: 'âŒ Interval maksimal 720 jam!'
      }, { quoted: m })
    }

    startAutoBackup(intervalHours)
    
    let intervalText = intervalHours === 1 ? '1 jam' : `${intervalHours} jam`
    return alip.sendMessage(m.chat, { 
      text: `âœ… Auto-backup diaktifkan setiap ${intervalText}.\nBackup pertama sedang diproses...`
    }, { quoted: m })
    
  } else {
    return alip.sendMessage(m.chat, { 
      text: `âŒ Perintah tidak valid!\n\n.autobackup on [jam]\n.autobackup off`
    }, { quoted: m })
  }
}
break
// ================== [ NGL SPAM VIA LINK ] ==================
case "nglspam": {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    if (args.length < 3) return Reply(`Contoh:\n${prefix + command} https://ngl.link/alipclutch Halo 5`);

    let link = args[0];
    if (!link.startsWith("http")) return Reply("âŒ Harus pakai link NGL (contoh: https://ngl.link/username)");

    let username = link.split("/").pop().trim();
    let spamCount = parseInt(args.pop());
    let message = args.slice(1).join(" ");

    if (!username || !message || isNaN(spamCount)) 
        return Reply(`âŒ Format salah!\nContoh:\n${prefix + command} https://ngl.link/username Halo 5`);

    if (spamCount > 50 && !isCreator) return Reply("âŒ Max spam 50 biar aman.");

    if (!global.nglCooldown) global.nglCooldown = {};
    if (global.nglCooldown[m.sender] && Date.now() - global.nglCooldown[m.sender] < 10*60*1000 && !isCreator) 
        return Reply(`â³ Kamu baru aja spam. Tunggu ${Math.ceil((10*60*1000 - (Date.now() - global.nglCooldown[m.sender]))/60000)} menit lagi.`);

    const crypto = require("crypto");
    const fetch = require("node-fetch");

    Reply(`ðŸš€ Otw spam ke @${username}\npesan: *${message}*\njumlah: *${spamCount}*`);

    let counter = 0;
    global.nglCooldown[m.sender] = Date.now();

    const spamLoop = async () => {
        if (counter >= spamCount) {
            return Reply(`âœ… Selesai spam ke @${username}, total terkirim: ${counter}`);
        }

        try {
            const date = new Date();
            const formattedDate = `${date.getHours()}:${date.getMinutes()}`;
            const deviceId = crypto.randomBytes(21).toString("hex");

            const res = await fetch("https://ngl.link/api/submit", {
                method: "POST",
                headers: {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0",
                    "Accept": "*/*",
                    "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                    "X-Requested-With": "XMLHttpRequest",
                    "Referer": `https://ngl.link/${username}`,
                    "Origin": "https://ngl.link"
                },
                body: `username=${username}&question=${message}&deviceId=${deviceId}&gameSlug=&referrer=`
            });

            if (res.status !== 200) {
                console.log(`[${formattedDate}] [Err] Ratelimited`);
                await new Promise(r => setTimeout(r, 25000));
            } else {
                counter++;
                console.log(`[${formattedDate}] [Msg] Sent: ${counter}`);
            }
        } catch (err) {
            console.error("NGL Error:", err);
            await new Promise(r => setTimeout(r, 5000));
        }

        setTimeout(spamLoop, 500); // Delay 0.5 detik tiap request biar bot tetap responsif
    };

    spamLoop();
}
break;

// CASE NSFW
case 'nsfw': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch langsung sebagai buffer
        const res = await fetch(`${global.apialip}/random/nsfw?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*yeuu sangean luuðŸ˜¡*`
        })

        // notif di grup/chat asal, optional
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwass': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/ass?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*yeuu sangean luuðŸ˜¡*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW ASS ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwloli': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/anime/nsfwloli?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ˜³ jangan bilangÂ² ya...*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW LOLI ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwgay': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/gay?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ˜ njir selera lu...*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW GAY ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwahegao': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/ahegao?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ¤¤ ngeliat muka ginian bikin greget...*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW AHEGAO ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwbdsm': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/bdsm?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*â›“ï¸ waduh... hardcore banget selera lu*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW BDSM ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwgangbang': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/gangbang?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ† rame banget anjir...*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW GANGBANG ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwpussy': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/pussy?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ˜¼ hmm mantap bet*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW PUSSY ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwzettai': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/zettai?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ‘€ zettai ryouiki detected...*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW ZETTAI ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case 'nsfwneko': {
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    try {
        // fetch gambar langsung dari API
        const res = await fetch(`${global.btc}/api/nsfw/neko?apikey=${global.apikeyalip}`)
        if (!res.ok) throw new Error(`Gagal ambil data dari API`)

        const imgBuf = Buffer.from(await res.arrayBuffer())

        // kirim ke private chat
        await alip.sendMessage(m.sender, {
            image: imgBuf,
            caption: `*ðŸ¾ neko imut tapi nakal ðŸ˜¼*`
        })

        // notif di grup/chat asal
        if (m.chat !== m.sender) {
            await alip.sendMessage(m.chat, { 
                text: `âœ… Cek private chat lu, gua udah kirim gambarnya ðŸ‘€` 
            }, { quoted: m })
        }

    } catch (e) {
        console.error('NSFW NEKO ERR', e)
        alip.sendMessage(m.chat, { 
            text: `âŒ Terjadi kesalahan, coba lagi nanti.` 
        }, { quoted: m })
    }
}
break

case "claim": {
  if (isPrem(m.sender) || isCreator) {
    return Reply("âŒ User premium & owner tidak perlu claim limit!");
  }
  
  const claimResult = global.claimLimit(m.sender);
  if (claimResult.success) {
    Reply(`ðŸŽ‰ ${claimResult.message}`);
  } else {
    Reply(`âš ï¸ ${claimResult.message}`);
  }
  break;
}


case 'confes': {
    // simpen cooldown di object
    if (!global.confessCooldown) global.confessCooldown = {}

if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    
    // cek cooldown
    const cdTime = 10 * 60 * 1000; // 10 menit
    if (global.confessCooldown[m.sender] && (Date.now() - global.confessCooldown[m.sender]) < cdTime) {
        let sisa = ((cdTime - (Date.now() - global.confessCooldown[m.sender])) / 1000 / 60).toFixed(1);
        return Reply(`â³ Tunggu *${sisa} menit* dulu sebelum pake .confes lagi!`);
    }
    global.confessCooldown[m.sender] = Date.now(); // update waktu terakhir pakai

    if (!text) 
        return alip.sendMessage(m.chat, { 
            text: `ðŸš¨ *Contoh:* .confes 628123456789 Hai, aku suka banget sama kamu\n\nðŸ“ Tulis pesanmu dengan jelas ya!` 
        }, { quoted: m });

    const parts = text.trim().split(' ');
    const targetNumber = parts.shift().replace(/\D/g, '');
    const pesan = parts.join(' ');

    if (!pesan) return alip.sendMessage(m.chat, { text: `âŒ Isi pesan kosong!` }, { quoted: m });

    const waktu = new Date().toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' });

    const captionConfes = `â•­â”€ðŸ’Œ *PESAN RAHASIA* ðŸ’Œ
â”‚ðŸ•’ *Waktu:* ${waktu}
â”‚ðŸ§© *Isi Pesan:*
${pesan.split('\n').map(line => 'â”‚ ' + line).join('\n')}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
ðŸŽ¯ *Pengirim anonim*`;

    const targetJid = targetNumber + '@s.whatsapp.net';
    const fotoUrl = 'https://img1.pixhost.to/images/8139/633650484_media.jpg';

    try {
        await alip.sendMessage(targetJid, { 
            image: { url: fotoUrl }, 
            caption: captionConfes 
        });

        await alip.sendMessage(m.chat, { 
            text: `âœ… Pesan rahasia berhasil dikirim ke *${targetNumber}*!` 
        }, { quoted: m });
    } catch (e) {
        console.log(`âŒ Gagal kirim pesan ke ${targetNumber}:`, e);
        await alip.sendMessage(m.chat, { 
            text: `âŒ Gagal mengirim pesan. Pastikan nomor benar dan bot bisa mengirim ke nomor tersebut.` 
        }, { quoted: m });
    }
}
break;

case 'rch': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi)
    if (!text) return Reply(`Contoh: ${prefix + command} https://whatsapp.com/channel/xxx ðŸ˜¹,ðŸ«¡,ðŸ˜‚`)

    try {
        const parts = text.split(' ')
        const link = parts[0]
        const emoji = parts.slice(1).join(' ') || 'ðŸ˜¹'

        if (!link.includes('whatsapp.com/channel/'))
            return Reply('âŒ Link channel tidak valid')

        await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } })

        const apiUrl = `https://api.danzy.web.id/api/tools/reactch?url=${encodeURIComponent(link)}&emoji=${encodeURIComponent(emoji)}&apikey=c140fb995d3ced3d79ae687202a9d8620f6f06eb2e7c2fcceb04d2da20e33591`
        const res = await fetch(apiUrl)
        const json = await res.json()

        if (!json.status) {
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } })
            return Reply('âŒ Gagal mengirim reactions')
        }

        const meta = json.result.metadata

        await Reply(
`âœ… *Reactions Sent*

ðŸŽ¯ Emoji: ${emoji}
ðŸ“¢ Channel: ${meta.name}
ðŸ‘¥ Followers: ${meta.followers}`
        )

        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } })

    } catch (e) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } })
        Reply('âŒ Gagal mengirim reactions')
    }
}
break;

case 'gdrive': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  if (!args.length) return Reply('Contoh penggunaan:\n.gdrive <link_gdrive>');

  try {
    const link = args[0];
    const fetch = require('node-fetch');

    const res = await fetch(`${global.btc}/api/download/gdrive?apikey=${global.apikeyalip}&url=${encodeURIComponent(link)}`);
    const json = await res.json();

    if (!json.status || !json.result || !json.result.data) {
      return Reply('Gagal mengambil data dari Google Drive.');
    }

    const file = json.result;
    const caption = `ðŸ“„ *Nama File:* ${file.fileName}\nðŸ’¾ *Ukuran:* ${file.fileSize}\nðŸ”— *Link Download:* ${file.data}\n\n>TUNGGU SEBENTAR SAYA AKAN MENGIRIMKAN FILE NYA`;

    // Kirim info file
    await alip.sendMessage(m.chat, { text: caption }, { quoted: m });

    // Kirim file langsung
    await alip.sendMessage(m.chat, {
      document: { url: file.data },
      mimetype: file.mimetype,
      fileName: file.fileName
    }, { quoted: m });

  } catch (e) {
    console.error('Error gdrive:', e);
    Reply(`âŒ Terjadi error saat memproses file Google Drive:\n${e.message || e}`);
  }
}
break; 

case 'tochibi': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tochibi*`);
    }
    m.reply("ðŸŽ¨ Sedang mengubah fotomu menjadi versi chibi anime... Tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "âœ¨", key: m.key } });

    const PROMPT_CHIBI = `
    Transform the person in the image into a cute anime chibi version. 
    Keep the same hairstyle, outfit style, and recognizable features, 
    but make the head slightly larger and the body smaller for a chibi proportion. 
    Use soft anime colors, expressive eyes, and a clean illustration look. 
    The final result should look like a high-quality anime chibi artwork.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_CHIBI)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'tobotak': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tobotak*`);
    }
    m.reply("ðŸ§‘â€ðŸ¦² Membuat versi botak dari fotomu... Tunggu sebentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸª®", key: m.key } });

    const PROMPT_BOTAK = `
    Transform the person in the image to appear completely bald, 
    keeping their facial structure, expression, and skin tone natural and unchanged. 
    The bald effect should look realistic with proper lighting and shading on the scalp. 
    Do not modify the face or add accessories â€” only remove all visible hair 
    while maintaining photo realism as if itâ€™s an actual picture of a bald person.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_BOTAK)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

// ================= FITUR : alip EDIT IMAGE =================
case 'alipedit': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    const teks = q.text?.split(' ').slice(1).join(' ') || m.text?.split(' ').slice(1).join(' ');
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}alipedit [prompt]*`);
    }
    if (!teks) return Reply(`ðŸ“ Masukkan prompt setelah command.\n\nContoh:\n${prefix}alipedit ubah jadi gaya cyberpunk dengan latar neon biru`);
    
    Reply("ðŸŽ¨ Sedang memproses gambar sesuai prompt kamu... Mohon tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸª„", key: m.key } });

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(teks)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'fakestory': {
  try {
    const { createCanvas, loadImage } = require('canvas')
    await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } })
    let [username, caption] = text.split('|')
    if (!username || !caption) return m.reply(`Contoh:\n.${command} Alip|Eummm...`)
    const bgUrl = 'https://files.catbox.moe/3gwr1l.jpg'
    const bg = await loadImage(bgUrl)
    const userPP = await alip.profilePictureUrl(m.sender, 'image').catch(_ => 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg')
    const pp = await loadImage(userPP)
    const canvas = createCanvas(720, 1280)
    const ctx = canvas.getContext('2d')
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height)
    const ppX = 40
    const ppY = 250
    const ppSize = 70
    ctx.save()
    ctx.beginPath()
    ctx.arc(ppX + ppSize / 2, ppY + ppSize / 2, ppSize / 2, 0, Math.PI * 2)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(pp, ppX, ppY, ppSize, ppSize)
    ctx.restore()
    ctx.font = '28px Arial'
    ctx.fillStyle = '#FFFFFF'
    ctx.textAlign = 'left'
    ctx.textBaseline = 'middle'
    const usernameX = ppX + ppSize + 15
    const usernameY = ppY + ppSize / 2
    ctx.fillText(username, usernameX, usernameY)
    ctx.font = 'bold 30px Arial'
    ctx.fillStyle = '#FFFFFF'
    ctx.textAlign = 'center'
    ctx.textBaseline = 'top'
    const captionX = canvas.width / 2
    const captionY = canvas.height - 650
    const maxWidth = canvas.width - 100
    const lineHeight = 42
    wrapTextCenter(ctx, caption, captionX, captionY, maxWidth, lineHeight)
    let buffer = canvas.toBuffer()
    await alip.sendMessage(m.chat, {
      image: buffer,
      caption: 'Sukses Kak :v'
    }, { quoted: m })
  } catch (e) {
    m.reply(`âŒ Error\nLogs error : ${e.message}`)
  }
  function wrapTextCenter(ctx, text, x, y, maxWidth, lineHeight) {
    let line = ''
    for (let i = 0; i < text.length; i++) {
      let testLine = line + text[i]
      let testWidth = ctx.measureText(testLine).width
      if (testWidth > maxWidth && line !== '') {
        ctx.fillText(line, x, y)
        line = text[i]
        y += lineHeight
      } else {
        line = testLine
      }
    }
    if (line) ctx.fillText(line, x, y)
  }
}
break

case 'polaroid': {
    if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const axios = require("axios");
    const FormData = require("form-data");
    const Jimp = require("jimp");
    const fakeUserAgent = require("fake-useragent");
    const https = require("https");

    const agent = new https.Agent({
        rejectUnauthorized: false
    });

    if (!global.polaroidSessions) global.polaroidSessions = {};

    const PROMPT_LOCK = `Buatlah gambar yang diambil dengan kamera polaroid. Buatlah seperti photobooth 3 grid. Foto tersebut harus terlihat seperti foto biasa, tanpa subyek atau properti yang jelas. Foto tersebut harus memiliki sedikit efek blur dan sumber cahaya yang konsisten, seperti lampu kilat dari ruangan gelap, yang tersebar di seluruh foto. Jangan ubah wajah. Ganti latar belakang dibelakang tersebut dengan tirai putih dengan orang pertama itu memegang kepala si orang kedua, orang keduanya menunjuk orang pertama itu, dan pose imut lainnya`;

    async function uploadUguu(buffer, filename = "file.jpg") {
        const form = new FormData();
        form.append("files[]", buffer, { filename, contentType: "application/octet-stream" });
        const { data } = await axios.post("https://uguu.se/upload.php", form, {
            headers: { ...form.getHeaders(), "User-Agent": fakeUserAgent() },
            httpsAgent: agent,
            maxBodyLength: Infinity,
            timeout: 60000
        });
        const url = data?.files?.[0]?.url;
        if (!url) throw new Error("Upload ke Uguu gagal");
        return url;
    }

    async function mergePhotos(buf1, buf2) {
        const img1 = await Jimp.read(buf1);
        const img2 = await Jimp.read(buf2);
        const size = 700;
        img1.cover(size, size);
        img2.cover(size, size);
        const gap = 20;
        const canvas = new Jimp(size * 2 + gap, size, 0xffffffff);
        canvas.composite(img1, 0, 0);
        canvas.composite(img2, size + gap, 0);
        return await canvas.getBufferAsync(Jimp.MIME_JPEG);
    }

    const key = `${m.chat}:${m.sender}`;
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";

    if (!global.polaroidSessions[key]) {
        if (!/image\//i.test(mime)) {
            return Reply(`âŒ Balas *gambar pertama* dengan caption *${prefix}polaroid*`);
        }
        const buf1 = await q.download();
        if (!buf1) return Reply("Gagal download gambar pertama.");
        
        global.polaroidSessions[key] = { buf1 };
        return m.reply(
            "âœ… Foto pertama disimpan!\n" +
            `Sekarang balas *gambar kedua* dengan caption *${prefix}polaroid* lagi.\n\n` +
            `Ketik *.batalpolaroid* untuk membatalkan.`
        );
        
    } else {
        const sess = global.polaroidSessions[key];
        if (!/image\//i.test(mime)) {
            return Reply(`âŒ Balas *gambar kedua* dengan caption *${prefix}polaroid*`);
        }
        const buf2 = await q.download();
        if (!buf2) return Reply("Gagal download gambar kedua.");

        try {
            await alip.sendMessage(m.chat, { react: { text: "ðŸ”„", key: m.key } });
            m.reply("â³ Menggabungkan gambar dan memproses dengan AI, mohon tunggu...");

            const merged = await mergePhotos(sess.buf1, buf2);
            const mergedUrl = await uploadUguu(merged, "merged.jpg");

            const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(mergedUrl)}&prompt=${encodeURIComponent(PROMPT_LOCK)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
        } catch (e) {
            await Reply("âŒ Error: " + e.message);
        } finally {
            delete global.polaroidSessions[key];
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        }
    }
}
break;


case 'batalpolaroid': {
    const key = `${m.chat}:${m.sender}`;
    if (global.polaroidSessions && global.polaroidSessions[key]) {
        delete global.polaroidSessions[key];
        Reply("âœ… Sesi polaroid berhasil dibatalkan.");
    } else {
        Reply("Tidak ada sesi polaroid yang sedang aktif.");
    }
}
break;
// ===========================================================
case 'tosunda': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tosunda*`);
    }
    m.reply("ðŸŽ¨ Memproses fotomu dengan gaya Sunda... Mohon tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "âœ¨", key: m.key } });

    const PROMPT_SUNDA = `
    Ubah pakaian orang di foto ini menjadi pakaian adat Sunda yang pas.
    Jika laki-laki, kenakan Baju Pangsi hitam lengkap dengan iket kepala batik.
    Jika perempuan, kenakan Kebaya Sunda yang elegan.
    Penting: Jangan ubah wajah, bentuk kepala, atau rambut asli â€” hanya ganti pakaiannya.
    Hasilkan tampilan realistis seperti foto sungguhan.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_SUNDA)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'tojawa': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tojawa*`);
    }
    m.reply("ðŸŽ¨ Memproses fotomu dengan gaya Jawa... Mohon tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "âœ¨", key: m.key } });

    const PROMPT_JAWA = `
    Ubah pakaian orang di foto ini menjadi pakaian adat Jawa yang autentik dan elegan.
    Jika laki-laki, kenakan beskap hitam khas Jawa lengkap dengan blangkon dan pegang keris di pinggangnya.
    Jika perempuan, kenakan kebaya Jawa klasik berwarna lembut dengan sanggul rapi.
    Pastikan hasilnya terlihat seperti foto sungguhan dan mempertahankan wajah, ekspresi, serta rambut asli tanpa perubahan.
    Latar belakang boleh disesuaikan agar tampak seperti suasana budaya Jawa tradisional.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_JAWA)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;
// ===========================================================

case 'hijabpin': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}hijabpin*`);
    }
    m.reply("ðŸ§• Menambahkan hijab elegan dengan pin bros di fotomu... Tunggu sebentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸŒ¸", key: m.key } });

    const PROMPT_HIJABPIN = `
    Add a realistic hijab to the person in the image, styled naturally around the head and neck.
    Include a small elegant pin or brooch near the side of the head.
    Keep the facial structure, expression, and lighting exactly the same.
    Make it look like a real photo of someone truly wearing a hijab with a stylish pin.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_HIJABPIN)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

// FITUR: PUTIHKAN GAMBAR
case 'putihkan': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}putihkan*`);
    }
    m.reply("âœ¨ Sedang memutihkan dan mencerahkan kulit di fotomu... Mohon tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ’Ž", key: m.key } });

    const PROMPT_PUTIHKAN = `
    Brighten and smoothen the skin tone of the person in the image naturally, 
    giving a clean, glowing, and healthy white appearance. 
    Keep the original facial features, structure, and expression unchanged. 
    Make the skin look evenly toned and radiant under soft lighting, 
    without making it look artificial or overexposed. 
    Maintain a realistic photographic quality with balanced contrast and warmth.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_PUTIHKAN)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'sdm': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

  const fs = require('fs');
  const axios = require('axios');
  const { ImageUploadService } = require('node-upload-images');
  const path = require('path');

  let qmsg = m.quoted ? m.quoted : m;
  let mime = (qmsg.msg || qmsg).mimetype || '';

  if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

  await alip.sendMessage(m.chat, { react: { text: 'ðŸ“¸', key: m.key } });

  try {
    // Download media sementara
    let media = await alip.downloadAndSaveMediaMessage(qmsg);

    // Upload ke pixhost
    const service = new ImageUploadService('postimages.org');
    let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');
    let imgUrl = directLink.toString();

    // Hapus media sementara
    await fs.unlinkSync(media);

    // Request API (langsung gambar)
    let apiUrl = `${global.btc}/api/maker/jadisdmtinggi?apikey=${global.apikeyalip}&url=${encodeURIComponent(imgUrl)}`;
    let response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

    // Simpan hasil sementara
    const tempDir = path.join(process.cwd(), 'tmp');
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir);
    const tempPath = path.join(tempDir, `jadisdmtinggi_${Date.now()}.jpg`);
    fs.writeFileSync(tempPath, response.data);

    // Kirim ke user
    await alip.sendMessage(m.chat, {
      image: fs.readFileSync(tempPath),
      caption: `âœ… *JADI SDM TINGGI BERHASIL*`
    }, { quoted: m });

    // Hapus file sementara
    setTimeout(() => {
      try { fs.unlinkSync(tempPath); } 
      catch (e) { console.error('Gagal hapus file temporary:', e); }
    }, 15000);

  } catch (err) {
    console.error('Error:', err);
    let msg = err.response?.statusText || err.message || 'Terjadi error';
    m.reply(`âŒ Error: ${msg}`);
  }
}
break;

case "sewa": {
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ“œ', key: m.key } })

  const fs = require("fs")
  const path = require("path")

  let totalCase = 0;
  const caseFile = path.join(__dirname, './alipai-cmd.js');
  if (fs.existsSync(caseFile)) {
      const content = fs.readFileSync(caseFile, 'utf8');
      totalCase = (content.match(/case\s+['"`]/g) || []).length;
  }

  let totalPlugin = 0;
  const pluginsDir = path.join(__dirname, './plugins');
  const countJsFiles = (dir) => {
      let count = 0;
      for (const file of fs.readdirSync(dir)) {
          const fullPath = path.join(dir, file);
          if (fs.statSync(fullPath).isDirectory()) count += countJsFiles(fullPath);
          else if (file.endsWith('.js')) count++;
      }
      return count;
  };
  if (fs.existsSync(pluginsDir)) totalPlugin = countJsFiles(pluginsDir);

  const totalFitur = totalCase + totalPlugin;
  const lastUpdate = new Date().toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' })

  const msgii = await generateWAMessageFromContent(m.chat, {
    viewOnceMessageV2Extension: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.fromObject({
            text: "*ðŸ’» SEWA BOT MURAH*"
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [{
              body: proto.Message.InteractiveMessage.Body.fromObject({}),
              footer: proto.Message.InteractiveMessage.Footer.fromObject({}),
              header: proto.Message.InteractiveMessage.Header.fromObject({
                title: `
ðŸ¤– *${global.botname}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸŽ¯ *${totalFitur}+ Fitur*

ðŸ’° *HARGA SEWA:*
â€¢ 1 Bulan: Rp 10.000
â€¢ 3 Bulan: Rp 25.000
â€¢ 6 Bulan: Rp 45.000
â€¢ 12 Bulan: Rp 80.000

ðŸ“… Terakhir Update: ${lastUpdate}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                hasMediaAttachment: true,
                ...(await prepareWAMessageMedia(
                  { image: { url: global.image.menu } },
                  { upload: alip.waUploadToServer }
                ))
              }),
              nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
                buttons: [
                  {
                    "name": "single_select",
                    "buttonParamsJson": JSON.stringify({
                      "title": "Pilih Menu",
                      "sections": [{
                        "title": "Menu Utama",
                        "rows": [
                          { "title": "ðŸ“‹ Menu Bot", "id": ".menu" }
                        ]
                      }]
                    })
                  },
                  {
                    "name": "cta_url",
                    "buttonParamsJson": `{\"display_text\":\"ðŸ’¬ CONTACT OWNER\",\"url\":\"${global.linkOwner}\",\"merchant_url\":\"${global.linkOwner}\"}`
                  }
                ]
              })
            }]
          })
        })
      }
    }
  }, { userJid: m.sender, quoted: m })

  await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id })
}
break;

case "script": {
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ“œ', key: m.key } })

  const fs = require("fs")
  const path = require("path")

  // Hitung total case
  let totalCase = 0;
  const caseFile = path.join(__dirname, './alipai-cmd.js');
  if (fs.existsSync(caseFile)) {
      const content = fs.readFileSync(caseFile, 'utf8');
      totalCase = (content.match(/case\s+['"`]/g) || []).length;
  }

  // Hitung total plugin
  let totalPlugin = 0;
  const pluginsDir = path.join(__dirname, './plugins');
  const countJsFiles = (dir) => {
      let count = 0;
      for (const file of fs.readdirSync(dir)) {
          const fullPath = path.join(dir, file);
          if (fs.statSync(fullPath).isDirectory()) count += countJsFiles(fullPath);
          else if (file.endsWith('.js')) count++;
      }
      return count;
  };
  if (fs.existsSync(pluginsDir)) totalPlugin = countJsFiles(pluginsDir);

  // Total fitur = case + plugin
  const totalFitur = totalCase + totalPlugin;

  const lastUpdate = new Date().toLocaleDateString('id-ID', { day: '2-digit', month: 'long', year: 'numeric' })

  const msgii = await generateWAMessageFromContent(m.chat, {
    viewOnceMessageV2Extension: {
      message: {
        messageContextInfo: {
          deviceListMetadata: {},
          deviceListMetadataVersion: 2
        },
        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
          body: proto.Message.InteractiveMessage.Body.fromObject({
            text: "*ðŸ“Œ Script Info*"
          }),
          carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
            cards: [{
              body: proto.Message.InteractiveMessage.Body.fromObject({}),
              footer: proto.Message.InteractiveMessage.Footer.fromObject({}),
              header: proto.Message.InteractiveMessage.Header.fromObject({
                title: `
ðŸ¤– Wts ${global.botname}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- *${totalFitur}+* fitur lengkap, menu stiker, maker, fun, tools, dll ( *Include premium apikey* )
- Auto downloader
- *Sewa bot & premium bot serba otomatis* 
- *Smart auto ai* Menggunakan sessions 
- *rapih & bersih* â€” kode mudah dibaca + cocok untuk pemula  
- *selalu diupdate* â€” maintenance rutin & teknologi terbaru  
- Menu button simple & base struktur rapi
- anti over-limit / anti bad session
- No enc â€” siap online 24/7
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`,
                hasMediaAttachment: true,
                ...(await prepareWAMessageMedia(
                  { image: { url: global.image.menu } },
                  { upload: alip.waUploadToServer }
                ))
              }),
              nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
                buttons: [
                  {
                    "name": "cta_url",
                    "buttonParamsJson": `{\"display_text\":\"CONTACT OWNER\",\"url\":\"${global.linkOwner}\",\"merchant_url\":\"${global.linkOwner}\"}`
                  },
                  {
                    "name": "cta_url",
                    "buttonParamsJson": `{\"display_text\":\"${global.namaSaluran}\",\"url\":\"${global.linkSaluran}\",\"merchant_url\":\"${global.linkSaluran}\"}`
                  }
                ]
              })
            }]
          })
        })
      }
    }
  }, { userJid: m.sender, quoted: m })

  await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id })
}
break;
case "bom":
case "gamebom": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
    
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    // Buat session game bom
    if (!global.bomGames) global.bomGames = {};
    
    const currentGame = global.bomGames[m.sender];
    if (currentGame && currentGame.active) {
        return Reply('ðŸŽ® Kamu masih punya game bom aktif!\nGunakan *.jawabbom [angka]* untuk melanjutkan.');
    }
    
    // Setup game baru
    const bombPosition = Math.floor(Math.random() * 10) + 1; // Bom di posisi 1-10
    const revealed = Array(10).fill('â¬œ');
    
    global.bomGames[m.sender] = {
        active: true,
        bomb: bombPosition,
        revealed: revealed,
        score: 0,
        level: 1,
        startTime: Date.now()
    };
    
    Reply(`
ðŸ’£ *GAME BOM* ðŸ’£

ðŸŽ¯ Level: 1
ðŸ’° Score: 0
â° Waktu: Unlimited

ðŸ“¦ Pilihan: 
1. â¬œ 2. â¬œ 3. â¬œ 4. â¬œ 5. â¬œ
6. â¬œ 7. â¬œ 8. â¬œ 9. â¬œ 10. â¬œ

ðŸŽ® Pilih angka 1-10 dengan:
.jawabbom [angka]

ðŸ’¡ Tips: Hanya ada 1 bom di antara 10 kotak!
ðŸŽ Hadiah: +5 limit setiap level berhasil!
    `.trim());
    break;
}

case "jawabbom": {
    if (!text) return Reply('âŒ Format: .jawabbom [angka]\nContoh: .jawabbom 5');
    
    const angka = parseInt(text);
    if (isNaN(angka) || angka < 1 || angka > 10) {
        return Reply('âŒ Masukkan angka 1-10 saja!');
    }
    
    if (!global.bomGames || !global.bomGames[m.sender]) {
        return Reply('âŒ Tidak ada game bom aktif!\nKetik *.bom* untuk mulai bermain.');
    }
    
    const game = global.bomGames[m.sender];
    if (!game.active) {
        return Reply('âŒ Game sudah selesai!\nKetik *.bom* untuk mulai baru.');
    }
    
    // Cek apakah kena bom
    if (angka === game.bomb) {
        // KENA BOM!
        game.active = false;
        game.revealed[angka-1] = 'ðŸ’£';
        
        Reply(`
ðŸ’¥ *KENA BOM!* ðŸ’¥

ðŸ“¦ Kotak ${angka} berisi BOM!

${formatBoxes(game.revealed)}

ðŸŽ® Game Over!
ðŸ’° Final Score: ${game.score}
ðŸ† Level reached: ${game.level}

Ketik *.bom* untuk main lagi!
        `.trim());
        
    } else {
        // SELAMAT!
        game.score += 10 * game.level;
        game.revealed[angka-1] = 'âœ…';
        
        // Naik level jika semua kotak sudah terbuka kecuali bom
        const openedBoxes = game.revealed.filter(box => box !== 'â¬œ').length;
        if (openedBoxes >= 9) {
            game.level++;
            game.revealed = Array(10).fill('â¬œ');
            game.bomb = Math.floor(Math.random() * 10) + 1;
            
            // Beri reward limit
            for (let i = 0; i < 5; i++) {
                addLimit(m.sender, global.isPrem(m.sender), isCreator);
            }
            
            Reply(`
ðŸŽ‰ *LEVEL COMPLETE!* ðŸŽ‰

${formatBoxes(game.revealed)}

ðŸ’° Score: ${game.score} (+50)
â¬†ï¸ Level Up: ${game.level}
ðŸŽ Reward: +5 limit!

ðŸ“¦ Level ${game.level} dimulai...
Bom telah dipindahkan!

.jawabbom [angka] untuk melanjutkan
            `.trim());
            
        } else {
            Reply(`
âœ… *AMAN!* âœ…

Kotak ${angka} tidak ada bom!

${formatBoxes(game.revealed)}

ðŸ’° Score: ${game.score} (+${10 * game.level})
ðŸŽ¯ Level: ${game.level}
ðŸ“¦ Sisa kotak: ${9 - openedBoxes}

.jawabbom [angka] untuk melanjutkan
            `.trim());
        }
    }
    break;
}

case "nyerahbom":
case "quitbom": {
    if (!global.bomGames || !global.bomGames[m.sender]) {
        return Reply('âŒ Tidak ada game bom aktif!');
    }
    
    const game = global.bomGames[m.sender];
    game.active = false;
    
    Reply(`
ðŸ³ï¸ *MENYERAH!* ðŸ³ï¸

ðŸ’° Final Score: ${game.score}
ðŸ† Level reached: ${game.level}

Ketik *.bom* untuk main lagi!
    `.trim());
    break;
    }

case "stikerrandom": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/random?apikey=${global.apikeyalip}`;

    // langsung ambil binary image
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
    console.log(e);
  }
}
break;

case "tvstiker": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  if (!text) return Reply("âŒ Contoh penggunaan: .tvstiker alip AI");

  try {
    const axios = require("axios");
    const namaText = encodeURIComponent(text.trim());
    const url = `${global.btc}/api/ephoto/televisi?apikey=${global.apikeyalip}&text=${namaText}`;

    // ambil gambar sebagai binary
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    // kirim sebagai stiker
    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker TV, coba lagi nanti!");
    console.log(e);
  }
}
break;

case "stikergojo": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/gojosatoru?apikey=${global.apikeyalip}`;

    // ambil langsung binary image
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
    console.log(e);
  }
}
break;

case "stikeranime": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/anime?apikey=${global.apikeyalip}`;
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
  }
}
break;
case "stikerspongebob": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/spongebob?apikey=${global.apikeyalip}`;

    // langsung ambil binary image
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
    console.log(e);
  }
}
break;
case "hdvid":
case "tohdvid":
case "hdvidio":
case "hdvideo": {
 if (!/video/.test(mime)) 
 return Reply(`Video tidak ditemukan!`);
 
 await Reply('Memproses Peningkatan Kualitas Video â³');
 
 let q = m.quoted ? m.quoted : m;
 let mediaBuffer = await downloadContentFromMessage(q.msg || q, 'video');
 let bufferArray = [];
 for await (const chunk of mediaBuffer) {
 bufferArray.push(chunk);
 }
 const media = Buffer.concat(bufferArray);
 
 let video = Math.floor(Math.random() * 100) + 1;
 const inputFilePath = `./input${video}.mp4`;
 const outputFilePath = `./output${video}.mp4`;
 
 fs.writeFileSync(inputFilePath, media);
 
 const ffmpegCommand = `
ffmpeg -y -i ${inputFilePath} \
-map_metadata 0 -map 0:v:0 -map 0:a? \
-vf "scale=iw*2:ih*2:flags=lanczos,
hqdn3d=1.5:1.5:6:6,
unsharp=5:5:1.0,
eq=brightness=0.03:contrast=1.15:saturation=1.1" \
-c:v libx264 -profile:v high -level 4.2 \
-preset veryslow -crf 18 -pix_fmt yuv420p \
-c:a copy -movflags +faststart \
${outputFilePath}`.replace(/\s+/g, ' ');

 exec(ffmpegCommand, (error) => {
 if (error) {
 return Reply('âŒ Gagal memproses video');
 }
 
 if (fs.existsSync(outputFilePath)) {
 const buffer = fs.readFileSync(outputFilePath);
 alip.sendMessage(m.chat, { 
 caption: `Berhasil HD Video âœ…`,
 video: buffer,
 mimetype: 'video/mp4'
 }, { quoted: m });
 
 fs.unlinkSync(inputFilePath);
 fs.unlinkSync(outputFilePath);
 } else {
 Reply('âŒ Video output tidak ditemukan');
 }
 });
}
break;
case 'tofootball': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tofootball*`);
    }
    m.reply("âš½ Mengubah fotomu jadi pemain sepak bola profesional... Tunggu bentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ”¥", key: m.key } });

    const PROMPT_FOOTBALL = `
    Transform the person in the image into a professional football (soccer) player 
    wearing a modern team uniform. Place them on a football field under bright stadium lights. 
    Maintain their original face, expression, and hairstyle. 
    Add realistic sports lighting, motion blur, and shadow for a dynamic action look. 
    The photo should look like an official sports poster or media photo.
    `;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_FOOTBALL)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;
//================================================================================

case 'cecankorea': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch('https://api.siputzx.my.id/api/r/cecan/korea');
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ“¸ Sukses :v'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[CECAN_KOREA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanjiso': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/jiso?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto Jiso khusus buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_JISO ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanryujin': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/ryujin?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto Ryujin khusus buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_RYUJIN ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanrose': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/rose?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto Rose khusus buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_ROSE ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanvietnam': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/vietnam?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Vietnam buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_VIETNAM ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanchina': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/china?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe China buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_CHINA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanjapan': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/japan?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Jepang buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_JAPAN ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanthailand': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/thailand?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Thailand buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_THAILAND ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecannaxie': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/justinaxie?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Justina Xie buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_JUSTINAXIE ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanhijaber': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/hijaber?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe hijaber buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_HIJABER ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanindonesia': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/indonesia?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Indonesia buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_INDONESIA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanmalaysia': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/malaysia?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();
    await alip.sendMessage(m.chat, { image: buffer, caption: 'ðŸ“¸ Nih foto cewe Malaysia buat lu!' }, { quoted: m });
  } catch (e) {
    console.error('[CECAN_MALAYSIA ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case 'cecanjeni': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    const res = await fetch(`${global.btc}/api/cecan/jeni?apikey=${global.apikeyalip}`);
    if (!res.ok) throw new Error('Gagal mengambil gambar');

    const buffer = await res.buffer();

    await alip.sendMessage(
      m.chat,
      {
        image: buffer,
        caption: 'ðŸ“¸ Nih foto Jeni khusus buat lu!'
      },
      { quoted: m }
    );
  } catch (e) {
    console.error('[CECAN_JENI ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat mengambil gambar.');
  }
};
break

case "stikermukalu": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/mukalu?apikey=${global.apikeyalip}`;

    // langsung ambil binary image
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
    console.log(e);
  }
}
break;

case "stikerpentol": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/pentol?apikey=${global.apikeyalip}`;
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
  }
}
break;

// =============== FITUR : TAFSIR MIMPI ===============
case 'tafsirmimpi': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!text) return m.reply(`âŒ Contoh penggunaan: ${prefix + command} bertemu setan`)

    try {
        let url = `https://api.siputzx.my.id/api/primbon/tafsirmimpi?mimpi=${encodeURIComponent(text)}`
        let res = await fetch(url)
        let data = await res.json()

        if (!data || !data.status) return m.reply('âš ï¸ Tafsir mimpi tidak ditemukan.')

        let keyword = data.data?.keyword || "-"
        let solusi = data.data?.solusi || "Tidak ada solusi."

        let hasil = `ðŸŒ™ *Tafsir Mimpi*\n\n`
        hasil += `ðŸ”‘ Keyword : *${keyword}*\n`
        hasil += `ðŸ“Œ Solusi : ${solusi}`

        alip.sendMessage(m.chat, { text: hasil }, { quoted: m })
    } catch (e) {
        console.error("âŒ TafsirMimpi Error:", e)
        m.reply("âš ï¸ Gagal mengambil tafsir mimpi, coba lagi nanti.")
    }
}
break
// ====================================================

case 'aiedit': {
  if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    if (!quoted) return Reply(`âš ï¸ Reply foto dengan caption *${prefix + command} <prompt>*`)
    if (!/image/.test(mime)) return Reply(`âš ï¸ File harus berupa gambar!`)
    if (!text) return Reply(`âš ï¸ Masukkan prompt deskripsi!\n\nðŸ’¡ Contoh:\n${prefix + command} jadikan figurin anime dengan background studio`)
    
    try {
        let buffer = await quoted.download()

        // buat pesan awal progress bar
        let progress = 0
        let total = 20
        const makeBar = (progress) => {
            let filled = 'â–ˆ'.repeat(progress)
            let empty = 'â–‘'.repeat(total - progress)
            return `[${filled}${empty}] ${(progress * 5)}%`
        }

        let statusMsg = await alip.sendMessage(m.chat, {
            text: `â³ *Sedang memproses...*\n\nðŸŽ¨ Prompt: _${text}_\n${makeBar(progress)}`
        }, { quoted: m })

        // simulasi progress sambil nunggu hasil convert
        let interval = setInterval(async () => {
            if (progress < total) {
                progress++
                await alip.sendMessage(m.chat, {
                    edit: statusMsg.key,
                    text: `â³ *Sedang memproses...*\n\nðŸŽ¨ Prompt: _${text}_\n${makeBar(progress)}`
                })
            }
        }, 2000) // update tiap 2 detik

        // jalankan convert AI
        let hasil = await convert(buffer, text)

        // stop progress bar
        clearInterval(interval)

        // update status jadi selesai
        await alip.sendMessage(m.chat, {
            edit: statusMsg.key,
            text: `âœ… *Selesai!* Gambar berhasil digenerate.\n\nðŸŽ¨ Prompt: _${text}_`
        })

        // kirim hasil generate
        await alip.sendMessage(m.chat, {
            image: { url: hasil },
            caption: `âœ¨ *Berhasil Generate!* ðŸŽ‰\n\nðŸŽ¨ Prompt: _${text}_`
        }, { quoted: m })

    } catch (e) {
        console.error(e)
        m.reply(`Prompt tidak valid coba yang lain:\n${e.message}`)
    }
    break
}

case 'todino': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}todino*`);
    }
    m.reply("ðŸ“¸ Membuat fotomu dalam gaya photobooth polaroid... Tunggu sebentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ¦–", key: m.key } });

    const PROMPT_DINO = `
    Create a picture taken with a polaroid camera. 
    Make it look like a 3-grid photobooth composition. 
    The photo should appear natural and casual, without any strong props or clear subject focus. 
    Add a soft blur and consistent lighting effect, resembling a flash in a dark room.
    Do not alter the face of the person in the original image.
    Replace the background with a white curtain. 
    In the photo, the girl should be gently holding the yellow dinosaurâ€™s cheek, 
    and the yellow dinosaur should be holding the girlâ€™s head affectionately. 
    Add another cute and playful pose in one of the frames to complete the photobooth style.
    The overall aesthetic should look authentic, warm, and slightly vintage, like a real polaroid photo.
    `;

    async function uploadUguu(buffer, filename = "file.jpg") {
        const FormData = require('form-data');
        const form = new FormData();
        form.append("files[]", buffer, { filename });
        const res = await fetch("https://uguu.se/upload.php", { method: "POST", body: form });
        if (!res.ok) throw new Error(`Upload gagal: ${res.status}`);
        const json = await res.json();
        const url = json?.files?.[0]?.url;
        if (!url) throw new Error("Gagal mendapatkan URL dari Uguu");
        return url;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadUguu(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_DINO)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'topenjara': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}topenjara*`);
    }
    m.reply("ðŸš” Mengubah fotomu jadi gaya tahanan penjara Indonesia... Tunggu sebentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ§±", key: m.key } });

    const PROMPT_PENJARA = `
    Ubah orang di foto ini menjadi tahanan di penjara Indonesia. 
    Gunakan pakaian tahanan khas Indonesia berwarna oranye dengan tulisan â€œTAHANANâ€ di dada.
    Tangan orang tersebut diborgol di depan tubuhnya, dan latar belakangnya adalah ruang penjara Indonesia 
    dengan jeruji besi dan pencahayaan realistis.
    Pastikan wajah tetap sama dan tidak diubah, hanya ubah pakaian dan suasananya agar tampak realistis seperti foto sungguhan.
    `;

    async function uploadUguu(buffer, filename = "file.jpg") {
        const FormData = require('form-data');
        const form = new FormData();
        form.append("files[]", buffer, { filename });
        const res = await fetch("https://uguu.se/upload.php", { method: "POST", body: form });
        if (!res.ok) throw new Error(`Upload gagal: ${res.status}`);
        const json = await res.json();
        const url = json?.files?.[0]?.url;
        if (!url) throw new Error("Gagal mendapatkan URL dari Uguu");
        return url;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadUguu(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_PENJARA)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;


case 'todonghua':
case 'tomanhwa':
case 'toanime':
case 'tomanga': {
    if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${command}*`);
    }
    let PROMPT_STYLE;
    let captionText;

    switch (command) {
        case 'todonghua':
            captionText = 'Donghua (Chinese Animation)';
            PROMPT_STYLE = `Please convert the user's image into a *high-resolution Donghua style* portrait. The resulting image must have soft lighting, intricate character design reminiscent of Chinese animation (e.g., Mo Dao Zu Shi, Tian Bao Fu Yao), a detailed fantasy background, and elegant color grading. Preserve the original subject's facial features and expression while fully applying the animation style.`;
            break;
        case 'tomanhwa':
            captionText = 'Manhwa (Korean Webtoon)';
            PROMPT_STYLE = `Please convert the user's image into a *Manhwa/Korean Webtoon style* illustration. The result should feature sharp, detailed line art, bright, saturated colors, distinct cell shading, and a dramatic, high-contrast look typical of popular action or romance manhwa. The subject should be stylized with large, expressive eyes and a modern feel.`;
            break;
        case 'toanime':
            captionText = 'Anime (Japanese Animation)';
            PROMPT_STYLE = `Please convert the user's image into a *classic Japanese Anime style* portrait. The resulting image must have clean line art, soft, cinematic lighting, a focus on character expressions, and vibrant, yet sometimes pastel, color palette. The background should be simplified or follow a detailed anime background structure.`;
            break;
        case 'tomanga':
            captionText = 'Manga (Japanese Comic)';
            PROMPT_STYLE = `Please convert the user's image into a *traditional Japanese Manga style* illustration. The resulting image must be entirely *monochrome (black and white)*, using strong lines, cross-hatching, and screen tones (halftone dots) for shading. The focus should be on dramatic composition and dynamic inking style, typical of Shonen or Shojo manga panels.`;
            break;
    }

    Reply(`ðŸŽ¨ Mengubah fotomu jadi versi *${captionText}*... Mohon tunggu sebentar ya!`);
    await alip.sendMessage(m.chat, { react: { text: "âœ¨", key: m.key } });

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);

        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_STYLE)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error saat konversi style: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }

}
break;

case 'tovn': {
    if (!m.quoted) return Reply(`ðŸŽ§ Kirim atau reply audio/video yang mau dikonversi jadi VN.`);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/audio|video/.test(mime)) return Reply(`âŒ File tidak valid. Reply ke audio atau video!`);

    try {
        const { exec } = require("child_process");
        const { promisify } = require("util");
        const execPromise = promisify(exec);
        const fs = require("fs");
        const path = require("path");
        const axios = require("axios");
        const tmpDir = path.join(__dirname, "tmp");
        if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
        const inputPath = path.join(tmpDir, `input_${Date.now()}`);
        const outputPath = path.join(tmpDir, `output_${Date.now()}.opus`);
        const buffer = await q.download();
        fs.writeFileSync(inputPath, buffer);
        await execPromise(`ffmpeg -i "${inputPath}" -c:a libopus -b:a 48k -vbr on -ar 48000 -ac 1 "${outputPath}"`);
        const vn = fs.readFileSync(outputPath);
        await alip.sendMessage(m.chat, { audio: vn, mimetype: 'audio/ogg; codecs=opus', ptt: true }, { quoted: m });
        fs.unlinkSync(inputPath);
        fs.unlinkSync(outputPath);

    } catch (err) {
        console.error(err);
        Reply(`âŒ Terjadi kesalahan saat mengonversi ke VN.`);
    }
}
break;

case 'tofigure': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tofigure*`);
    }
    m.reply("ðŸŽ¨ Mengubah fotomu jadi versi figure realistis... Mohon tunggu sebentar ya!");
    await alip.sendMessage(m.chat, { react: { text: "âœ¨", key: m.key } });

    const PROMPT_FIGURE = `Using the nano-banana model, a commercial 1/7 scale figurine of the character in the picture was created, depicting a realistic style and a realistic environment. The figurine is placed on a computer desk with a round transparent acrylic base. There is no text on the base. The computer screen shows the Zbrush modeling process of the figurine. Next to the computer screen is a BANDAI-style toy box with the original painting printed on it.`;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const fs = require('fs');
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_FIGURE)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'acc': {
  if (!isRegistered(m.sender))
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  if (!m.isGroup)
    return Reply('âŒ Hanya bisa di dalam grup.');

  if (!m.isAdmin)
    return Reply('âŒ Hanya admin grup yang bisa menggunakan perintah ini.');

  // Tambahkan limit setelah lolos pengecekan
  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const pending = await alip.groupRequestParticipantsList(m.chat);
    if (pending.length === 0)
      return Reply('âœ… Tidak ada member yang minta bergabung.');

    if (args[0] === 'all') {
      await alip.groupRequestParticipantsUpdate(m.chat, pending.map(u => u.jid), 'approve');
      return Reply(`âœ… Semua member yang meminta bergabung sudah di-ACC (${pending.length} orang).`);
    } else {
      let jumlah = parseInt(args[0]);
      if (isNaN(jumlah) || jumlah < 1)
        return Reply('Masukkan jumlah yang valid!\nContoh: .acc 1 atau .acc all');

      let selected = pending.slice(0, jumlah);
      await alip.groupRequestParticipantsUpdate(m.chat, selected.map(u => u.jid), 'approve');
      return Reply(`âœ… Berhasil ACC ${selected.length} member yang meminta gabung.`);
    }
  } catch (err) {
    console.error('Error in acc command:', err);
    return Reply('âŒ Terjadi kesalahan saat memproses perintah. Coba lagi nanti.');
  }
}
break;

case 'tolakacc': {
  if (!isRegistered(m.sender))
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  if (!m.isGroup)
    return Reply('âŒ Hanya bisa di dalam grup.');

  if (!m.isAdmin)
    return Reply('âŒ Hanya admin grup yang bisa menggunakan perintah ini.');

  // Tambahkan limit setelah lolos pengecekan
  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const pending = await alip.groupRequestParticipantsList(m.chat);
    if (pending.length === 0)
      return Reply('âœ… Tidak ada member yang minta bergabung.');

    if (args[0] === 'all') {
      await alip.groupRequestParticipantsUpdate(m.chat, pending.map(u => u.jid), 'reject');
      return Reply(`âœ… Semua permintaan gabung sudah DITOLAK (${pending.length} orang).`);
    } else {
      let jumlah = parseInt(args[0]);
      if (isNaN(jumlah) || jumlah < 1)
        return Reply('Masukkan jumlah yang valid!\nContoh: .tolakacc 1 atau .tolakacc all');

      let selected = pending.slice(0, jumlah);
      await alip.groupRequestParticipantsUpdate(m.chat, selected.map(u => u.jid), 'reject');
      return Reply(`âœ… Berhasil menolak ${selected.length} permintaan gabung.`);
    }
  } catch (err) {
    console.error('Error in tolakacc command:', err);
    return Reply('âŒ Terjadi kesalahan saat memproses perintah. Coba lagi nanti.');
  }
}
break;

case 'tovideo':
case 'tojpg':
case 'toimg': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi)
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit)
    if (!m.quoted)
        return Reply('Reply stikernya dulu, kak ðŸ™‚')

    const mime = (m.quoted.msg || m.quoted).mimetype || ''
    if (!/webp/i.test(mime))
        return Reply('Yang di-reply harus stiker (.webp).')

    addLimit(m.sender, global.isPrem(m.sender), isCreator)

    try {
        const mediaBuffer = await downloadContentFromMessage(m.quoted.msg || m.quoted, 'image')
        let bufferArray = []
        for await (const chunk of mediaBuffer) {
            bufferArray.push(chunk)
        }
        const media = Buffer.concat(bufferArray)

        if (command === 'tovideo') {
            Reply('â³ Mengonversi stiker ke video...')

            async function uploadFile(buffer, mimeType) {
                const ext = 'webp'
                const code = crypto.randomBytes(3).toString('hex')
                const fileName = `${code}-${Date.now()}.${ext}`
                const filePathGitHub = `uploads/${fileName}`
                const base64Content = buffer.toString('base64')
                
                const repos = ['dat1','dat2','dat3','dat4']
                const targetRepo = repos[Math.floor(Math.random()*repos.length)]
                const owner = 'alifalfarel25-commits'
                const branch = 'main'
                const githubToken = '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'
                
                const response = await axios.put(
                    `https://api.github.com/repos/${owner}/${targetRepo}/contents/${filePathGitHub}`,
                    { 
                        message: `Upload file ${fileName}`, 
                        content: base64Content, 
                        branch: branch 
                    },
                    { 
                        headers: { 
                            Authorization: `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github+json'
                        } 
                    }
                )
                
                return `https://raw.githubusercontent.com/${owner}/${targetRepo}/${branch}/${filePathGitHub}`
            }

            const tempUrl = await uploadFile(media, mime)
            const apiUrl = `${global.btc}/api/tools/webp2mp4?apikey=${global.apikeyalip}&url=${encodeURIComponent(tempUrl)}`
            const response = await axios.get(apiUrl)

            if (!response.data.status || !response.data.result)
                throw new Error('Convert gagal')

            await alip.sendMessage(
                m.chat,
                {
                    video: { url: response.data.result },
                    caption: 'âœ… Stiker berhasil dikonversi ke video!'
                },
                { quoted: m }
            )

        } else {
            Reply('â³ Mengonversi stiker ke gambar...')

            async function uploadFile(buffer, mimeType) {
                const ext = 'webp'
                const code = crypto.randomBytes(3).toString('hex')
                const fileName = `${code}-${Date.now()}.${ext}`
                const filePathGitHub = `uploads/${fileName}`
                const base64Content = buffer.toString('base64')
                
                const repos = ['dat1','dat2','dat3','dat4']
                const targetRepo = repos[Math.floor(Math.random()*repos.length)]
                const owner = 'alifalfarel25-commits'
                const branch = 'main'
                const githubToken = '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'
                
                const response = await axios.put(
                    `https://api.github.com/repos/${owner}/${targetRepo}/contents/${filePathGitHub}`,
                    { 
                        message: `Upload file ${fileName}`, 
                        content: base64Content, 
                        branch: branch 
                    },
                    { 
                        headers: { 
                            Authorization: `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github+json'
                        } 
                    }
                )
                
                return `https://raw.githubusercontent.com/${owner}/${targetRepo}/${branch}/${filePathGitHub}`
            }

            const tempUrl = await uploadFile(media, mime)
            const apiUrl = `${global.btc}/api/tools/webp2png?apikey=${global.apikeyalip}&url=${encodeURIComponent(tempUrl)}`
            const response = await axios.get(apiUrl)

            if (!response.data.status || !response.data.result)
                throw new Error('Convert gagal')

            const imgBuffer = await axios.get(response.data.result, { responseType: 'arraybuffer' })

            await alip.sendMessage(
                m.chat,
                {
                    image: Buffer.from(imgBuffer.data),
                    caption: 'âœ… Stiker berhasil dikonversi ke gambar!'
                },
                { quoted: m }
            )
        }

    } catch (e) {
        Reply('âŒ Gagal mengonversi stiker')
    }
}
break

case 'faktadunia': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  const listFakta = [
    // ðŸŒŒ ALAM SEMESTA & ASTRONOMI
    "ðŸŒ  **Bintang Zombie**: Jenis bintang 'TZO' bisa 'hidup kembali' dengan mencuri materi dari bintang tetangga, padahal seharusnya sudah mati.",
    "ðŸ•³ï¸ **Lubang Hitam Bernyanyi**: Lubang hitam di gugus Perseus menghasilkan gelombang suara 57 oktaf di bawah C, tapi tak bisa didengar manusia.",
    "â˜„ï¸ **Oumuamua**: Objek antarbintang pertama yang terdeteksi (2017) punya percepatan aneh, diduga pesawat alien oleh beberapa ilmuwan.",
    "ðŸŒ‘ **Bulan Punya Gempa**: 'Moonquake' bisa bertahan 30 menit karena tidak ada atmosfer untuk meredam getaran.",

    // ðŸ”¬ SAINS & TEKNOLOGI
    "ðŸ§ª **Air Superionic**: Bentuk air di inti planet es seperti Uranus, bersifat padat dan cair sekaligus.",
    "âš¡ **Petir Abadi di Venezuela**: RelÃ¡mpago del Catatumbo terjadi 140-160 malam/tahun, menghasilkan ozon sebanyak hutan Amazon.",
    "ðŸ”‹ **Baterai Baghdad**: Artefak berusia 2.000 tahun diduga baterai listrik kuno, masih jadi perdebatan arkeolog.",
    "ðŸ§  **Otak Manusia = Internet**: Kapasitas penyimpanan otak ~2,5 petabyte (setara 3 juta jam video YouTube).",

    // ðŸ›ï¸ SEJARAH & ARKEOLOGI
    "ðŸº **Mekanisme Antikythera**: Komputer analog Yunani Kuno (205 SM) untuk prediksi astronomi, lebih canggih dari teknologi 1.000 tahun setelahnya.",
    "ðŸ—¿ **Moai Berbadan**: Patung Pulau Paskah ternyata punya tubuh terkubur dengan tulisan misterius Rongorongo.",
    "ðŸ“œ **Perpustakaan Ashurbanipal**: Perpustakaan kuno (600 SM) di Iraq menyimpan 30.000 tablet tanah liat, termasuk epos Gilgamesh.",
    "âš”ï¸ **Tentara Terakota**: Setiap patung prajurit di makam Qin Shi Huang memiliki wajah unik, belum ada yang identik.",

    // ðŸ•µï¸â€â™‚ï¸ MISTERI & KONSIPIRASI
    "ðŸ” **Proyek MKUltra**: Program rahasia CIA (1950-1970) untuk kontrol pikiran menggunakan LSD dan penyiksaan psikologis.",
    "ðŸ“¡ **Sinyal Wow!**: Sinyal radio dari rasi Sagitarius (1977) sangat kuat dan terarah, diduga pesan alien, tak pernah terulang.",
    "ðŸ‘½ **Insiden Roswell**: Militer AS awalnya mengaku temukan piring terbang (1947), lalu ubah pernyataan jadi balon cuaca.",
    "ðŸ—ºï¸ **Peta Piri Reis**: Peta abad 16 ini menggambar Antartika tanpa es, padahal benua itu baru ditemukan 1820.",

    // ðŸŒ BUMI & LINGKUNGAN
    "ðŸŒ‹ **Danau Natron**: Danau Tanzania ini bisa mengawetkan hewan jadi 'mumi' karena pH air mencapai 10,5 (sangat basa).",
    "ðŸŒ€ **Mata Sahara**: Struktur geologis raksasa di Mauritania, hanya terlihat jelas dari angkasa, asal-usulnya masih misteri.",
    "â„ï¸ **Blood Falls**: Air terjun di Antartika berwarna merah darah karena kandungan besi tinggi dari danau bawah es berusia 2 juta tahun.",
    "ðŸŒŠ **Lautan Bawah Tanah**: Di kedalaman 660km, air 3x volume laut permukaan terperangkap dalam batuan ringwoodite.",

    // ðŸ§¬ BIOLOGI & KEDOKTERAN
    "ðŸ¦  **Tardigrade**: Mikroorganisme ini bisa hidup di ruang hampa, radiasi 1.000x dosis manusia, bahkan tanpa air selama 30 tahun.",
    "ðŸ§¬ **DNA Sampah**: 98% DNA manusia disebut 'junk DNA', tapi ternyata menyimpan kode evolusi dan virus purba.",
    "ðŸ©¸ **Golden Blood**: Golongan darah Rh-null (hanya 43 orang di dunia) bisa donor universal tapi sangat berbahaya jika butuh transfusi.",
    "ðŸ§« **Mitokondria adalah Bakteri**: Organel penghasil energi ini punya DNA terpisah, diduga bakteri purba yang bersimbiosis dengan sel.",

    // ðŸ¤– TEKNOLOGI & AI
    "ðŸ“± **Ponsel Pertama (1973)**: Beratnya 1,1kg, baterai cuma 30 menit, butuh 10 jam untuk mengisi ulang.",
    "ðŸ¤– **Sophia the Robot**: Robot pertama yang dapat kewarganegaraan (Arab Saudi, 2017), tapi sebenarnya hanya AI chatbot canggih.",
    "ðŸ’¾ **1GB Pertama (1980)**: Harganya $140,000, beratnya 250kg, butuh pesawat kargo untuk mengangkut.",
    "ðŸ” **Kriptografi Kuantum**: China berhasil kirim pesan anti-hack lewat satelit quantum (2017), jarak 1.200km.",

    // ðŸŽ¨ SENI & BUDAYA
    "ðŸŽ­ **Teater Shakespeare Hilang**: Globe Theatre asli (1599) ditemukan reruntuhannya tahun 1989 di bawah gedung parkir London.",
    "ðŸŽ¼ **Nada 432Hz vs 440Hz**: Konspirasi bahwa perubahan standar nada musik (dari 432Hz ke 440Hz) oleh Nazi pengaruhi kesadaran manusia.",
    "ðŸ–¼ï¸ **Mona Lisa Punya Saudara Kembar**: Versi 'Prado Mona Lisa' di Madrid diduga dilukis bersamaan oleh murid Da Vinci.",
    "ðŸ“– **Buku Terlarang Voynich**: Naskah abad 15 dengan tanaman dan bahasa tak dikenal, bahkan AI pun gagal memecahkannya.",

    // ðŸ¦– PALEONTOLOGI
    "ðŸ¦• **Dinosaurus Berbulu**: Fosil di China membuktikan T-Rex mungkin berbulu seperti ayam, bukan bersisik seperti di film Jurassic Park.",
    "ðŸ‰ **Naga Komodo Punya Racun**: Air liurnya mengandung 50 jenis bakteri mematikan, bukan sekadar gigitan kuat.",
    "ðŸ§Š **Mammoth Beku Masih Berdarah**: Fosil Siberia (2013) mengeluarkan darah cair berkat bakteri cryoprotectant alami.",
    "ðŸ¦´ **Hobbit Flores**: Spesies manusia kerdil (Homo floresiensis) ditemukan 2003, hidup 50.000 tahun lalu setinggi 1 meter.",

    // ðŸš€ EKSPLORASI RUANG ANGKASA
    "ðŸ›°ï¸ **Sputnik 1**: Satelit pertama (1957) hanya mengirim 'beep-beep' radio, tapi memulai Perang Dingin teknologi.",
    "ðŸ‘¨â€ðŸš€ **Pendaratan Bulan yang Hilang**: Uni Luna 15 (USSR) jatuh di Bulan 20 Juli 1969, bersamaan dengan Apollo 11.",
    "ðŸŒŒ **Pilar Penciptaan**: Foto ikonik Hubble (1995) sebenarnya sudah hancur 6.000 tahun lalu, tapi cahaya baru sampai ke Bumi.",
    "ðŸª **Cincin Saturnus Menghilang**: Setiap 15 tahun, cincinnya 'lenyap' karena sudut pandang dari Bumi sejajar dengan tepiannya.",

    // ðŸ§ª KIMIA & FISIKA ANEH
    "ðŸ§Š **Es Panas (Hot Ice)**: Natrium asetat bisa membeku instan saat disentuh, melepaskan panas (eksotermik).",
    "âš›ï¸ **Quantum Entanglement**: Partikel bisa 'terhubung' jarak jauh, mengubah satu langsung mempengaruhi pasangannya.",
    "ðŸ’§ **Air Memori**: Teori kontroversial bahwa air menyimpan 'ingatan' zat terlarut walau sudah diencerkan (homeopati).",
    "ðŸ”¥ **Plasma Ke-4 Wujud Materi**: 99% alam semesta terbuat dari plasma, bukan padat/cair/gas (contoh: petir & matahari).",

    // ðŸº ARKEOLOGI MISTERIUS
    "ðŸ”® **Crystal Skulls**: Tengkorak kristal suku Maya diduga alat komunikasi alien, tapi ternyata buatan abad 19.",
    "âš’ï¸ **Baja Damascus**: Pedang abad pertengahan ini punya pola nano-tube karbon, teknologi metalurgi yang baru dipahami abad 21.",
    "ðŸ§± **Betron Romawi**: Material kuno ini bisa memperbaiki diri saat retak terkena air hujan.",
    "ðŸ—¿ **GÃ¶bekli Tepe**: Kuil berusia 12.000 tahun ini lebih tua dari pertanian, mempertanyakan ulang sejarah peradaban.",

    // ðŸ§  PSIKOLOGI & OTAK
    "ðŸ‘» **Efek Capgras**: Gangguan otak membuat penderitanya yakin keluarga/familiar digantikan oleh impostor identik.",
    "ðŸ•µï¸ **False Memory**: Otak bisa menciptakan ingatan palsu yang sangat detail hingga sulit dibedakan dengan nyata.",
    "ðŸ‘ï¸ **Blindsight**: Orang buta tetap bisa 'melihat' dan menghindari rintangan berkat sistem visual alternatif di otak.",
    "ðŸ¤¯ **Sindrom Aksen Asing**: Kerusakan otak bisa membuat seseorang tiba-tiba berbicara dengan aksen asing tanpa pernah belajar.",

    // ðŸ¦… HEWAN & TUMBUHAN UNIK
    "ðŸ¦‘ **Cumi Raksasa Mata Pizza**: Mata sebesar piring (30cm) untuk melihat di kedalaman 1.000m yang gelap total.",
    "ðŸ¯ **Madu Abadi**: Madu di makam Firaun masih bisa dimakan setelah 3.000 tahun berkat sifat antibakteri alami.",
    "ðŸœ **Semut Zombie**: Jamur Ophiocordyceps mengendalikan semut jadi 'zombie' yang mencari tempat ideal untuk menyebarkan spora.",
    "ðŸŒµ **Tanaman Menari**: Desmodium gyrans bisa gerakkan daun sendiri merespon rangsangan suara/elektromagnetik."
  ];

  // Pilih fakta random + format pesan
  const randomFakta = listFakta[Math.floor(Math.random() * listFakta.length)];
  const teks = `ðŸ”® *FAKTA RAHASIA YANG TAK PERNAH KAU DENGAR* ðŸ”®\n\n${randomFakta}\n\n_Dari ${listFakta.length}+ fakta tersembunyi di database alip_`;

  // Kirim dengan thumbnail keren
  await alip.sendMessage(m.chat, { 
    text: teks,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ¤¯ ${botname2} - fakta misterius`,
        body: 'Dapatkan 1 fakta langka setiap hari!',
        thumbnailUrl: global.image.menu,
        sourceUrl: 'https://en.wikipedia.org/wiki/List_of_unexplained_phenomena',
        mediaType: 1,
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

case "faktaunik": case "tahukahkamu": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    try {
        let response = await fetch("https://api.ownblox.biz.id/api/tahukahkamu");
        let data = await response.json();
        if (data?.result) {
            Reply(`*${data.result}*`);
        } else {
            Reply("Gagal mengambil fakta. Coba lagi nanti!");
        }
    } catch (error) {
        console.error(error);
        Reply("Terjadi kesalahan saat mengambil fakta!");
    }
}
    break
    
case 'soraai': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply('Contoh: .soraai kucing vs harimau');
    
    try {
        await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });
        
        const response = await fetch(`https://api-faa.my.id/faa/sora?prompt=${encodeURIComponent(text)}`);
        const data = await response.json();
        
        if (!data.status) {
            await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
            return;
        }
        
        const jobId = data.job_id;
        const checkUrl = `https://api-faa.my.id/faa/sora/status?id=${jobId}`;
        
        let videoSent = false;
        let attempts = 0;
        
        while (!videoSent && attempts < 60) {
            attempts++;
            await sleep(5000);
            
            const statusResponse = await fetch(checkUrl);
            const statusData = await statusResponse.json();
            
            if (statusData.status && !statusData.processing && statusData.result) {
                await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
                
                await alip.sendMessage(m.chat, {
                    video: { url: statusData.result.download_url },
                    caption: `ðŸŽ¬ *SORA AI VIDEO*\n\nðŸ“ ${text}`,
                    gifPlayback: false
                }, { quoted: m });
                
                videoSent = true;
            }
        }
        
        if (!videoSent) {
            await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
        }
        
    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
    }
}
break;
 
case "gpt5plus": {
  if (!text) return Reply("format: .gpt5plus <pertanyaan>")
  
  try {
    const response = await axios.get(`https://api.yupra.my.id/api/ai/gpt5?text=${encodeURIComponent(text)}`)
    
    if (response.data.status && response.data.result) {
      Reply(response.data.result)
    } else {
      Reply("gpt5 gabisa jawab ðŸ˜¡")
    }
  } catch {
    Reply("error nyambung ke api ðŸ˜¡")
  }
}
break
    
case 'gptonline': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
 if (!text) return alip.sendMessage(m.chat, { text: 'Contoh: .gptonline halo apa kabar?' });

  try {
    const axios = require('axios');
    const cheerio = require('cheerio');
    const FormData = require('form-data');

    // fetch halaman untuk dapatkan nonce, botId, postId
    let { data } = await axios.get("https://gptonline.ai/id/chatgpt-online/");
    let $ = cheerio.load(data);
    let div = $('.wpaicg-chat-shortcode');
    let nonce  = div.attr('data-nonce');
    let botId  = div.attr('data-bot-id');
    let postId = div.attr('data-post-id');

    // build form
    let form = new FormData();
    form.append("_wpnonce", nonce);
    form.append("post_id", postId);
    form.append("url", "https://gptonline.ai/id/chatgpt-online/");
    form.append("action", "wpaicg_chat_shortcode_message");
    form.append("message", text);
    form.append("bot_id", botId);
    form.append("chat_bot_identity", "custom_bot_1040");
    form.append("wpaicg_chat_history", "[]");
    form.append("wpaicg_chat_client_id", "LCgGOMeIOC");

    // kirim request ke AJAX endpoint
    let res = await axios.post(
      "https://gptonline.ai/id/wp-admin/admin-ajax.php",
      form,
      { headers: form.getHeaders() }
    );

    let hasil = res.data?.data?.message || res.data?.data || 'Gagal mendapatkan respon.';
    await alip.sendMessage(m.chat, { text: hasil });

  } catch (e) {
    console.log(e);
    await alip.sendMessage(m.chat, { text: 'Terjadi error, coba lagi nanti.' });
  }
}
break;

case 'jadidisney': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  const fs = require('fs');
  const axios = require('axios');
  const { ImageUploadService } = require('node-upload-images');

  let qmsg = m.quoted ? m.quoted : m;
  let mime = (qmsg.msg || qmsg).mimetype || '';

  if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

  await alip.sendMessage(m.chat, { react: { text: 'ðŸŽ¨', key: m.key } });

  try {
    // Download media sementara
    let media = await alip.downloadAndSaveMediaMessage(qmsg);

    // Upload ke pixhost
    const service = new ImageUploadService('postimages.org');
    let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');
    let imgUrl = directLink.toString();
    await fs.unlinkSync(media);

    // Hit API jadidisney â†’ hasil langsung image
    let apiUrl = `${global.btc}/api/maker/jadidisney?apikey=${global.apikeyalip}&url=${encodeURIComponent(imgUrl)}`;
    let response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

    // Kirim langsung ke user
    await alip.sendMessage(m.chat, {
      image: response.data,
      caption: `âœ… *EFEK DISNEY BERHASIL*`
    }, { quoted: m });

  } catch (err) {
    console.error(err);
    let msg = err.response?.statusText || err.message || 'Terjadi error';
    m.reply(`âŒ Error: ${msg}`);
  }
}
break;

case 'jadipixar': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  const fs = require('fs');
  const axios = require('axios');
  const { ImageUploadService } = require('node-upload-images');

  let qmsg = m.quoted ? m.quoted : m;
  let mime = (qmsg.msg || qmsg).mimetype || '';

  if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

  await alip.sendMessage(m.chat, { react: { text: 'ðŸŽ¬', key: m.key } });

  try {
    // Download media sementara
    let media = await alip.downloadAndSaveMediaMessage(qmsg);

    // Upload ke pixhost
    const service = new ImageUploadService('postimages.org');
    let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');
    let imgUrl = directLink.toString();
    await fs.unlinkSync(media);

    // Hit API jadipixar â†’ hasil langsung image
    let apiUrl = `${global.btc}/api/maker/jadipixar?apikey=${global.apikeyalip}&url=${encodeURIComponent(imgUrl)}`;
    let response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

    // Kirim hasil ke user
    await alip.sendMessage(m.chat, {
      image: response.data,
      caption: `âœ… *EFEK PIXAR BERHASIL*`
    }, { quoted: m });

  } catch (err) {
    console.error(err);
    let msg = err.response?.statusText || err.message || 'Terjadi error';
    m.reply(`âŒ Error: ${msg}`);
  }
}
break;

case 'jadigta': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  const fs = require('fs');
  const axios = require('axios');
  const { ImageUploadService } = require('node-upload-images');

  let qmsg = m.quoted ? m.quoted : m;
  let mime = (qmsg.msg || qmsg).mimetype || '';

  if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

  await alip.sendMessage(m.chat, { react: { text: 'ðŸŽ®', key: m.key } });

  try {
    // Download media sementara
    let media = await alip.downloadAndSaveMediaMessage(qmsg);

    // Upload ke pixhost
    const service = new ImageUploadService('postimages.org');
    let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');
    let imgUrl = directLink.toString();
    await fs.unlinkSync(media);

    // Hit API jadigta langsung dengan apikey alipclutch
    let apiUrl = `${global.btc}/api/maker/jadigta?apikey=${global.apikeyalip}&url=${encodeURIComponent(imgUrl)}`;
    let { data } = await axios.get(apiUrl);

    if (!data.status) return Reply('âŒ Gagal bikin efek GTA');

    // Kirim hasil ke user
    await alip.sendMessage(m.chat, {
      image: { url: data.result },
      caption: `âœ… *EFEK GTA BERHASIL*`
    }, { quoted: m });

  } catch (err) {
    console.error(err);
    let msg = err.response?.statusText || err.message || 'Terjadi error';
    m.reply(`âŒ Error: ${msg}`);
  }
}
break;

case 'twitter': case 'xdl': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
;
  if (!q) {
    return alip.sendMessage(m.chat, { text: 'Link Twitter-nya mana?' });
  }
  if (!q.includes('x.com')) {
    return alip.sendMessage(m.chat, { text: 'Link tidak valid!' });
  }

  try {
    const axios = require("axios");
    const FormData = require("form-data");
    const cheerio = require("cheerio");

    let form = new FormData();
    form.append("q", q);
    form.append("lang", "en");
    form.append("cftoken", "");

    let { data } = await axios.post(
      "https://savetwitter.net/api/ajaxSearch",
      form,
      { headers: form.getHeaders() }
    );

    if (!data.data) {
      return alip.sendMessage(m.chat, { text: "Data kosong / tidak ditemukan" });
    }

    const $ = cheerio.load(data.data);
    const thumbnail = $(".image-tw img").attr("src");
    let result = [];

    $(".dl-action a").each((_, el) => {
      const link = $(el).attr("href");
      const label = $(el).text().trim();
      if (link && label.includes("Download MP4")) {
        result.push({
          quality: label.replace("Download MP4", "").replace(/[()]/g, "").trim(),
          url: link
        });
      }
    });

    if (result.length === 0) {
      return alip.sendMessage(m.chat, { text: "Video tidak ditemukan." });
    }

    // Kirim list URL per kualitas
    let caption = `*Semua Kualitas Tersedia:*\n\n`;
    result.forEach((v, i) => {
      caption += `${i+1}. *${v.quality}*\n${v.url}\n\n`;
    });
    await alip.sendMessage(m.chat, { text: caption });

    // Kirim preview video kualitas tertinggi (1280)
    let high = result.find(v => v.quality.includes("1280"));
    if (high) {
      await alip.sendMessage(m.chat, {
        video: { url: high.url },
        caption: `Berikut video kualitas *${high.quality}*`
      });
    } else {
      await alip.sendMessage(m.chat, { text: "Video kualitas 1280 tidak ditemukan." });
    }

  } catch (e) {
    console.error(e);
    await alip.sendMessage(m.chat, { text: "Terjadi kesalahan saat memproses permintaan." });
  }
}
break;

/*******************  CASE: kirimch  *******************/
case "kirimch": {
    if (!isCreator) return Reply(mess.owner);
    const CH_ID = global.idSaluran
  
    const quoted = m.quoted ? m.quoted : m;
    const mime = (quoted.msg || quoted).mimetype || '';
    const caption = text?.trim() || quoted.caption || '';

    try {
        if (/image/.test(mime)) {
            const buffer = await quoted.download();
            await alip.sendMessage(CH_ID, { 
                image: buffer, 
                caption: caption || null 
            });
            Reply("âœ… *Gambar berhasil dikirim ke Channel!*");
        } 
        else if (/video/.test(mime)) {
            const buffer = await quoted.download();
            await alip.sendMessage(CH_ID, { 
                video: buffer, 
                mimetype: "video/mp4",
                gifPlayback: true,
                ptv: true,
                caption: caption || null 
            });
            Reply("âœ… *Video berhasil dikirim ke Channel sebagai PTV!*");
        } 
        else if (caption) {
            await alip.sendMessage(CH_ID, { 
                text: caption 
            });
            Reply("âœ… *Teks berhasil dikirim ke Channel!*");
        } else {
            return Reply(`Kirim teks atau reply video/gambar!\nContoh: *${prefix}kirimch Selamat pagi semua!*`);
        }

    } catch (error) {
        console.error('[KIRIMCH ERROR]', error);
        Reply('âŒ Gagal mengirim pesan ke channel. Pastikan bot adalah admin channel.');
    }
}
break;
case 'zrooart': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  const fetch = (await import('node-fetch')).default;
  const FormData = (await import('form-data')).default;
  const input = q ? q.split('|').map(v => v.trim()) : [];
  const prompt = input[0];
  let style = input[1] || 'Fantasy Art';
  let aspect = input[2] || '16:9';

  const styleList = [
    'None', '3D Model', 'Analog Film', 'Anime', 'Cinematic', 'Comic Book',
    'Digital Art', 'Enhance', 'Fantasy Art', 'Isometric', 'Line Art',
    'Low Poly', 'Modeling Compound', 'Neon Punk', 'Origami',
    'Photographic', 'Pixel Art', 'Tile Texture'
  ];

  const ratioList = [
    '16:9', '1:1', '9:16', '4:5', '5:4', '2:3', '3:2', '21:9', '9:21'
  ];

  if (!prompt) {
    return Reply(`*Format:*
.zrooart <prompt> | <style?> | <ratio?>

*Contoh:*
.zrooart naga api | Anime | 9:16
.zrooart kota masa depan | random | random

*Style yang tersedia:*
${styleList.join(', ')}

*Rasio yang tersedia:*
${ratioList.join(', ')}`);
  }

  if (style.toLowerCase() === 'random') {
    style = styleList[Math.floor(Math.random() * styleList.length)];
  }

  if (aspect.toLowerCase() === 'random') {
    aspect = ratioList[Math.floor(Math.random() * ratioList.length)];
  }

  const form = new FormData();
  form.append('video_description', prompt);
  form.append('test_mode', 'false');
  form.append('negative_prompt', 'blurry, distorted, bad quality');
  form.append('aspect_ratio', aspect);
  form.append('style', style);
  form.append('output_format', 'png');
  form.append('seed', '0');

  Reply(`â³ Membuat gambar dari prompt:\n*${prompt}*\nStyle: *${style}*\nRasio: *${aspect}*`);

  try {
    const res = await fetch('https://aiart-zroo.onrender.com/generate', {
      method: 'POST',
      headers: { accept: '*/*' },
      body: form
    });

    const json = await res.json();

    if (!json.success || !json.image_path)
      return Reply('âŒ Gagal membuat gambar:\n' + JSON.stringify(json, null, 2));

    const finalURL = `https://aiart-zroo.onrender.com${json.image_path}?t=${Date.now()}`;

    await alip.sendMessage(m.chat, {
      image: { url: finalURL },
      caption: `âœ… Gambar berhasil dibuat dari:\n*${prompt}*\nStyle: *${style}*\nRasio: *${aspect}*`
    }, { quoted: m });

  } catch (e) {
    Reply('âŒ Terjadi error:\n' + e.message);
  }
}
break;

case 'gpt1image':
case 'gptimg': {
if (!global.isPrem(m.sender) && !isCreator) return Reply('Khusus user premium');
    if (!q) return Reply('Contoh: *.gptimg kucing lucu terbang ke luar angkasa dengan jetpack*');

    await alip.sendMessage(m.chat, {
        react: {
            text: 'ðŸ¤–',
            key: m.key
        }
    });

    Reply('Sabar yah, sedang membuat gambar dari imajinasimu...\nProses ini mungkin agak lama, tunggu sebentar...');

    try {
        const headers = {
            'content-type': 'application/json',
            'referer': 'https://gpt1image.exomlapi.com/',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36'
        };

        const body = JSON.stringify({
            prompt: q,
            n: 1,
            size: '1024x1024',
            is_enhance: true,
            response_format: 'url'
        });

        const res = await fetch('https://gpt1image.exomlapi.com/v1/images/generations', {
            method: 'POST',
            headers,
            body
        });

        if (!res.ok) return Reply(`Gagal mengambil gambar dari server.\nStatus: ${res.status} ${res.statusText}`);

        const data = await res.json();
        const imgUrl = data?.data?.[0]?.url;

        if (!imgUrl) return Reply('Gambar berhasil dibuat tapi URL kosong. Mungkin ada gangguan dari server.');

        await alip.sendMessage(m.chat, {
            image: { url: imgUrl },
            caption: `Gambar untuk:\n@${m.sender.split("@")[0]}`
        }, { quoted: m });

    } catch (err) {
        Reply('Terjadi error saat membuat gambar: ' + err.message);
    }
}
break;

case "playch": {
  if (!isCreator) return Reply(mess.owner)
  if (!text) return Reply('ðŸŽµ Masukkan judul lagu!\n\nContoh: *.playch Jakarta Hari Ini*')

  m.reply('â³ *Mencari dan memproses audio...*')
  const CH_ID = global.idSaluran

  const fs = require("fs")
  const path = require("path")
  const axios = require("axios")
  const { exec } = require("child_process")
  const { promisify } = require("util")
  const execPromise = promisify(exec)

  try {
    const ytsSearch = await yts(text)
    const ytRes = ytsSearch.all[0]
    if (!ytRes) return Reply("âŒ Lagu tidak ditemukan.")

    const apiUrl = `${global.termai}/api/downloader/youtube?type=mp3&url=${encodeURIComponent(ytRes.url)}&key=${global.apitermai}`
    const apiRes = await fetch(apiUrl).then(v => v.json())

    if (!apiRes.status || !apiRes.data || !apiRes.data.downloads)
      return Reply("âŒ Gagal ambil audio.")

    const audioItem = apiRes.data.downloads.find(v => v.dlink && v.dlink.includes('type=mp3'))
    if (!audioItem) return Reply("âŒ Audio MP3 tidak ditemukan.")

    const tmpDir = path.join(__dirname, "tmp")
    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true })

    const inputPath = path.join(tmpDir, `dl_${Date.now()}.mp3`)
    const outputPath = path.join(tmpDir, `dl_${Date.now()}.opus`)

    const mp3Buffer = await axios.get(audioItem.dlink, {
      responseType: 'arraybuffer',
      headers: { 'User-Agent': 'Mozilla/5.0' }
    })

    fs.writeFileSync(inputPath, Buffer.from(mp3Buffer.data))

    await execPromise(`ffmpeg -i "${inputPath}" -c:a libopus -b:a 48k -vbr on "${outputPath}"`)

    const buffer = fs.readFileSync(outputPath)

    await alip.sendMessage(CH_ID, {
      audio: buffer,
      mimetype: "audio/ogg; codecs=opus",
      ptt: true,
      contextInfo: {
        externalAdReply: {
          thumbnailUrl: ytRes.thumbnail,
          title: ytRes.title,
          body: `Author: ${ytRes.author.name} || Duration: ${ytRes.timestamp}`,
          sourceUrl: ytRes.url,
          renderLargerThumbnail: true,
          mediaType: 1
        }
      }
    }, { quoted: m })

    if (fs.existsSync(inputPath)) fs.unlinkSync(inputPath)
    if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath)

    Reply(`âœ… *Berhasil dikirim ke channel!*\nðŸŽµ ${ytRes.title}\nðŸ”— ${global.linkSaluran}`)

  } catch (err) {
    console.error(err)
    Reply('âŒ Terjadi kesalahan saat proses.')
  }
}
break
/****************  play v2  ****************/

case 'playv2': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply('Masukkan judul lagu!\nContoh: *play Jakarta Hari Ini*');

  try {
    let res = await fetch(`https://ochinpo-helper.hf.space/yt?query=${encodeURIComponent(text)}`);
    if (!res.ok) throw new Error('API utama gagal');
    let json = await res.json();
    if (!json.success || !json.result) throw new Error('Respon API utama tidak valid');

    const {
      title,
      url,
      image,
      duration,
      author,
      download
    } = json.result;

    const thumbnail = await (await fetch(image)).buffer();

    await alip.sendMessage(m.chat, {
      audio: { url: download.audio },
      mimetype: 'audio/mpeg',
      fileName: `${title}.mp3`,
      ptt: true,
      contextInfo: {
        forwardingScore: 999,
        isForwarded: true,
        externalAdReply: {
          title,
          body: `${author.name} â€¢ ${duration.timestamp}`,
          thumbnail,
          mediaUrl: url,
          mediaType: 2,
          renderLargerThumbnail: true,
          sourceUrl: url
        }
      }
    }, { quoted: m });

  } catch (e) {
    console.warn('Fallback to Nekorinn API:', e.message);
    try {
      let res = await fetch(`https://api.nekorinn.my.id/downloader/ytplay-savetube?q=${encodeURIComponent(text)}`);
      let data = await res.json();
      if (!data.status || !data.result) throw new Error('Respon cadangan 1 tidak valid');

      const { title, channel, duration, imageUrl, link } = data.result.metadata;
      const downloadUrl = data.result.downloadUrl;
      const thumbnail = await (await fetch(imageUrl)).buffer();

      await alip.sendMessage(m.chat, {
        audio: { url: downloadUrl },
        mimetype: 'audio/mpeg',
        fileName: `${title}.mp3`,
        ptt: true,
        contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          externalAdReply: {
            title,
            body: `${channel} â€¢ ${duration}`,
            thumbnail,
            mediaUrl: link,
            mediaType: 2,
            renderLargerThumbnail: true,
            sourceUrl: link
          }
        }
      }, { quoted: m });

    } catch (err) {
      console.warn('Fallback to Diioffc API:', err.message);
      try {
        const res2 = await fetch(`https://api.diioffc.web.id/api/search/ytplay?query=${encodeURIComponent(text)}`);
        if (!res2.ok) return Reply('Gagal mengambil data dari server cadangan.');
        const json = await res2.json();
        if (!json.status || !json.result) return Reply('Lagu tidak ditemukan!');

        const { title, author, duration, thumbnail: thumb, url, download } = json.result;
        const thumbnail = await (await fetch(thumb)).buffer();

        await alip.sendMessage(m.chat, {
          audio: { url: download.url },
          mimetype: 'audio/mpeg',
          fileName: download.filename || `${title}.mp3`,
          ptt: true,
          contextInfo: {
            forwardingScore: 999,
            isForwarded: true,
            externalAdReply: {
              title,
              body: `${author.name} â€¢ ${duration.timestamp}`,
              thumbnail,
              mediaUrl: url,
              mediaType: 2,
              renderLargerThumbnail: true,
              sourceUrl: url
            }
          }
        }, { quoted: m });

      } catch (finalErr) {
        console.error(finalErr);
        Reply('Terjadi kesalahan saat memproses permintaanmu.');
      }
    }
  }
}
break;

//================================================================================

case 'tokartun': {
if (!global.isPrem(m.sender) && !isCreator) return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}tokartun*`);
    }
    m.reply("ðŸŽ¨ Sedang mengubah fotomu menjadi gaya kartun... Tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸŒ€", key: m.key } });

    const PROMPT_KARTUN = `
    Transform the person in the image into a stylized cartoon version 
    with smooth shading, expressive facial features, and vibrant colors. 
    Maintain the original face identity, hairstyle, and expression. 
    The final result should look like a high-quality Pixar or Disney-style 
    cartoon portrait with clean outlines and natural lighting.
    `;

    async function uploadUguu(buffer, filename = "file.jpg") {
        const FormData = require('form-data');
        const form = new FormData();
        form.append("files[]", buffer, { filename });
        const res = await fetch("https://uguu.se/upload.php", { method: "POST", body: form });
        if (!res.ok) throw new Error(`Upload gagal: ${res.status}`);
        const json = await res.json();
        const url = json?.files?.[0]?.url;
        if (!url) throw new Error("Gagal mendapatkan URL dari Uguu");
        return url;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadUguu(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_KARTUN)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);

    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case "playvidyt": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) return Reply('Masukkan judul video!\nContoh: .playvidyt Jakarta Hari Ini');
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ”Ž', key: m.key } });

    try {
        let ytsSearch = await yts(text);
        const res = ytsSearch.videos[0] || ytsSearch.all[0];

        if (!res || !res.url) throw new Error("Video tidak ditemukan");

        await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });

        const API_URL = "https://thesocialcat.com/api/youtube-download"
        const HEADERS = {
            "accept": "*/*",
            "accept-language": "id-ID", 
            "content-type": "application/json",
            "Referer": "https://thesocialcat.com/tools/youtube-video-downloader"
        }
        
        const {data} = await axios.post(API_URL, {url: res.url, format: '360p'}, {headers: HEADERS})
        
        if (!data || !data.mediaUrl) return Reply('Gagal mengambil data video.')
        
        const tmpDir = './tmp'
        if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true })
        
        const rawPath = `./tmp/raw_${Date.now()}.mp4`
        const outPath = `./tmp/out_${Date.now()}.mp4`
        
        const vid = await axios.get(data.mediaUrl, {responseType: 'arraybuffer'})
        fs.writeFileSync(rawPath, Buffer.from(vid.data))
        
        await new Promise((resolve, reject) => {
            exec(`ffmpeg -y -i "${rawPath}" -c:v libx264 -preset veryfast -movflags +faststart -pix_fmt yuv420p -c:a aac "${outPath}"`,
            (err) => err ? reject(err) : resolve())
        })
        
        const buffer = fs.readFileSync(outPath)
        let caption = `ðŸŽ¬ *${res.title || 'YouTube Video'}*\n\nðŸ‘¤ Author: ${res.author?.name || '-'}\nâ±ï¸ Duration: ${res.timestamp || '-'}\nðŸš© Quality: 360p\n\nâœ… Downloaded by ${global.botname}`
        
        await alip.sendMessage(m.chat, {
            video: buffer,
            mimetype: 'video/mp4',
            caption: caption
        }, { quoted: m })
        
        if (fs.existsSync(rawPath)) fs.unlinkSync(rawPath)
        if (fs.existsSync(outPath)) fs.unlinkSync(outPath)
        
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
    } catch (err) {
        console.error(err);
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
        Reply('âŒ Terjadi error saat mengambil video.');
    }
}
break;
//===============================================================================

case "yts": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(example('we dont talk'))
await alip.sendMessage(m.chat, {react: {text: 'ðŸ”Ž', key: m.key}})
let ytsSearch = await yts(text)
const anuan = ytsSearch.all
let teks = "\n    *[ Result From Youtube Search ðŸ” ]*\n\n"
for (let res of anuan) {
teks += `* *Title :* ${res.title}
* *Durasi :* ${res.timestamp}
* *Upload :* ${res.ago}
* *Views :* ${res.views}
* *Author :* ${res?.author?.name || "Unknown"}
* *Source :* ${res.url}\n\n`
}
await Reply(teks)
await alip.sendMessage(m.chat, {react: {text: '', key: m.key}})
}
break

//===============================================================================

case "play1": {
if (!isCreator && !isPremium) return Reply(mess.prem)
if (!text) return Reply(example("dj tiktok"))
await alip.sendMessage(m.chat, {react: {text: 'ðŸ”Ž', key: m.key}})
let ytsSearch = await yts(text)
const res = await ytsSearch.all[0]

var anu = await ytdl.ytmp3(`${res.url}`)

if (anu.status) {
let urlMp3 = anu.download.url
await alip.sendMessage(m.chat, {audio: {url: urlMp3}, mimetype: "audio/mpeg", contextInfo: { externalAdReply: {thumbnailUrl: res.thumbnail, title: res.title, body: `Author ${res.author.name} || Duration ${res.timestamp}`, sourceUrl: res.url, renderLargerThumbnail: true, mediaType: 1}}}, {quoted: m})
} else {
return Reply("Error! Result Not Found")
}
await alip.sendMessage(m.chat, {react: {text: '', key: m.key}})
}
break

case 'ytmp3': {
    if (!isRegistered(m.sender) && !isCreator) return
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return
    if (!text) return Reply('Masukin link YouTube')
    if (!text.includes('youtube.com') && !text.includes('youtu.be')) return Reply('Link YouTube tidak valid')

    await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } })
    addLimit(m.sender, global.isPrem(m.sender), isCreator)

    try {
        const yt = {
            base: "https://api.apiapi.lat",
            enc: s => s.split("").map(c => c.charCodeAt()).reverse().join(";"),
            xor: s => s.split("").map(c => String.fromCharCode(c.charCodeAt() ^ 1)).join(""),
            rand: () => {
                const h = "0123456789abcdef";
                return Array.from({ length: 32 }, () => h[Math.floor(Math.random() * h.length)]).join("");
            },
            async init(url) {
                const api = `${this.base}/${this.rand()}/init/${this.enc(url)}/${this.rand()}/`;
                const res = await fetch(api, {
                    method: "POST",
                    body: JSON.stringify({ data: this.xor(url), format: "0", mp3Quality: 128 })
                });
                const j = await res.json();
                if (j.s === "C") return this.file(j.i, j.pk);
                return this.wait(j.i, j.pk);
            },
            file(i, pk) {
                return `${this.base}/${this.rand()}/download/${i}/${this.rand()}/${pk ? pk + "/" : ""}`;
            },
            async wait(i, pk) {
                let j;
                do {
                    await new Promise(r => setTimeout(r, 3000));
                    const api = `${this.base}/${this.rand()}/status/${i}/${this.rand()}/${pk ? pk + "/" : ""}`;
                    const res = await fetch(api, { method: "POST", body: JSON.stringify({ data: i }) });
                    j = await res.json();
                } while (j.s === "P");
                if (j.s === "E") throw "Gagal convert audio";
                return this.file(i, pk);
            }
        };

        const fetchBufferSafe = async (url, retry = 3) => {
            for (let i = 0; i < retry; i++) {
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(res.status);
                    return await res.buffer();
                } catch {
                    if (i === retry - 1) throw "Gagal download audio";
                    await new Promise(r => setTimeout(r, 3000));
                }
            }
        };

        const search = await yts({ query: text, hl: 'id' });
        if (!search.videos.length) return Reply('Lagu tidak ditemukan');

        const v = search.videos[0];
        
        const dl = await yt.init(v.url);
        const buffer = await fetchBufferSafe(dl);

        if (buffer.length > 50 * 1024 * 1024) {
            return Reply(`File terlalu besar (di atas 50MB)\nLink: ${dl}`);
        }

        await alip.sendMessage(
            m.chat,
            {
                audio: buffer,
                mimetype: 'audio/mpeg',
                ptt: false,
                contextInfo: {
                    externalAdReply: {
                        title: v.title,
                        body: `Durasi: ${v.timestamp}`,
                        thumbnailUrl: v.thumbnail,
                        sourceUrl: v.url,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            },
            { quoted: m }
        );

        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } })

    } catch (e) {
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } })
        
        if (e.code === 'ECONNABORTED') {
            Reply('Timeout: Proses terlalu lama')
        } else if (e.response && e.response.status === 404) {
            Reply('Audio tidak ditemukan')
        } else if (e.response && e.response.status === 403) {
            Reply('Akses ditolak oleh server')
        } else {
            Reply('Error saat memproses audio')
        }
    }
}
break

 case 'hiitwixtor': case 'twixtor': {
 if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply('Contoh: hiitwixtor Gojo');
  const axios = require("axios");
  const cheerio = require("cheerio");
  const search = async (query) => {
    try {
      const url = `https://hiitwixtor.com/?s=${encodeURIComponent(query)}`;
      const { data } = await axios.get(url);
      const $ = cheerio.load(data);
      let result = [];
      $('.post-details').each((_, el) => {
        const title = $(el).find('h2').text().trim();
        const link = $(el).find('h2>a').attr('href');
        const image = $('a.post-thumb').find('img').attr('src');
        const coment = $(el).find('span.meta-comment.tie-icon.meta-item.fa-before').text().trim();
        const fire = $(el).find('span.meta-views.meta-item.very-hot').text().trim();
        result.push({ title, link, image, coment, fire });
      });
      return result;
    } catch (e) {
      return [];
    }
  };
  let res = await search(text);
  if (!res.length) return Reply('Tidak ditemukan.');
  let teks = `*Hasil pencarian Hiitwixtor: ${text}*\n\n`;
  for (let i = 0; i < res.length; i++) {
    teks += `*${i + 1}. ${res[i].title}*\n`;
    teks += `ðŸ”¥ Views: ${res[i].fire} | ðŸ’¬ Comments: ${res[i].coment}\n`;
    teks += `${res[i].link}\n\n`;
  }
  Reply(teks);
}
  break

//================================================================================
case "youtubemp4":
case "ytmp4": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply('Masukkan URL YouTube\n\nContoh: .yt https://youtu.be/...');
    
    let url = text.trim();
    
    if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
        return Reply('âŒ URL YouTube tidak valid!');
    }
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const apiUrl = `https://fgsi.dpdns.org/api/downloader/youtube/v2`;
        
        const response = await axios.get(apiUrl, {
            params: {
                apikey: "fgsiapi-2ef6382d-6d",
                url: url,
                type: "mp4"
            },
            headers: {
                accept: "application/json"
            },
            timeout: 45000
        });
        
        const data = response.data;
        
        if (data.status === true && data.data && data.data.status === "tunnel" && data.data.url) {
            const videoData = data.data;
            const filename = videoData.filename || "youtube_video.mp4";
            const duration = videoData.duration ? `${Math.floor(videoData.duration / 60)}:${(videoData.duration % 60).toString().padStart(2, '0')}` : "Tidak diketahui";
            
            const tempVideoPath = `./tmp/youtube_${Date.now()}.mp4`;
            const convertedVideoPath = `./tmp/youtube_${Date.now()}_converted.mp4`;
            
            const videoResponse = await axios.get(videoData.url, {
                responseType: 'stream',
                timeout: 180000
            });
            
            const writer = fs.createWriteStream(tempVideoPath);
            videoResponse.data.pipe(writer);
            
            await new Promise((resolve, reject) => {
                writer.on('finish', resolve);
                writer.on('error', reject);
            });
            
            await new Promise((resolve, reject) => {
                ffmpeg(tempVideoPath)
                    .outputOptions([
                        '-c:v', 'libx264',
                        '-preset', 'fast',
                        '-crf', '28',
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        '-movflags', '+faststart',
                        '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2'
                    ])
                    .save(convertedVideoPath)
                    .on('end', resolve)
                    .on('error', reject);
            });
            
            const videoBuffer = fs.readFileSync(convertedVideoPath);
            
            const caption = `*âœ… Berhasil didownload!*`;
            
            await alip.sendMessage(
                m.chat,
                {
                    video: videoBuffer,
                    caption: caption,
                    mimetype: 'video/mp4',
                    fileName: filename
                },
                { quoted: m }
            );
            
            fs.unlinkSync(tempVideoPath);
            fs.unlinkSync(convertedVideoPath);
            
        } else {
            Reply(`âŒ ${data.message || 'Gagal mendapatkan link download'}`);
        }
        
    } catch (error) {
        console.error('YouTube Download Error:', error);
        
        if (error.code === 'ECONNABORTED') {
            Reply('â±ï¸ Timeout! Video terlalu panjang atau server sibuk.');
        } else if (error.message.includes('ENOTFOUND')) {
            Reply('ðŸŒ Server API tidak bisa diakses.');
        } else {
            Reply('âŒ Gagal download video YouTube. Coba lagi nanti.');
        }
    }
}
break;
//================================================================================

case "mediafire": {
if (!global.isPrem(m.sender) && !isCreator) return Reply('Khusus user premium');
if (!text) return Reply(example("linknya"))
if (!text.includes('mediafire.com')) return Reply("Link tautan tidak valid")
await mediafire(text).then(async (res) => {
if (!res.link) return Reply("Error! Result Not Found")
await alip.sendMessage(m.chat, {document: {url: res.link}, fileName: res.judul, mimetype: "application/"+res.mime.toLowerCase()}, {quoted: m})
}).catch((e) => Reply("Error! Result Not Found"))
}
break

//================================================================================

case "ptvch": {
if (!isCreator) return Reply(mess.owner)
    if (!text) return Reply(example("dj tiktok"));
    const CH_ID = global.idSaluran;
    if (!CH_ID) return Reply("âŒ Channel ID tidak ditemukan.");

    await alip.sendMessage(m.chat, { react: { text: 'ðŸ”Ž', key: m.key } });
    
    const processMsg = await Reply("â³ *Mencari video TikTok...*\n\nVideo akan dikirim ke channel setelah ditemukan.");
    
    try {
        let res = await fetch(`https://apizell.web.id/download/tiktokplay?q=${encodeURIComponent(text)}`);
        let json = await res.json();

        if (!json.status || !json.data || !json.data.length) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply("âŒ Video TikTok tidak ditemukan.");
        }

        let video = json.data[0];
        let videoUrl = video.url;
        
        if (!videoUrl) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply("âŒ URL video tidak valid.");
        }

        const fs = require("fs");
        const path = require("path");
        const { exec } = require("child_process");
        const { promisify } = require("util");
        const execPromise = promisify(exec);
        
        const tmpDir = path.join(__dirname, "tmp");
        if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
        
        const videoPath = path.join(tmpDir, `tiktok_${Date.now()}.mp4`);
        const outputPath = path.join(tmpDir, `tiktok_ptv_${Date.now()}.mp4`);
        
        const axios = require("axios");
        const writer = fs.createWriteStream(videoPath);
        const response = await axios({ 
            url: videoUrl, 
            method: "GET", 
            responseType: "stream",
            timeout: 30000 
        });
        
        response.data.pipe(writer);

        await new Promise((resolve, reject) => {
            writer.on("finish", resolve);
            writer.on("error", reject);
        });

        if (!fs.existsSync(videoPath)) {
            await alip.sendMessage(m.chat, { delete: processMsg.key });
            return Reply("âŒ Gagal mendownload video.");
        }

        const fileSize = fs.statSync(videoPath).size;
        if (fileSize > 16 * 1024 * 1024) {
            await execPromise(`ffmpeg -i "${videoPath}" -c:v libx264 -crf 28 -preset fast -c:a aac -b:a 64k -movflags +faststart "${outputPath}"`);
            
            if (fs.existsSync(outputPath)) {
                fs.unlinkSync(videoPath);
                fs.renameSync(outputPath, videoPath);
            }
        }

        const finalBuffer = fs.readFileSync(videoPath);
        
        await alip.sendMessage(CH_ID, {
            video: finalBuffer,
            ptv: true,
            mimetype: "video/mp4",
            caption: `ðŸŽµ *TIKTOK PLAY*\n\nðŸ” Pencarian: ${text}\nðŸ“… ${new Date().toLocaleDateString('id-ID')}\n\n${video.title || ''}`,
            contextInfo: {
                externalAdReply: {
                    thumbnailUrl: video.thumbnail || global.image.menu,
                    title: "ðŸŽµ TikTok Play",
                    body: `Hasil pencarian: ${text}`,
                    sourceUrl: videoUrl,
                    mediaType: 2,
                    renderLargerThumbnail: true
                }
            }
        });

        await alip.sendMessage(m.chat, { delete: processMsg.key });
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
        Reply(`âœ… *Video berhasil dikirim ke channel!*\n\nðŸŽµ Pencarian: ${text}\nðŸ”— ${global.linkSaluran}`);
        
        if (fs.existsSync(videoPath)) {
            fs.unlinkSync(videoPath);
        }
        if (fs.existsSync(outputPath)) {
            fs.unlinkSync(outputPath);
        }
        
    } catch (e) {
        console.error("[PTV ERROR]", e);
        
        try {
            if (processMsg?.key) {
                await alip.sendMessage(m.chat, { delete: processMsg.key });
            }
        } catch (err) {}
        
        let errorMsg = "âš ï¸ Terjadi kesalahan saat mengambil video TikTok.";
        
        if (e.code === 'ECONNABORTED') {
            errorMsg += "\nâ±ï¸ Timeout - video terlalu besar atau koneksi lambat.";
        } else if (e.message?.includes('ENOTFOUND')) {
            errorMsg += "\nðŸŒ API tidak dapat diakses.";
        }
        
        errorMsg += "\n\nCoba dengan pencarian lain.";
        
        Reply(errorMsg);
    }
}
break;

case "ptv": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return m.reply(example("dj tiktok"));
  await alip.sendMessage(m.chat, { react: { text: 'ðŸ”Ž', key: m.key } });
  try {
    let res = await fetch(`https://apizell.web.id/download/tiktokplay?q=${encodeURIComponent(text)}`);
    let json = await res.json();

    if (!json.status || !json.data || !json.data.length)
      return m.reply("âŒ Video TikTok tidak ditemukan.");

    let video = json.data[0];
    let videoUrl = video.url;
    await alip.sendMessage(m.chat, {
      video: { url: videoUrl },
      ptv: true,
      mimetype: "video/mp4",
      caption: `ðŸŽµ *TikTok Play*\n> Hasil pencarian: ${text}`
    }, { quoted: m });

    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
  } catch (e) {
    console.error("[PTV ERROR]", e);
    return m.reply("âš ï¸ Terjadi kesalahan saat mengambil video TikTok.");
  }
}
break;

case 'playtiktok': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  if (!q) return Reply('Masukkan query!\nContoh: playtiktok haikyuu edit');

  // Kirim pesan loading sederhana
  const waitMsg = await alip.sendMessage(m.chat, {
    text: `â³ *Mencari video...*`
  }, { quoted: m });

  try {
    let res = await fetch(`https://apizell.web.id/download/tiktokplay?q=${encodeURIComponent(q)}`);
    let json = await res.json();

    if (!json.status || !json.data || !json.data.length) {
      return Reply('âŒ Video tidak ditemukan.');
    }

    let vid = json.data[0];
    let videoBuffer = await (await fetch(vid.url)).buffer();

    await alip.sendMessage(m.chat, {
      video: videoBuffer,
      mimetype: 'video/mp4',
      caption: `âœ… *Done!*\n\nBerikut hasil pencarian TikTok`
    }, { quoted: m });

  } catch (e) {
    console.error('[PLAYTIKTOK ERROR]', e);
    Reply('âŒ Terjadi kesalahan saat memproses permintaan.\nCoba lagi nanti.');
  }
}
break;

case "stikerdinokuning": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/dinokuning?apikey=${global.apikeyalip}`;

    // ambil langsung binary image
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
    console.log(e);
  }
}
break;
case 'tohitam':
case 'hitamin': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!/image\//i.test(mime)) {
        return Reply(`âŒ Reply ke *gambar* atau kirim gambar dengan caption *${prefix}hitamin*`);
    }
    m.reply("ðŸŒ‘ Sedang menggelapkan warna kulit secara natural... Mohon tunggu sebentar!");
    await alip.sendMessage(m.chat, { react: { text: "ðŸ•¶ï¸", key: m.key } });

    const PROMPT_HITAMIN = `
Transform the skin tone into a very deep, rich African ebony black â€” smooth, even, and naturally radiant. 
Preserve all original facial features and expressions. 
Ensure the skin looks ultra-dark and realistic, not gray or burned. 
Use soft lighting and warm highlights to enhance the beauty and depth of true African dark skin.
`;

    async function uploadPixhost(buffer, filename = "file.jpg") {
        const { ImageUploadService } = require('node-upload-images');
        const service = new ImageUploadService('pixhost.to');
        const upload = await service.uploadFromBinary(buffer, filename);
        return upload.directLink;
    }

    try {
        const userImageBuffer = await q.download();
        if (!userImageBuffer) throw new Error("Gagal mengunduh gambar Anda.");
        const userImageUrl = await uploadPixhost(userImageBuffer);     
        const apiUrl = `https://api-faa.my.id/faa/editfoto?url=${encodeURIComponent(userImageUrl)}&prompt=${encodeURIComponent(PROMPT_HITAMIN)}`;
const response = await axios.get(apiUrl, { responseType: "arraybuffer" });
const hasilBuffer = Buffer.from(response.data, "binary");

await alip.sendMessage(
    m.chat,
    { image: hasilBuffer, caption: `*done bosku*` },
    { quoted: m }
);
    } catch (e) {
        await Reply("âŒ Error: " + e.message);
    } finally {
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
    }
}
break;

case 'fb': case 'fbdl': case 'facebook': {
    if (!text) return Reply(`Contoh: ${prefix}${command} https://facebook.com/share/video/...`);
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const encodedUrl = encodeURIComponent(text);
        const apiUrl = `${global.btc}/api/download/fbdown?apikey=${global.apikeyalip}&url=${encodedUrl}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 90000 });
        
        if (!data.status || !data.result?.status === 'success') {
            throw new Error('Gagal download video');
        }
        
        const urls = data.result?.url?.urls || [];
        const videoUrl = urls.find(v => v.hd)?.hd || urls.find(v => v.sd)?.sd;
        
        if (!videoUrl) throw new Error('Video tidak ditemukan');
        
        await alip.sendMessage(m.chat, {
            video: { url: videoUrl },
            mimetype: 'video/mp4'
        }, { quoted: m });
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal download video Facebook');
    }
    break;
}
case 'pindl':
case 'pindown': 
case 'downpin':
case 'downloadpin': {
    if (!text) return Reply('âŒ Masukkan link Pinterest!\nContoh: .pindl https://pin.it/xxxx');
    
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        if (!text.match(/pinterest\.com|pin\.it/i)) {
            return Reply('âŒ URL bukan dari Pinterest!');
        }
        
        const encodedUrl = encodeURIComponent(text);
        const apiUrl = `${global.btc}/api/download/pinterest?apikey=${global.apikeyalip}&url=${encodedUrl}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 60000 });
        
        if (!data || !data.result || !data.result.data) {
            throw new Error('Gagal mengambil data dari Pinterest');
        }
        
        const pinterestData = data.result.data;
        let caption = `ðŸ“Œ *Pinterest Downloader*\n\n`;
        
        if (pinterestData.video) {
            await alip.sendMessage(m.chat, {
                video: { url: pinterestData.video },
                caption: caption,
                mimetype: 'video/mp4'
            }, { quoted: m });
        } else if (pinterestData.image) {
            await alip.sendMessage(m.chat, {
                image: { url: pinterestData.image },
                caption: caption
            }, { quoted: m });
        } else {
            throw new Error('Media tidak ditemukan');
        }
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (e) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal mendownload Pinterest: ' + (e.message || 'Unknown error'));
    }
}
break;

case "ig": 
case "igdl":
case "instagram": {
    if (!text) return Reply('âŒ Masukkan URL Instagram!');
    
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        if (!text.match(/instagram\.com|instagr\.am/i)) {
            return Reply('âŒ URL bukan Instagram');
        }

        const encodedUrl = encodeURIComponent(text);
        const apiUrl = `${global.apialip}/download/instagram?apikey=${global.apikeyalip}&url=${encodedUrl}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 30000 });
        
        if (!data.status || !data.result || !Array.isArray(data.result) || data.result.length === 0) {
            return Reply('âŒ Gagal mengambil media Instagram');
        }

        let successCount = 0;
        
        for (const [index, media] of data.result.entries()) {
            try {
                const mediaCaption = `ðŸ“Œ *Instagram Download*\nðŸŽ¬ ${media.kualitas || 'Media'} ${index + 1}/${data.result.length}`;
                
                if (media.url_download) {
                    const url = media.url_download.toLowerCase();
                    
                    if (url.includes('.jpg') || url.includes('.jpeg') || url.includes('.png') || url.includes('.webp')) {
                        await alip.sendMessage(m.chat, {
                            image: { url: media.url_download },
                            caption: mediaCaption,
                            mimetype: 'image/jpeg'
                        }, { quoted: index === 0 ? m : undefined });
                    } else if (url.includes('.mp4') || url.includes('.mov') || url.includes('.avi')) {
                        await alip.sendMessage(m.chat, {
                            video: { url: media.url_download },
                            caption: mediaCaption,
                            mimetype: 'video/mp4'
                        }, { quoted: index === 0 ? m : undefined });
                    } else {
                        await alip.sendMessage(m.chat, {
                            image: { url: media.url_download },
                            caption: mediaCaption
                        }, { quoted: index === 0 ? m : undefined });
                    }
                    
                    successCount++;
                    await sleep(1000);
                }
                
            } catch (err) {
                console.log('Error:', err.message);
            }
        }

        if (successCount > 0) {
            await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        } else {
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            Reply('âŒ Gagal mengunduh media');
        }

    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal mengunduh: ' + error.message);
    }
}
break;

case 'ttmp3':
case 'tiktokmp3': {
    if (!text) return Reply('Contoh: .ttmp3 https://vt.tiktok.com/xxxx');
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const apiUrl = `${global.termai}/api/downloader/tiktok?url=${encodeURIComponent(text)}&key=${global.apitermai}`;
        const response = await axios.get(apiUrl, { timeout: 60000 });
        
        if (response.data?.status === true && response.data.data) {
            const data = response.data.data;
            
            let audioUrl = null;
            
            if (data.audio?.url) {
                audioUrl = data.audio.url;
            } else if (data.media && Array.isArray(data.media)) {
                const mp3Media = data.media.find(item => 
                    item.description?.toLowerCase().includes('mp3') || 
                    item.url?.includes('.mp3')
                );
                if (mp3Media) {
                    audioUrl = mp3Media.url;
                }
            }
            
            if (audioUrl) {
                await alip.sendMessage(m.chat, {
                    audio: { url: audioUrl },
                    mimetype: 'audio/mpeg',
                    fileName: `tiktok_audio_${Date.now()}.mp3`,
                    caption: `ðŸŽµ *TIKTOK AUDIO*\n\nðŸ‘¤ *Author:* ${data.author?.nickname || 'Unknown'}\nðŸ“ *Title:* ${data.title || '-'}\nðŸŽ¶ *Audio extracted from TikTok*\n\n_Â© ${global.botname}_`
                }, { quoted: m });
            } else {
                Reply('âŒ Audio tidak ditemukan dalam data TikTok');
            }
        } else {
            Reply('âŒ Gagal mengambil audio TikTok');
        }
    } catch (error) {
        console.error('TTMP3 Error:', error.message);
        Reply(`âŒ Error: ${error.message}`);
    }
    break;
}
//================================================================================

case 'capcut': {
    if (!text) return Reply(`Contoh: ${prefix}${command} https://capcut.com/tv2/ZS51gMBtR/`);
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const encodedUrl = encodeURIComponent(text);
        const apiUrl = `${global.btc}/api/download/capcut?apikey=${global.apikeyalip}&url=${encodedUrl}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 90000 });
        
        if (!data.status) throw new Error('Gagal download video');
        
        const videoUrl = data.result?.video;
        const title = data.result?.title || 'CapCut Video';
        const author = data.result?.author?.name || data.result?.owner || 'Unknown';
        
        if (!videoUrl) throw new Error('Video tidak ditemukan');
        
        await alip.sendMessage(m.chat, {
            video: { url: videoUrl },
            mimetype: 'video/mp4',
            caption: `ðŸ“¹ ${title}\nðŸ‘¤ ${author}`
        }, { quoted: m });
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Gagal download video CapCut');
    }
    break;
}

//================================================================================

case "tt":
case "ttdl":
case "tiktokdl":
case "tiktok": {
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  if (!text) return m.reply(example("url"));
  if (!text.startsWith("https://")) return m.reply(example("url"));

  addLimit(m.sender, global.isPrem(m.sender), isCreator);

  await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key } });

  try {
    const apiUrl = `https://api.yupra.my.id/api/downloader/tiktok?url=${encodeURIComponent(text)}`;
    const response = await axios.get(apiUrl, { timeout: 30000 });
    const result = response.data;
    
    if (!result.status || result.status !== 200 || !result.result || !result.result.status) {
      return m.reply("Gagal mengambil data TikTok! Pastikan link valid.");
    }

    const tiktokData = result.result;

    if (tiktokData.data && tiktokData.data.length > 0) {
      let selectedVideo = tiktokData.data.find(e => e.type === "nowatermark");
      
      if (!selectedVideo) {
        selectedVideo = tiktokData.data.find(e => e.type === "nowatermark_hd") ||
                       tiktokData.data.find(e => e.type === "watermark") ||
                       tiktokData.data[0];
      }

      if (!selectedVideo || !selectedVideo.url) {
        return m.reply("Video tidak ditemukan atau link tidak valid.");
      }

      const videoCaption = `
*Tiktok Downloaderâœ…*

> â±ï¸ *Durasi:* ${tiktokData.duration || 'Tidak diketahui'}
> ðŸ‘¤ *Uploader:* ${tiktokData.author?.nickname || 'Tidak diketahui'}

> ðŸ“Š *Info:*
> ðŸ“… *Unggahan:* ${tiktokData.taken_at || 'Tidak diketahui'}
> ðŸŒ *Region:* ${tiktokData.region || 'Tidak diketahui'}

> ðŸŽµ *Musik:*
> ${tiktokData.music_info?.title || 'Tidak ada info musik'}
      `.trim();

      await alip.sendMessage(
        m.chat,
        {
          video: { url: selectedVideo.url },
          mimetype: 'video/mp4',
          caption: videoCaption,
          buttons: [
            {
              buttonId: `.ttmp3 ${text}`,
              buttonText: { displayText: "ðŸŽ¸ Download Audio" },
              type: 1,
            }
          ],
          headerType: 4
        },
        { quoted: m }
      );
    } else {
      return m.reply("Video tidak ditemukan atau link tidak valid.");
    }

    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

  } catch (e) {
    console.error('[TIKTOK ERROR]', e);
    await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
    m.reply(`Gagal Mengunduh TikTok\n\nError: ${e.message}\n\nAlternatif: Gunakan command .alipdl atau coba lagi beberapa saat.`);
  }
}
break;

case "playvid": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} storywa`);

  const query = text.trim();

  try {
    await alip.sendMessage(m.chat, {
      image: { url: global.image.menu },
      caption: `ðŸŽ¬ *PILIH PLATFORM DIBAWAH*`,
      footer: `ï¾ `,
      buttons: [
        {
          buttonId: 'playvidpilih',
          buttonText: { displayText: 'ðŸ“¥ Pilih Sumber Video' },
          type: 4,
          nativeFlowInfo: {
            name: 'single_select',
            paramsJson: JSON.stringify({
              title: 'Download Video',
              sections: [
                {
                  title: 'ðŸŸ¢ Pilihan Video',
                  rows: [
                    { title: 'YouTube', description: 'Ambil dari YouTube', id: `${prefix}playvidyt ${query}` },
                    { title: 'TikTok', description: 'Ambil dari TikTok', id: `${prefix}playtiktok ${query}` }
                  ]
                }
              ]
            })
          }
        }
      ],
      headerType: 4,
      viewOnce: true,
      contextInfo: {
        isForwarded: false,
        mentionedJid: [m.sender]
      }
    }, { quoted: m });

  } catch (error) {
    console.error('[PLAYVID ERROR]', error);
    Reply('âŒ Gagal menampilkan menu PlayVid.');
  }
}
break;

case "aitts": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply(example("aku suka makan ramen"));
    if (text.length > 200) return Reply('âŒ Teks terlalu panjang. Maksimal 200 karakter.');
    
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ•’', key: m.key } });
    
    try {
        async function generateVN(text, voice = "bella") {
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const response = await axios.get(`${global.termai}/api/text2speech/elevenlabs`, {
                        params: {
                            text,
                            voice,
                            key: `${global.apitermai}`
                        },
                        responseType: "arraybuffer",
                        timeout: 30000
                    });
                    
                    return Buffer.from(response.data);
                    
                } catch (e) {
                    if (attempt === 3) {
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
            return null;
        }
        
        const audioBuffer = await generateVN(text, "bella");
        
        if (!audioBuffer) {
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            return Reply("âŒ Gagal membuat audio. Coba lagi.");
        }
        
        await alip.sendMessage(m.chat, {
            audio: audioBuffer,
            mimetype: 'audio/mpeg',
            ptt: true,
            contextInfo: {
                externalAdReply: {
                    title: "ðŸš€ Text 2 Speech",
                    body: "",
                    thumbnailUrl: "https://raw.githubusercontent.com/alifalfarel25-commits/dat1/main/uploads/alip-clutch-1769826260043.jpg",
                    mediaType: 1
                }
            }
        }, { quoted: m });
        
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
    } catch (err) {
        console.error(err);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('âŒ Terjadi kesalahan saat memproses audio.');
    }
}
break;

case "getaudio":
case "gtmp3": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  try {
    if (!text) return Reply(example("https://example.com"))
    alip.sendMessage(m.chat, { audio: { url: text }, mimetype: 'audio/mpeg' }, { quoted: m })
  } catch (e) {
    console.error(e)
    Reply(`Gagal download audio:\n${e}`)
  }
}
break;
// case play yt
case 'play': {
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  if (!text) return m.reply(`ðŸ“Œ Contoh: ${prefix + command} melukis senja`);

  const query = text.trim();

  try {
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ•–', key: m.key } });

    const ytsSearch = await yts(query);
    const video = ytsSearch.videos[0];
    if (!video) return Reply('âŒ Lagu tidak ditemukan.');

    const duration = video.timestamp || 'Unknown';
    const views = video.views || 'Unknown';

    const caption = `
*Hasil ditemukan! Pilih format di bawah ini ðŸ¥·ðŸ¿*

â”â” âŠ‘ *INFO RESULT* âŠ’
â”‚ê†œ *Channel:* ${video.author?.name || 'Unknown'}
â”‚ê†œ *Durasi:* ${duration}
â”‚ê†œ *Views:* ${views}
â”‚ê†œ *Upload:* ${video.ago || 'Unknown'}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`.trim();

    await alip.sendMessage(
      m.chat,
      {
        image: { url: video.thumbnail },
        caption,
        footer: ``,
        buttons: [
          {
            buttonId: `${prefix}playmusik ${video.url}`,
            buttonText: { displayText: "ðŸŽµ Musik" },
            type: 1,
          },
          {
            buttonId: `${prefix}ytmp4 ${video.url}`,
            buttonText: { displayText: "ðŸŽ¬ Video" },
            type: 1,
          }
        ],
        headerType: 4
      },
      { quoted: m }
    );

    await alip.sendMessage(m.chat, { react: { text: "âœ”ï¸", key: m.key } });

  } catch (error) {
    console.error('[PLAY ERROR]', error);
    Reply('âŒ Gagal menampilkan pilihan.');
  }
}
break;

case 'playmusik': {
    if (!isRegistered(m.sender) && !isCreator) return
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return
    if (!text) return Reply('Masukin link YouTube')
    if (!text.includes('youtube.com') && !text.includes('youtu.be')) return Reply('Link YouTube tidak valid')

    await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } })
    addLimit(m.sender, global.isPrem(m.sender), isCreator)

    try {
        const yt = {
            base: "https://api.apiapi.lat",
            enc: s => s.split("").map(c => c.charCodeAt()).reverse().join(";"),
            xor: s => s.split("").map(c => String.fromCharCode(c.charCodeAt() ^ 1)).join(""),
            rand: () => {
                const h = "0123456789abcdef";
                return Array.from({ length: 32 }, () => h[Math.floor(Math.random() * h.length)]).join("");
            },
            async init(url) {
                const api = `${this.base}/${this.rand()}/init/${this.enc(url)}/${this.rand()}/`;
                const res = await fetch(api, {
                    method: "POST",
                    body: JSON.stringify({ data: this.xor(url), format: "0", mp3Quality: 128 })
                });
                const j = await res.json();
                if (j.s === "C") return this.file(j.i, j.pk);
                return this.wait(j.i, j.pk);
            },
            file(i, pk) {
                return `${this.base}/${this.rand()}/download/${i}/${this.rand()}/${pk ? pk + "/" : ""}`;
            },
            async wait(i, pk) {
                let j;
                do {
                    await new Promise(r => setTimeout(r, 3000));
                    const api = `${this.base}/${this.rand()}/status/${i}/${this.rand()}/${pk ? pk + "/" : ""}`;
                    const res = await fetch(api, { method: "POST", body: JSON.stringify({ data: i }) });
                    j = await res.json();
                } while (j.s === "P");
                if (j.s === "E") throw "Gagal convert audio";
                return this.file(i, pk);
            }
        };

        const fetchBufferSafe = async (url, retry = 3) => {
            for (let i = 0; i < retry; i++) {
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(res.status);
                    return await res.buffer();
                } catch {
                    if (i === retry - 1) throw "Gagal download audio";
                    await new Promise(r => setTimeout(r, 3000));
                }
            }
        };

        const search = await yts({ query: text, hl: 'id' });
        if (!search.videos.length) return Reply('Lagu tidak ditemukan');

        const v = search.videos[0];
        
        const dl = await yt.init(v.url);
        const buffer = await fetchBufferSafe(dl);

        if (buffer.length > 50 * 1024 * 1024) {
            return Reply(`File terlalu besar (di atas 50MB)\nLink: ${dl}`);
        }

        await alip.sendMessage(
            m.chat,
            {
                audio: buffer,
                mimetype: 'audio/mpeg',
                ptt: false,
                contextInfo: {
                    externalAdReply: {
                        title: v.title,
                        body: `Durasi: ${v.timestamp}`,
                        thumbnailUrl: v.thumbnail,
                        sourceUrl: v.url,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            },
            { quoted: m }
        );

        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } })

    } catch (e) {
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } })
        
        if (e.code === 'ECONNABORTED') {
            Reply('Timeout: Proses terlalu lama')
        } else if (e.response && e.response.status === 404) {
            Reply('Audio tidak ditemukan')
        } else if (e.response && e.response.status === 403) {
            Reply('Akses ditolak oleh server')
        } else {
            Reply('Error saat memproses audio')
        }
    }
}
break

case 'fakeml': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    const qmsg = m.quoted ? m.quoted : m;
    const mime = (qmsg.msg || qmsg).mimetype || '';
    
    if (!/image/.test(mime)) {
        return Reply(`âŒ Balas gambar dengan caption:\n${prefix}fakeml UsernameKamu`);
    }
    
    if (!text) {
        return Reply(`âŒ Masukkan username!\nContoh: ${prefix}fakeml AlipPro`);
    }
    
    const nickname = text.trim();

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    await m.reply('â³ Membuat Fake Lobby ML...');

    try {
        const mediaBuffer = await qmsg.download();
        const imageUrl = await uploadPixhost(mediaBuffer, 'profile.jpg');
        
        if (!imageUrl) {
            return Reply('âŒ Gagal upload gambar');
        }
        
        const apiUrl = `https://alipai-api.vercel.app/imagecreator/fakeml?apikey=${global.apikeyalip}&nama=${encodeURIComponent(nickname)}&url=${encodeURIComponent(imageUrl)}`;
        
        await alip.sendMessage(m.chat, {
            image: { url: apiUrl },
            caption: `*âœ… Fake Lobby ML*\n*Username:* ${nickname}`,
        }, { quoted: m });

    } catch (e) {
        console.error("Error fakeml:", e);
        Reply(`âŒ Gagal: ${e.message}`);
    }
}
break;

case "gitclone": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(example("https://github.com.."))
let regex = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
if (!regex.test(text)) return Reply("Link tautan tidak valid")
try {
    let [, user, repo] = args[0].match(regex) || []
    repo = repo.replace(/.git$/, '')
    let url = `https://api.github.com/repos/${user}/${repo}/zipball`
    let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
    alip.sendMessage(m.chat, { document: { url: url }, mimetype: 'application/zip', fileName: `${filename}`}, { quoted : m })
} catch (e) {
await Reply(`Error! Repositori Tidak Ditemukan`)
}}
break
// ================= RPG CASE =================

// NGOCOK
case "ngocok": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 5) return Reply("âŒ Kamu terlalu lemes buat ngocok, istirahat dulu bro!");

  const hasil = [
    { nama: "puas tapi capek", exp: 5, gold: 10, hp: -3 },
    { nama: "ketiduran di WC", exp: 2, gold: 5, hp: -5 },
    { nama: "dapet inspirasi baru", exp: 8, gold: 15, hp: -2 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`âœŠ *Ngocok Simulator* âœŠ\n\nHasil ngocok kamu: *${reward.nama}*\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// NGELONTE
case "ngelonte": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 10) return Reply("âŒ Kamu udah loyo, ga kuat ngelonte lagi!");

  const hasil = [
    { nama: "dapet pelanggan tajir", exp: 20, gold: 100, hp: -10 },
    { nama: "dapet pelanggan pelit", exp: 10, gold: 20, hp: -5 },
    { nama: "dikejar Satpol PP", exp: 15, gold: 0, hp: -15 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ’ƒ *Ngelonte Simulator* ðŸ’ƒ\n\nKamu nekad turun ke jalan dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// OPENBO
case "openbo": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 10) return Reply("âŒ Kamu ga punya tenaga buat open BO!");

  const hasil = [
    { nama: "dapet om-om sultan", exp: 30, gold: 200, hp: -15 },
    { nama: "dapet bocil epep", exp: 10, gold: 5, hp: -5 },
    { nama: "ditipu pelanggan", exp: 5, gold: 0, hp: -20 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ‘  *Open BO Simulator* ðŸ‘ \n\nKamu pasang iklan open BO dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// NGOJEK
case "ngojek": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 8) return Reply("âŒ Kamu terlalu capek buat narik ojek!");

  const hasil = [
    { nama: "dapet orderan jauh", exp: 15, gold: 70, hp: -8 },
    { nama: "dapet orderan deket", exp: 8, gold: 30, hp: -5 },
    { nama: "kecelakaan kecil", exp: 5, gold: 10, hp: -15 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ›µ *Ojek Online Simulator* ðŸ›µ\n\nKamu narik ojek hari ini dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// NGAJI
case "ngaji": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 3) return Reply("âŒ Kamu terlalu ngantuk buat ngaji!");

  const hasil = [
    { nama: "hatimu jadi tenang", exp: 20, gold: 0, hp: 10 },
    { nama: "dapet ilmu baru", exp: 15, gold: 0, hp: 5 },
    { nama: "ketiduran pas ngaji", exp: 5, gold: 0, hp: -3 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp > player.maxHp) player.hp = player.maxHp;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ“– *Ngaji Simulator* ðŸ“–\n\nKamu buka Al-Qur'an dan *${reward.nama}*.\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp > 0 ? "+" : ""}${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// ================= RPG CASE =================

// KERJA
case "kerja": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 8) return Reply("âŒ Kamu kelelahan, ga bisa kerja sekarang!");

  const hasil = [
    { nama: "kerja lembur dapet bonus", exp: 20, gold: 150, hp: -10 },
    { nama: "kerja santai tapi gaji kecil", exp: 10, gold: 50, hp: -5 },
    { nama: "dimarahin bos", exp: 5, gold: 30, hp: -8 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ’¼ *Kerja Simulator* ðŸ’¼\n\nKamu kerja seharian dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// JOBKERJA
case "jobkerja": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 8) return Reply("âŒ Kamu terlalu capek buat kerja tambahan!");

  const hasil = [
    { nama: "jadi kuli bangunan", exp: 15, gold: 100, hp: -12 },
    { nama: "jadi admin warnet", exp: 12, gold: 60, hp: -7 },
    { nama: "kerja part-time di kafe", exp: 18, gold: 80, hp: -10 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸ§‘â€ðŸ”§ *Job Kerja Simulator* ðŸ§‘â€ðŸ”§\n\nKamu ambil kerja tambahan dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

// BERKEBUN
case "berkebun": {
  let jid = m.sender;
  if (!rpgDB.players[jid]) rpgDB.players[jid] = initPlayerRPG(jid);
  let player = rpgDB.players[jid];
  if (player.hp < 6) return Reply("âŒ Kamu kecapekan, ga bisa berkebun dulu!");

  const hasil = [
    { nama: "panen padi melimpah", exp: 25, gold: 120, hp: -10 },
    { nama: "dapet sayur segar", exp: 15, gold: 70, hp: -5 },
    { nama: "tanaman diserang hama", exp: 8, gold: 30, hp: -7 }
  ];
  let reward = hasil[Math.floor(Math.random() * hasil.length)];
  player.hp += reward.hp; if (player.hp < 0) player.hp = 0;
  player.gold += reward.gold;
  let leveled = gainExp(player, reward.exp);
  fs.writeFileSync(rpgDBPath, JSON.stringify(rpgDB, null, 2));

  Reply(`ðŸŒ¾ *Berkebun Simulator* ðŸŒ¾\n\nKamu berkebun hari ini dan hasilnya: *${reward.nama}*!\n\nðŸ“Š Hasil:\nâ€¢ EXP +${reward.exp}\nâ€¢ Gold +${reward.gold}\nâ€¢ HP ${reward.hp} (${player.hp}/${player.maxHp})\n${leveled ? `â¬†ï¸ Level Up! Level kamu sekarang *${player.level}*` : ""}`);
}
break;

//================================================================================

case "ssweb": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(example("https://example.com"))
if (!isUrl(text)) return Reply(example("https://example.com"))
const {
  screenshotV1, 
  screenshotV2,
  screenshotV3 
} = require('getscreenshot.js')
const fs = require('fs')
const data = await screenshotV2(text)
await alip.sendMessage(m.chat, { image: data, mimetype: "image/png"}, {quoted: m})
}
break
//================================================================================

case "shortlink": case "shorturl": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(example("https://example.com"))
if (!isUrl(text)) return Reply(example("https://example.com"))
var res = await axios.get('https://tinyurl.com/api-create.php?url='+encodeURIComponent(text))
var link = `
* *Shortlink by tinyurl.com*
${res.data.toString()}
`
return Reply(link)
}
break


case "shortlink-dl": {


if (!text) return Reply(example("https://example.com"))
if (!isUrl(text)) return Reply(example("https://example.com"))
var a = await fetch(`https://moneyblink.com/st/?api=524de9dbd18357810a9e6b76810ace32d81a7d5f&url=${text}`)
await alip.sendMessage(m.chat, {text: a.url}, {quoted: m})
}
break

//================================================================================

case 'tekateki': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const soalList = [
    { soal: "Aku punya leher tapi tidak punya kepala. Siapakah aku?", jawaban: "baju" },
    { soal: "Makin malam makin terang, aku apa?", jawaban: "bulan" },
    { soal: "Aku bisa menghilang saat kau sebut namaku. Siapa aku?", jawaban: "hening" },
    { soal: "Apa yang bisa naik tapi tidak turun?", jawaban: "umur" },
    { soal: "Apa yang selalu datang tapi tak pernah tiba?", jawaban: "besok" },
    { soal: "Aku punya kaki tapi tidak bisa berjalan. Apakah aku?", jawaban: "meja" },
    { soal: "Apa yang selalu basah saat mengeringkan?", jawaban: "handuk" },
    { soal: "Benda apa yang dilempar malah kembali?", jawaban: "boomerang" },
    { soal: "Benda apa yang kalau dipakai tetap dingin?", jawaban: "kipas" },
    { soal: "Kenapa ayam menyeberang jalan?", jawaban: "karena ingin ke seberang" },
    { soal: "Apa yang bulat, kecil, tapi bikin orang pusing?", jawaban: "utang" },
    { soal: "Apa yang bisa dilihat tapi tidak bisa disentuh?", jawaban: "bayangan" },
    { soal: "Semakin banyak diambil, semakin besar. Apakah aku?", jawaban: "lubang" },
    { soal: "Aku selalu bersama kamu tapi kamu gak bisa pegang aku. Apa aku?", jawaban: "bayangan" },
    { soal: "Aku bisa terbang tanpa sayap dan bisa jatuh tanpa terluka. Apa aku?", jawaban: "waktu" },
    { soal: "Apa yang bisa memanjat tapi tidak punya kaki?", jawaban: "suara" },
    { soal: "Semua orang punya tapi tak bisa dilihat. Apakah aku?", jawaban: "pikiran" },
    { soal: "Benda apa yang tiap hari dibuka tutup tapi tidak marah?", jawaban: "pintu" },
    { soal: "Apa yang bisa masuk rumah tanpa izin?", jawaban: "udara" },
    { soal: "Apa yang gak bisa dilihat tapi bisa dirasakan?", jawaban: "angin" },
    { soal: "Apa yang selalu kamu bawa tapi gak pernah kamu lihat?", jawaban: "punggung" },
    { soal: "Aku bisa nyala tanpa api. Aku apa?", jawaban: "lampu" },
    { soal: "Apa yang kalau berdiri dia miring, tapi kalau tidur dia lurus?", jawaban: "pensil" },
    { soal: "Apa yang warnanya putih tapi bukan kapas?", jawaban: "awan" },
    { soal: "Aku lahir dari api, tapi aku basah. Siapakah aku?", jawaban: "abu" },
    { soal: "Apa yang bisa berputar tapi tidak jalan?", jawaban: "kipas angin" },
    { soal: "Apa yang kalau disimpan dia hilang?", jawaban: "rahasia" },
    { soal: "Apa yang bisa mengikat tapi tidak kelihatan?", jawaban: "janji" },
    { soal: "Aku selalu di belakang kamu, tapi kamu gak bisa lihat aku. Apa aku?", jawaban: "masa lalu" },
    { soal: "Apa yang selalu benar tapi jarang dipercaya?", jawaban: "logika" },
    { soal: "Aku punya tangan tapi gak punya jari. Siapa aku?", jawaban: "jam" }
];
    let soalAcak = soalList[Math.floor(Math.random() * soalList.length)];
    global.tekatekiJawaban = soalAcak.jawaban.toLowerCase();

    Reply(`â“ *Teka-Teki Waktu Santai!*\n\n*Soal:* ${soalAcak.soal}\n\nKetik *.jawabteka [jawaban kamu]*`);
}
break;

case 'jawabteka': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!global.tekatekiJawaban) return Reply("âš ï¸ Belum ada teka-teki yang aktif. Ketik *.tekateki* dulu!");

    const jawabanUser = text.toLowerCase().trim();
    if (jawabanUser === global.tekatekiJawaban) {
        Reply("âœ… *Bener cuy!* Pinter juga kepala lu!");
    } else {
        Reply(`âŒ *Salah!*\nClue: Jawabannya ${global.tekatekiJawaban.length} huruf.`);
    }
}
break;

case 'kuis': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const soalList = [
        { soal: "Ibukota Indonesia adalah?", jawaban: "jakarta" },
        { soal: "Siapa presiden pertama Indonesia?", jawaban: "soekarno" },
        { soal: "Planet terbesar di tata surya?", jawaban: "jupiter" },
        { soal: "Bendera Jepang berwarna apa?", jawaban: "putih merah" },
        { soal: "Jumlah provinsi di Indonesia tahun 2023?", jawaban: "38" },
        { soal: "Bahasa resmi negara Brazil?", jawaban: "portugis" },
        { soal: "1 lusin berapa?", jawaban: "12" },
        { soal: "Apa kepanjangan dari CPU?", jawaban: "central processing unit" },
        { soal: "Lambang kimia dari air?", jawaban: "h2o" },
        { soal: "Gunung tertinggi di dunia?", jawaban: "everest" },
        { soal: "Apa warna daun?", jawaban: "hijau" },
        { soal: "Binatang berkaki delapan?", jawaban: "laba-laba" },
        { soal: "Apa yang dipakai untuk menulis di papan tulis?", jawaban: "spidol" },
        { soal: "Ibukota Jawa Barat?", jawaban: "bandung" },
        { soal: "Sebutkan alat musik yang ditiup?", jawaban: "seruling" }
    ];
    let soalAcak = soalList[Math.floor(Math.random() * soalList.length)];
    global.kuisJawaban = soalAcak.jawaban.toLowerCase();
    Reply(`ðŸŽ¯ *KUIS CEPAT!* \n\n*Soal:* ${soalAcak.soal}\n\nKetik *.jawabkuis [jawaban kamu]*`);
}
break;

case 'jawabkuis': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!global.kuisJawaban) return Reply("âš ï¸ Belum ada soal kuis! Ketik *.kuis* dulu!");

    const jawabanUser = text.toLowerCase().trim();
    if (jawabanUser === global.kuisJawaban) {
        Reply("âœ… *Betul banget! Pinter juga otak kamu!*");
    } else {
        Reply(`âŒ *Salah!* Clue: Jawabannya ${global.kuisJawaban.length} huruf.`);
    }
}
break;

case 'tebakff': {
  const axios = require('axios');
  const fetch = require('node-fetch');

if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!global.isPrem(m.sender) && !isCreator)
    return Reply('âŒ Fitur ini khusus user premium.\nSilakan upgrade ke premium untuk akses.');

  if (!global._tebakff) global._tebakff = {};
  if (global._tebakff[m.sender]) {
    return Reply('âš ï¸ Masih ada soal aktif. Jawab dulu pakai: *.jawab <nama>*');
  }

  try {
    const res = await axios.get('https://api.siputzx.my.id/api/games/karakter-freefire');
    const data = res.data?.data;
    const image = data?.gambar;
    const jawaban = data?.name;

    if (!image || !jawaban) throw new Error('API tidak mengandung gambar atau nama.');

    const imgRes = await fetch(image);
    if (!imgRes.ok) throw new Error('Gagal download gambar.');
    const imgBuf = await imgRes.buffer();

    global._tebakff[m.sender] = {
      answer: jawaban.toLowerCase(),
      timeout: setTimeout(() => {
        if (global._tebakff[m.sender]) {
          Reply(`â° Waktu habis! Jawaban: *${jawaban}*`);
          delete global._tebakff[m.sender];
        }
      }, 60000)
    };

    await alip.sendMessage(m.chat, {
      image: imgBuf,
      caption: `ðŸŽ¯ Tebak Karakter Free Fire\n\nKetik: *.jawab <nama>*\nWaktu: 60 detik`
    }, { quoted: m });

  } catch (e) {
    console.error('âŒ Error tebakff:', e);
    Reply(`âŒ Gagal ambil soal: ${e.message}`);
  }
}
break;

case 'jawab': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!global.isPrem(m.sender) && !isCreator)
    return Reply('âŒ Fitur ini hanya untuk user premium.');

  if (!global._tebakff || !global._tebakff[m.sender]) {
    return Reply('âŒ Ga ada soal aktif. Ketik *.tebakff* dulu.');
  }

  const jawab = args.join(' ').toLowerCase();
  if (!jawab) return Reply('Ketik jawaban kamu: *.jawab <nama karakter>*');

  const data = global._tebakff[m.sender];
  if (jawab === data.answer) {
    clearTimeout(data.timeout);
    delete global._tebakff[m.sender];
    return Reply('âœ… Jawaban benar! Kamu keren!');
  } else {
    return Reply('âŒ Jawaban salah! Coba lagi.');
  }
}
break;

case 'tebakkah': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  // Cek akses user

    const soalList = [
        { soal: "Apa yang bisa terbang, tetapi tidak memiliki sayap?", jawaban: "waktu" },
        { soal: "Aku punya banyak kunci, tapi tidak bisa membuka pintu. Apa aku?", jawaban: "piano" },
        { soal: "Apa yang selalu naik tapi tidak pernah turun?", jawaban: "umur" },
        { soal: "Aku bisa dipegang, tapi tidak bisa dilihat. Apa aku?", jawaban: "janji" },
        { soal: "Apa yang bisa dipotong, tapi tidak berkurang?", jawaban: "rambut" },
        { soal: "Aku bisa menangis tanpa mata. Apa aku?", jawaban: "awan" },
        { soal: "Apa yang ada di depan kamu, tapi kamu tidak bisa melihatnya?", jawaban: "masa depan" },
        { soal: "Aku bisa berlari, tapi tidak punya kaki. Apa aku?", jawaban: "air" },
        { soal: "Aku bisa terbang, tapi bukan burung. Aku adalah?", jawaban: "layang-layang" },
        { soal: "Aku bisa berbicara, tapi tidak punya mulut. Apa aku?", jawaban: "gema" }
    ];
    let soalAcak = soalList[Math.floor(Math.random() * soalList.length)];
    global.tebakJawaban = soalAcak.jawaban.toLowerCase();
    Reply(`ðŸŽ® *Game Tebak Random!*\n\nâ“ *Soal:* ${soalAcak.soal}\n\nKetik *.jawabtebak [jawaban kamu]*`);
}
break;

case 'jawabtebak': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  // Cek akses user

    if (!global.tebakJawaban) return Reply("âš ï¸ Belum ada soal tebak! Ketik *.tebakkah* dulu!");
    let jawabanUser = text.toLowerCase().trim();
    if (jawabanUser === global.tebakJawaban) {
        Reply("âœ… *Benar! Jawaban lo tepat!*");
    } else {
        Reply(`âŒ *Salah!* Clue: Jawabannya ada ${global.tebakJawaban.length} huruf.`);
    }
}
break;

case 'cekfemboy': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!text) return Reply('Masukin nama dulu, biar bisa gue nilai... seberapa layak lo dibisik "malam ini kamu punyaku ya~".');

    let target = text || m.pushName;

    const hash = Array.from(target).reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const percent = Math.floor((hash * Date.now()) % 101);

    let rank = '';
    if (percent >= 95) {
        rank = 'UKE LEGENDARIS';
    } else if (percent >= 85) {
        rank = 'FEMBOY HOTLINE';
    } else if (percent >= 70) {
        rank = 'FEMBOY SIAGA 1';
    } else if (percent >= 50) {
        rank = 'FEMBOY NGEFLIRT';
    } else if (percent >= 30) {
        rank = 'FEMBOY TERPENDAM';
    } else {
        rank = 'TARGET FANTASI';
    }

    let komentar = '';
    if (percent >= 95) {
        komentar = 'Lo tuh femboy idaman sugar daddy. Dikit aja dikasih perhatian, langsung manja-manja sambil meringkuk di dada orang. Suara lo? ASMR-nya ngegoda setengah mati.';
    } else if (percent >= 85) {
        komentar = 'Dari cara lo ngetik aja udah kebaca: lo suka dipeluk dari belakang sambil dibisikin pelan. "Udah siap buat nakal belum?" dan lo cuma bisa ngangguk pelan.';
    } else if (percent >= 70) {
        komentar = 'Lo bukan cuma femboy... lo tuh pemicu dosa. Outfit lo selalu kebetulan *nempel banget*. Bikin yang lihat pengen langsung tarik dan bilang "ayo, kamar kosong ada nih."';
    } else if (percent >= 50) {
        komentar = 'Lo diem-diem horny. Di luar keliatan kalem, tapi pas malem sendirian, lo buka headset, pasang playlist "moan compilation", dan... ya, lo ngerti sendiri lanjutannya.';
    } else if (percent >= 30) {
        komentar = 'Aura lo tuh "aku malu, tapi mau". Sering banget dikira polos, padahal tab bookmark lo isinya *doujin* dan video-videonya full dengan tag yang... gak bisa dijelasin di sini.';
    } else {
        komentar = 'Lo bukan femboy. Tapi lo punya muka yang sering jadi thumbnail video "cowok straight dibikin leleh sama trap". Dan lo nonton... sampe habis. Diam-diam ngulang 3x.';
    }

    const notes = [
        'Note: Stop nyari "femboy gets bred" di search bar, lo ketauan.',
        'Note: Lo tuh bukan innocent, lo cuman belum ke-ekspos aja.',
        'Note: Lo suka bilang "iya kak..." pas voice? Jangan sok malu deh.',
        'Note: History lo isinya lebih orno dari VPN premium.',
        'Note: Lo udah bukan wibu biasa, lo tuh femboy enjoyer tingkat advance.',
        'Note: Kalau explore IG lo isinya cowok berseragam ketat... lo udah tau lah.',
    ];

    const pickNote = notes[Math.floor(Math.random() * notes.length)];

    Reply(`ðŸ‘¤ *${target}*\nðŸ… *RANK:* ${rank}\nðŸ”ž *${percent}% Femboy Power*\n\n${komentar}\n\n${pickNote}`);
}
break

case "idgc": case "cekidgc": {
if (!m.isGroup) return Reply(mess.group)
Reply(m.chat)
}
break

case 'asahotak': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const soalList = [
        { soal: "Apa yang makin dipotong malah makin panjang?", jawaban: "rambut" },
        { soal: "Aku punya ekor, tapi bukan hewan. Aku bisa terbang, tapi bukan burung. Aku adalah...?", jawaban: "layang-layang" },
        { soal: "Apa yang selalu naik tapi tidak pernah turun?", jawaban: "usia" },
        { soal: "Aku punya banyak lubang, tapi bisa menampung air. Aku adalah?", jawaban: "spons" },
        { soal: "Semakin kau ambil dariku, semakin aku membesar. Aku adalah?", jawaban: "lubang" },
        { soal: "Siapa yang lebih kuat dari Superman?", jawaban: "tukang parkir" },
        { soal: "Apa yang selalu ada di tengah malam?", jawaban: "huruf l" },
        { soal: "Aku bisa berdiri tanpa kaki, dan aku jatuh tanpa lutut. Aku adalah?", jawaban: "lilin" },
        { soal: "Apa yang lebih ringan dari bulu tapi tidak bisa ditahan lebih dari satu menit?", jawaban: "nafas" },
        { soal: "Aku bisa pecah tapi tidak bisa diperbaiki. Aku adalah?", jawaban: "janji" },
        { soal: "Apa yang makin dikocok makin enak?", jawaban: "kopi" },
        { soal: "Aku punya sayap tapi tidak bisa terbang. Aku adalah?", jawaban: "hidung" },
        { soal: "Aku punya 88 kunci, tapi tidak bisa membuka pintu. Aku adalah?", jawaban: "piano" },
        { soal: "Aku ada di depan kamu, tapi kamu tidak bisa melihatku. Aku adalah?", jawaban: "masa depan" },
        { soal: "Aku bisa berbicara, tapi aku tidak punya mulut. Aku adalah?", jawaban: "gema" },
        { soal: "Apa yang bisa kamu pecahkan, tapi tidak bisa dimakan?", jawaban: "telur" },
        { soal: "Aku bisa terisi penuh di pagi hari, tapi kosong di malam hari. Aku adalah?", jawaban: "energi" },
        { soal: "Apa yang punya kepala tapi tidak punya otak?", jawaban: "bawang" },
        { soal: "Aku punya tangan, tapi tidak bisa bertepuk tangan. Aku adalah?", jawaban: "jam" },
        { soal: "Apa yang bisa berlari tapi tidak punya kaki?", jawaban: "air" },
        { soal: "Aku bisa menangis tanpa mata, dan aku bisa mengapung tanpa sayap. Aku adalah?", jawaban: "awan" },
        { soal: "Aku bisa tumbuh tanpa disiram. Aku adalah?", jawaban: "masalah" },
        { soal: "Aku lebih tajam dari pedang, tapi aku tidak bisa memotong. Aku adalah?", jawaban: "lidah" },
        { soal: "Apa yang bisa berwarna-warni, tapi tidak bisa disentuh?", jawaban: "pelangi" },
        { soal: "Aku bisa terbang tanpa sayap, dan aku bisa jatuh tanpa terluka. Aku adalah?", jawaban: "waktu" },
        { soal: "Aku punya banyak jari, tapi aku bukan manusia. Aku adalah?", jawaban: "sarung tangan" },
        { soal: "Aku bisa masuk ke rumah kamu tanpa izin, tapi kamu tidak akan marah. Aku adalah?", jawaban: "udara" },
        { soal: "Aku bisa terlihat saat siang tapi tidak malam. Apa aku?", jawaban: "bayangan" },
        { soal: "Aku punya mata tapi tidak bisa melihat. Aku adalah?", jawaban: "jarum" },
        { soal: "Semakin banyak kamu isi aku, semakin ringan aku. Aku adalah?", jawaban: "balon" },
        { soal: "Apa yang bisa duduk, berjalan, dan berdiri tapi tidak punya tulang?", jawaban: "robot" },
        { soal: "Apa yang punya jendela tapi tidak bisa dibuka?", jawaban: "komputer" },
        { soal: "Aku punya dua tangan tapi tidak punya kaki. Aku adalah?", jawaban: "jam" },
        { soal: "Apa yang bisa hidup tanpa napas?", jawaban: "api" },
        { soal: "Semakin dibersihkan semakin kotor. Aku adalah?", jawaban: "lap" },
        { soal: "Aku bisa terbang dan nyala, tapi bukan pesawat. Aku adalah?", jawaban: "kembang api" },
        { soal: "Aku selalu naik turun tapi tetap di tempat. Aku adalah?", jawaban: "lift" },
        { soal: "Aku punya daun tapi bukan pohon. Aku adalah?", jawaban: "buku" },
        { soal: "Aku bisa berdiri sendiri tapi lemah kalau dibaringkan. Aku adalah?", jawaban: "huruf i" }
    ];
    let soalAcak = soalList[Math.floor(Math.random() * soalList.length)];
    global.asahJawaban = soalAcak.jawaban.toLowerCase();
    Reply(`ðŸ§  *Asah Otak!*\n\nâ“ *Soal:* ${soalAcak.soal}\n\nKetik *.jawabasah [jawaban kamu]*`);
}
break;

case 'jawabasah': {
    if (!global.asahJawaban) return Reply("âš ï¸ Belum ada soal asah otak! Ketik *.asahotak* dulu!");
    let jawabanUser = text.toLowerCase().trim();
    if (jawabanUser === global.asahJawaban) {
        Reply("âœ… *Benar! Otak lo waras dan tajem!*");
    } else {
        Reply(`âŒ *Salah!* Clue: Jawabannya ${global.asahJawaban.length} huruf.`);
    }
}
break;

case 'creategc':
case 'creategroup':
case 'creategrup': {
  // âœ… Khusus owner
  if (!isCreator) return Reply('âŒ Fitur ini khusus untuk *Owner*.')

  if (!text) return Reply(
    `âŒ Masukkan nama grup yang ingin dibuat.\n\n` +
    `Contoh:\n.creategc Nama Grup Baru`
  )

  try {
    Reply("â³ Sedang membuat grup, mohon tunggu...")

    const senderJid = m.key.remoteJid.endsWith('@g.us') ? m.key.participant : m.key.remoteJid
    const groupCreation = await alip.groupCreate(text, [senderJid])

    await sleep(1500) // fungsi delay

    const groupInviteCode = await alip.groupInviteCode(groupCreation.id)
    const inviteUrl = `https://chat.whatsapp.com/${groupInviteCode}`

    Reply(
      `âœ… *Berhasil Membuat Grup*\n\n` +
      `*ðŸ“› Nama:* ${text}\n` +
      `*ðŸ†” ID:* ${groupCreation.id}\n` +
      `*ðŸ‘¤ Admin:* @${senderJid.split('@')[0]}\n` +
      `*ðŸ”— Link:* ${inviteUrl}`, 
      [senderJid]
    )

  } catch (e) {
    console.error("creategc error:", e)
    Reply("âŒ Gagal membuat grup. Coba lagi atau pastikan bot tidak dibatasi.")
  }
}
break

//================================================================================

case "listgc": case "listgrup": {
if (!isCreator) return
let teks = `\n *ä¹‚ List all group chat*\n`
let a = await alip.groupFetchAllParticipating()
let gc = Object.values(a)
teks += `\n* *Total group :* ${gc.length}\n`
for (const u of gc) {
teks += `\n* *ID :* ${u.id}
* *Nama :* ${u.subject}
* *Member :* ${u.participants.length}
* *Status :* ${u.announce == false ? "Terbuka": "Hanya Admin"}
* *Pembuat :* ${u?.subjectOwner ? u?.subjectOwner.split("@")[0] : "Sudah Keluar"}\n`
}
return Reply(teks)
}
break

case "pin":
case "pinterest": {
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} kucing lucu`);

  const query = text.trim();

  try {
    await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });

    await alip.sendMessage(
      m.chat,
      {
        image: { url: global.image.menu },
        caption: `ðŸ“Œ *Pilih Sumber Pinterest*\n> ${query}`,
        footer: ``,
        buttons: [
          {
            buttonId: `.pinfoto ${query}`,
            buttonText: { displayText: "ðŸ“¸ Ambil Foto" },
            type: 1,
          },
          {
            buttonId: `.pinvideo ${query}`,
            buttonText: { displayText: "ðŸŽ¬ Ambil Video" },
            type: 1,
          }
        ],
        headerType: 4
      },
      { quoted: m }
    );

    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

  } catch (error) {
    console.error('[PIN ERROR]', error);
    await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
    Reply('âŒ Gagal menampilkan menu Pinterest.');
  }
}
break;

case "pinterestfoto": case "pinfoto": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(`Contoh: .${command} cat`);
      await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });
  try {
    let url = `${global.apialip}/search/pinterest?apikey=${global.apikeyalip}&q=${encodeURIComponent(text)}`;
    let response = await axios.get(url);
    let results = (response.data.result || [])
  .filter(v => typeof v === "string" && v.startsWith("http"))
    if (!results || results.length === 0) return Reply("âŒ Tidak ditemukan hasil.");
    let selected = results.slice(0, 5);
    let cards = [];
    for (let img of selected) {
      let prepared = await prepareWAMessageMedia({ image: { url: img }}, { upload: alip.waUploadToServer });
      cards.push({
        header: proto.Message.InteractiveMessage.Header.fromObject({
          hasMediaAttachment: true,
          ...prepared
        }),
        nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
          buttons: [{
            "name": "cta_url",
            "buttonParamsJson": `{\"display_text\":\"Lihat Asli\",\"url\":\"${img}\",\"merchant_url\":\"${img}\"}`
          }]
        })
      });
    }
    const msgii = await generateWAMessageFromContent(m.chat, {
      viewOnceMessageV2Extension: {
        message: {
          messageContextInfo: {
            deviceListMetadata: {},
            deviceListMetadataVersion: 2
          },
          interactiveMessage: proto.Message.InteractiveMessage.fromObject({
            body: proto.Message.InteractiveMessage.Body.fromObject({
              text: `ðŸ”Ž Hasil pencarian Pinterest untuk *${text}*`
            }),
            carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
              cards
            })
          })
        }
      }
    }, { userJid: m.sender, quoted: m });

    await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id });
  } catch (err) {
    console.error(err);
    Reply("âŒ Gagal mencari di Pinterest, coba lagi nanti.");
  }
}
break;
case "pinvideo":
case "playpinvid": {
    if (!text) return Reply('Format: .pinvideo <query>\nContoh: .pinvideo cat');
    
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

    try {
        const query = encodeURIComponent(text);
        const apiUrl = `https://api.termai.cc/api/search/pinterest-video?query=${query}&key=alipxtermai`;
        
        const response = await axios.get(apiUrl, { timeout: 30000 });

        if (!response.data?.status || !response.data?.data?.pins || response.data.data.pins.length === 0) {
            return Reply('âŒ Video tidak ditemukan.');
        }

        const pins = response.data.data.pins;
        const randomPin = pins[Math.floor(Math.random() * pins.length)];
        
        if (!randomPin.link) {
            return Reply('âŒ Video URL tidak tersedia.');
        }

        const downloadApiUrl = `https://api.termai.cc/api/downloader/pinterest?url=${encodeURIComponent(randomPin.link)}&key=alipxtermai`;
        const downloadResponse = await axios.get(downloadApiUrl, { timeout: 30000 });

        if (!downloadResponse.data?.status || !downloadResponse.data?.data?.videos) {
            return Reply('âŒ Gagal mendapatkan data video.');
        }

        const videos = downloadResponse.data.data.videos;
        const videoKeys = Object.keys(videos);
        
        if (videoKeys.length === 0) {
            return Reply('âŒ Video tidak tersedia untuk diunduh.');
        }

        let selectedVideo = videos[videoKeys[0]];
        
        for (const key of videoKeys) {
            if (key.includes('720') || key.includes('V_720P')) {
                selectedVideo = videos[key];
                break;
            }
        }

        if (!selectedVideo?.url) {
            return Reply('âŒ URL video tidak ditemukan.');
        }

        const tempVideoPath = `./tmp/pinterest_${Date.now()}.mp4`;
        const convertedVideoPath = `./tmp/pinterest_${Date.now()}_converted.mp4`;

        const videoResponse = await axios.get(selectedVideo.url, {
            responseType: 'stream',
            timeout: 60000
        });

        const writer = fs.createWriteStream(tempVideoPath);
        videoResponse.data.pipe(writer);

        await new Promise((resolve, reject) => {
            writer.on('finish', resolve);
            writer.on('error', reject);
        });

        await new Promise((resolve, reject) => {
            ffmpeg(tempVideoPath)
                .outputOptions([
                    '-c:v', 'libx264',
                    '-preset', 'fast',
                    '-crf', '28',
                    '-c:a', 'aac',
                    '-b:a', '128k',
                    '-movflags', '+faststart',
                    '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2'
                ])
                .save(convertedVideoPath)
                .on('end', resolve)
                .on('error', reject);
        });

        const videoBuffer = fs.readFileSync(convertedVideoPath);

        await alip.sendMessage(
            m.chat,
            {
                video: videoBuffer,
                mimetype: 'video/mp4',
                fileName: `pinterest_${text.replace(/\s+/g, '_')}.mp4`
            },
            { quoted: m }
        );

        fs.unlinkSync(tempVideoPath);
        fs.unlinkSync(convertedVideoPath);

    } catch (error) {
        console.error('Pinterest Video Error:', error);
        return Reply('âŒ Gagal mendownload atau convert video.');
    }
}
break;
//================================================================================
case "cekidch":
case "idch": {
  if (!text) return Reply(example("linkchnya"))
  if (!text.includes("https://whatsapp.com/channel/")) 
    return Reply("âŒ Link tautan tidak valid!")

  try {
    let result = text.split('https://whatsapp.com/channel/')[1].split(/[?&]/)[0]
    let res = await alip.newsletterMetadata("invite", result).catch(e => null)

    if (!res) return Reply("âŒ Gagal mengambil data channel!")

    // isi teks info channel
    let teks = `
â•”â”€â”€â˜‰ *CHANNEL INFO* 
â”‚âœŽ *Nama*     : ${res.name || "-"}
â”‚âœŽ *Followers*: ${res.subscribers || 0}
â”‚âœŽ *Status*   : ${res.state || "-"}
â”‚âœŽ *Verified* : ${res.verification == "VERIFIED" ? "âœ… Terverifikasi" : "âŒ Tidak"}
â•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜‰
`.trim()

    // gambar fix biar ga error toString
    let img = await prepareWAMessageMedia(
      { image: { url: "https://img1.pixhost.to/images/8474/637790880_media.jpg" }},
      { upload: alip.waUploadToServer }
    )

    const msgii = await generateWAMessageFromContent(m.chat, {
      viewOnceMessageV2Extension: {
        message: {
          messageContextInfo: {
            deviceListMetadata: {},
            deviceListMetadataVersion: 2
          },
          interactiveMessage: proto.Message.InteractiveMessage.fromObject({
            body: proto.Message.InteractiveMessage.Body.fromObject({
              text: "*info ch*"
            }),
            carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
              cards: [
                {
                  header: proto.Message.InteractiveMessage.Header.fromObject({
                    title: teks, // tampilkan info channel disini
                    hasMediaAttachment: true,
                    ...img
                  }),
                  nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
                    buttons: [
                      {
                        "name": "cta_copy",
                        "buttonParamsJson": `{\"display_text\":\"SALIN ID\",\"id\":\"${res.id}\",\"copy_code\":\"${res.id}\"}`
                      },
                      {
                    "name": "cta_url",
                    "buttonParamsJson": `{\"display_text\":\"${global.namaSaluran}\",\"url\":\"${global.linkSaluran}\",\"merchant_url\":\"${global.linkSaluran}\"}`
                      }
                    ]
                  })
                }
              ]
            })
          })
        }
      }
    }, { userJid: m.sender, quoted: m })

    await alip.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id })
  } catch (e) {
    console.error(e)
    Reply("âŒ Terjadi error!")
  }
}
break
case "stkbaik": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Baik!");
    break;
}

case "stkcantik": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Cantik!");
    break;
}

case "stkganteng": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Ganteng!");
    break;
}

case "stkhitam": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Berkelas Hitam!");
    break;
}

case "stkmiskin": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Miskin!");
    break;
}

case "stkkaya": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Kaya!");
    break;
}

case "stkmarah": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Marah!");
    break;
}

case "stksabar": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Sabar!");
    break;
}

case "stksakiti": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Suka Menyakiti!");
    break;
}

case "stkkeren": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Keren!");
    break;
}

case "stkmisterius": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Misterius!");
    break;
}

case "stksantai": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Santai!");
    break;
}

case "stksombong": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Sombong!");
    break;
}

case "stklucu": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Lucu!");
    break;
}

case "stkgila": {
  if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(mess.limit);
    if (!text) return Reply("Nama tidak ada!");
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    generateAndSendCertificate(text, "Anda dinyatakan Gila!");
    break;
}


// ================== [ STALK TIKTOK ] ==================
case "tiktokstalk": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(`Contoh:\n${prefix + command} alipclutch`);

  try {
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ”Ž', key: m.key } })

    let res = await fetch(`https://api.siputzx.my.id/api/stalk/tiktok?username=${encodeURIComponent(text)}`);
    let data = await res.json();

    if (!data.status) return m.reply("âŒ Username tidak ditemukan atau error API.");

    let user = data.data.user;
    let stats = data.data.stats;
    let info = `
â•­â”€â *TIKTOK STALKER*
â”‚ðŸ‘¤ *Username:* ${user.uniqueId}
â”‚ðŸ“› *Nama:* ${user.nickname || "-"}
â”‚ðŸ“ *Bio:* ${user.signature || "-"}
â”‚âœ… *Verified:* ${user.verified ? "Ya" : "Tidak"}
â”‚ðŸ”’ *Private:* ${user.privateAccount ? "Ya" : "Tidak"}
â”‚ðŸ‘¥ *Followers:* ${stats.followerCount}
â”‚âž¡ï¸ *Following:* ${stats.followingCount}
â”‚â¤ï¸ *Likes:* ${stats.heartCount}
â”‚ðŸŽ¥ *Video:* ${stats.videoCount}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â
    `.trim();

    await alip.sendMessage(m.chat, {
      image: { url: user.avatarLarger },
      caption: info
    }, { quoted: m });

  } catch (e) {
    console.error(e);
    m.reply("âŒ Gagal stalk TikTok, coba lagi nanti.");
  }
}
break;

case 'removebg': {
  try {
    if (!isRegistered(m.sender) && !isCreator)
      return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
      return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    const qmsg = m.quoted || m;
    const mime = (qmsg.msg || qmsg).mimetype || '';
    if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

    m.reply('â³ Sedang menghapus background gambar...');
    const media = await alip.downloadAndSaveMediaMessage(qmsg);
    
    const buffer = fs.readFileSync(media);
    const imageUrl = await uploadPixhost(buffer, 'image.png');
    
    if (!imageUrl) {
      await fs.unlinkSync(media);
      throw new Error('Gagal mengupload gambar ke server');
    }

    const { data } = await axios.get(
      `${global.btc}/api/tools/removebg?apikey=${global.apikeyalip}&url=${encodeURIComponent(imageUrl)}`
    );

    if (!data.status || !data.url) throw new Error('API gagal mengembalikan gambar');

    await alip.sendMessage(m.chat, {
      image: { url: data.url },
      caption: 'âœ… *Background Berhasil Dihapus!*'
    }, { quoted: m });

    await fs.unlinkSync(media);

  } catch (err) {
    console.error('âŒ REMOVEBG ERROR:', err);
    m.reply(`âŒ Gagal menghapus background: ${err.message}`);
  }
}
break;
//================= [ FUN MENU ] =================//

case 'apakah': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

if (!text) return Reply(example('aku ganteng'));
const jawaban = ['Iya', 'Tentu saja', 'Pasti', 'Sangat', 'Tidak', 'Tidak mungkin', 'Mustahil', 'Bisa jadi', 'Coba tanya lagi'];
const hasil = jawaban[Math.floor(Math.random() * jawaban.length)];
Reply(`ðŸ¤” Pertanyaan: ${text}\n\nðŸ¤– Jawaban: ${hasil}`);
}
break;

case 'kapan': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

if (!text) return Reply(example('aku nikah'));
const jawaban = ['Besok', 'Minggu depan', 'Bulan depan', 'Tahun depan', '10 tahun lagi', 'Lusa', 'Nanti sore', 'Tunggu gajian', 'Tidak akan pernah', 'Secepatnya'];
const hasil = jawaban[Math.floor(Math.random() * jawaban.length)];
Reply(`ðŸ¤” Pertanyaan: ${text}\n\nðŸ¤– Jawaban: ${hasil}`);
}
break;

case 'cekganteng': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

const persen = Math.floor(Math.random() * 101);
let katakata;
if (persen < 20) {
    katakata = 'Definisi cowok pas-pasan. ðŸ˜‚';
} else if (persen < 40) {
    katakata = 'Lumayan, bisa lah buat ngantri sembako. ðŸ™‚';
} else if (persen < 60) {
    katakata = 'Standar, gak jelek gak ganteng. ðŸ˜';
} else if (persen < 80) {
    katakata = 'Cakep juga, banyak yang naksir nih. ðŸ˜';
} else {
    katakata = 'Ganteng maksimal! Sainganmu cuma artis Korea. ðŸ˜';
}
Reply(`âœ¨ *CEK TINGKAT GANTENG*\n\nNama: ${text || m.pushName}\nPersentase Ganteng: ${persen}%\n\n${katakata}`);
}
break;

case 'cekcantik': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

const persen = Math.floor(Math.random() * 101);
let katakata;
if (persen < 20) {
    katakata = 'Hmm, inner beauty lebih penting kok. ðŸ˜‚';
} else if (persen < 40) {
    katakata = 'Manis, kayak janji mantan. ðŸ™‚';
} else if (persen < 60) {
    katakata = 'Cantik standar, aman lah. ðŸ˜';
} else if (persen < 80) {
    katakata = 'Aura bidadari terpancar. Bikin insecure. ðŸ˜';
} else {
    katakata = 'Cantik paripurna! Bikin cowok-cowok rela jadi babu. ðŸ˜';
}
Reply(`âœ¨ *CEK TINGKAT CANTIK*\n\nNama: ${text || m.pushName}\nPersentase Cantik: ${persen}%\n\n${katakata}`);
}
break;

case 'truth': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
const truths = [
    'Apa hal paling memalukan yang pernah kamu lakukan?',
    'Siapa orang yang paling sering kamu kepoin di sosial media?',
    'Kapan terakhir kali kamu bohong dan tentang apa?',
    'Apa kebiasaan jorok yang kamu miliki?',
    'Pernahkah kamu naksir sahabat sendiri?',
    'Apa hal tergila yang pernah kamu lakukan demi cinta?',
    'Jika kamu bisa bertukar hidup dengan seseorang selama sehari, siapa orang itu?',
    'Apa fantasi terliarmu?',
    'Pernahkah kamu ngompol saat sudah besar?',
    'Apa aib terbesar yang kamu sembunyikan?'
];
const randomTruth = truths[Math.floor(Math.random() * truths.length)];
Reply(`*TRUTH* ðŸ—£ï¸\n\nJawab dengan jujur:\n*${randomTruth}*`);
}
break;

case 'dare': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
const dares = [
    'Kirim pesan ke mantan dan bilang "aku masih sayang kamu". Screenshot hasilnya!',
    'Update status "Aku Mencintaimu, [tag orang ke-3 di kontakmu]" selama 1 jam.',
    'Telepon crush kamu dan nyanyikan lagu "Balonku Ada Lima".',
    'Tirukan suara hewan selama 1 menit di voice note.',
    'Posting foto alay-mu di story WA.',
    'Ganti nama profil WhatsApp-mu menjadi "Babu Cinta" selama 24 jam.',
    'Chat orang random dan ajak kenalan.',
    'Prank chat salah satu admin grup.',
    'Buat video TikTok dengan filter paling aneh.',
    'Spam chat temanmu dengan emoji ðŸ’© sebanyak 5 kali.'
];
const randomDare = dares[Math.floor(Math.random() * dares.length)];
Reply(`*DARE* ðŸ”¥\n\nLakukan tantangan ini:\n*${randomDare}*`);
}
break;



// islami menu

case "audiosurah": case "audiosurat": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
	let wrong = `*Example Command :*\n*.audiosurah* 1

*List Surah :*
1 : Al-Fatihah
2 : Al-Baqarah
3 : Ali 'Imran
4 : An-Nisa'
5 : Al-Ma'idah
6 : Al-An'am
7 : Al-Aâ€™raf
8 : Al-Anfal
9 : At-Taubah
10 : Yunus
11 : Hud
12 : Yusuf
13 : Ar-Raâ€™d
14 : Ibrahim
15 : Al-Hijr
16 : An-Nahl
17 : Al-Isra'
18 : Al-Kahf
19 : Maryam
20 : Ta Ha
21 : Al-Anbiya
22 : Al-Hajj
23 : Al-Muâ€™minun
24 : An-Nur
25 : Al-Furqan
26 : Asy-Syu'ara'
27 : An-Naml
28 : Al-Qasas
29 : Al-'Ankabut
30 : Ar-Rum
31 : Luqman
32 : As-Sajdah
33 : Al-Ahzab
34 : Sabaâ€™
35 : Fatir
36 : Ya Sin
37 : As-Saffat
38 : Sad
39 : Az-Zumar
40 : Ghafir
41 : Fussilat
42 : Asy-Syura
43 : Az-Zukhruf
44 : Ad-Dukhan
45 : Al-Jasiyah
46 : Al-Ahqaf
47 : Muhammad
48 : Al-Fath
49 : Al-Hujurat
50 : Qaf
51 : Az-Zariyat
52 : At-Tur
53 : An-Najm
54 : Al-Qamar
55 : Ar-Rahman
56 : Al-Waqiâ€™ah
57 : Al-Hadid
58 : Al-Mujadilah
59 : Al-Hasyr
60 : Al-Mumtahanah
61 : As-Saff
62 : Al-Jumuâ€™ah
63 : Al-Munafiqun
64 : At-Tagabun
65 : At-Talaq
66 : At-Tahrim
67 : Al-Mulk
68 : Al-Qalam
69 : Al-Haqqah
70 : Al-Maâ€™arij
71 : Nuh
72 : Al-Jinn
73 : Al-Muzzammil
74 : Al-Muddassir
75 : Al-Qiyamah
76 : Al-Insan
77 : Al-Mursalat
78 : An-Nabaâ€™
79 : An-Naziâ€™at
80 : 'Abasa
81 : At-Takwir
82 : Al-Infitar
83 : Al-Tatfif
84 : Al-Insyiqaq
85 : Al-Buruj
86 : At-Tariq
87 : Al-Aâ€™la
88 : Al-Gasyiyah
89 : Al-Fajr
90 : Al-Balad
91 : Asy-Syams
92 : Al-Lail
93 : Ad-Duha
94 : Al-Insyirah
95 : At-Tin
96 : Al-'Alaq
97 : Al-Qadr
98 : Al-Bayyinah
99 : Az-Zalzalah
100 : Al-'Adiyat
101 : Al-Qari'ah
102 : At-Takasur
103 : Al-'Asr
104 : Al-Humazah
105 : Al-Fil
106 : Quraisy
107 : Al-Maâ€™un
108 : Al-Kausar
109 : Al-Kafirun
110 : An-Nasr
111 : Al-Lahab
112 : Al-Ikhlas
113 : Al-Falaq
114 : An-Nas`
   if (!text) return Reply(`${wrong}`)
      Reply(mess.wait)
   alip.sendMessage(m.chat, { audio: { url: `https://api.lolhuman.xyz/api/quran/audio/${text}?apikey=efcb180d3fd3134748648887` }, mimetype: 'audio/mp4' }, { quoted: m });

}
break

case "kisahnabi": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(`*Example Command :*\n*.kisahnabi* adam`)
let url = await fetch(`https://raw.githubusercontent.com/ZeroChanBot/Api-Freee/a9da6483809a1fbf164cdf1dfbfc6a17f2814577/data/kisahNabi/${text}.json`)
let kisah = await url.json().catch(_ => "Error")
if (kisah == "Error") return Reply("*Not Found*")

let hasil = `*ðŸ‘³ Nabi :* ${kisah.name}
*- Tanggal Lahir :* ${kisah.thn_kelahiran}
*- Tempat Lahir :* ${kisah.tmp}
*- Usia :* ${kisah.usia}

*â€”â€”â€”â€”â€”â€” \`[ K I S A H ]\` â€”â€”â€”â€”â€”â€”*

${kisah.description}`

Reply(`${hasil}`)

}
break


case "niatsholat": case "niatshalat": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!q) return Reply(`*Example Command :*\n*.niatsholat* subuh\n\n List :\n- subuh\n- maghrib\n- dzuhur\n- isha\n- ashar`)
const niatsholat = [
    {
        index: 1,
        solat: "subuh",
        latin: "Ushalli fardhosh shubhi rok'ataini mustaqbilal qiblati adaa-an lillaahi ta'aala",
        arabic: "Ø§ÙØµÙŽÙ„Ù‘ÙÙ‰ ÙÙŽØ±Ù’Ø¶ÙŽ Ø§Ù„ØµÙ‘ÙØ¨Ù’Ø­Ù Ø±ÙŽÙƒÙ’Ø¹ÙŽØªÙŽÙŠÙ’Ù†Ù Ù…ÙØ³Ù’ØªÙŽÙ‚Ù’Ø¨ÙÙ„ÙŽ Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙŽØ©Ù Ø§ÙŽØ¯ÙŽØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙŽØ¹ÙŽØ§Ù„ÙŽÙ‰",
        translation_id: "Aku berniat shalat fardhu Shubuh dua raka'at menghadap kiblat karena Allah Ta'ala",
    },
    {
        index: 2,
        solat: "maghrib",
        latin: "Ushalli fardhol maghribi tsalaata raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
        arabic: "Ø§ÙØµÙŽÙ„Ù‘ÙÙ‰ ÙÙŽØ±Ù’Ø¶ÙŽ Ø§Ù„Ù’Ù…ÙŽØºÙ’Ø±ÙØ¨Ù Ø«ÙŽÙ„Ø§ÙŽØ«ÙŽ Ø±ÙŽÙƒÙŽØ¹ÙŽØ§ØªÙ Ù…ÙØ³Ù’ØªÙŽÙ‚Ù’Ø¨ÙÙ„ÙŽ Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙŽØ©Ù Ø§ÙŽØ¯ÙŽØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙŽØ¹ÙŽØ§Ù„ÙŽÙ‰",
        translation_id: "Aku berniat shalat fardhu Maghrib tiga raka'at menghadap kiblat karena Allah Ta'ala",
    },
    {
        index: 3,
        solat: "dzuhur",
        latin: "Ushalli fardhodl dhuhri arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
        arabic: "Ø§ÙØµÙŽÙ„Ù‘ÙÙ‰ ÙÙŽØ±Ù’Ø¶ÙŽ Ø§Ù„Ø¸Ù‘ÙÙ‡Ù’Ø±ÙØ§ÙŽØ±Ù’Ø¨ÙŽØ¹ÙŽ Ø±ÙŽÙƒÙŽØ¹ÙŽØ§ØªÙ Ù…ÙØ³Ù’ØªÙŽÙ‚Ù’Ø¨ÙÙ„ÙŽ Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙŽØ©Ù Ø§ÙŽØ¯ÙŽØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙŽØ¹ÙŽØ§Ù„ÙŽÙ‰",
        translation_id: "Aku berniat shalat fardhu Dzuhur empat raka'at menghadap kiblat karena Allah Ta'ala",
    },
    {
        index: 4,
        solat: "isha",
        latin: "Ushalli fardhol 'isyaa-i arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
        arabic: "ØµÙŽÙ„Ù‘ÙÙ‰ ÙÙŽØ±Ù’Ø¶ÙŽ Ø§Ù„Ù’Ø¹ÙØ´ÙŽØ§Ø¡Ù Ø§ÙŽØ±Ù’Ø¨ÙŽØ¹ÙŽ Ø±ÙŽÙƒÙŽØ¹ÙŽØ§ØªÙ Ù…ÙØ³Ù’ØªÙŽÙ‚Ù’Ø¨ÙÙ„ÙŽ Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙŽØ©Ù Ø§ÙŽØ¯ÙŽØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙŽØ¹ÙŽØ§Ù„ÙŽÙ‰",
        translation_id: "Aku berniat shalat fardhu Isya empat raka'at menghadap kiblat karena Allah Ta'ala",
    },
    {
        index: 5,
        solat: "ashar",
        latin: "Ushalli fardhol 'ashri arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
        arabic: "ØµÙŽÙ„Ù‘ÙÙ‰ ÙÙŽØ±Ù’Ø¶ÙŽ Ø§Ù„Ù’Ø¹ÙŽØµÙ’Ø±ÙØ§ÙŽØ±Ù’Ø¨ÙŽØ¹ÙŽ Ø±ÙŽÙƒÙŽØ¹ÙŽØ§ØªÙ Ù…ÙØ³Ù’ØªÙŽÙ‚Ù’Ø¨ÙÙ„ÙŽ Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙŽØ©Ù Ø§ÙŽØ¯ÙŽØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙŽØ¹ÙŽØ§Ù„ÙŽÙ‰",
        translation_id: "Aku berniat shalat fardhu 'Ashar empat raka'at menghadap kiblat karena Allah Ta'ala",
    }
]
    let text = q.toLowerCase() || ''
    let data = Object.values(niatsholat).find(v => v.solat == text)
    if (!data) return Reply(`${txt} Tidak Ditemukan\n\nList Solat 5 Waktu :\nâ€¢ Subuh\nâ€¢ Maghrib\nâ€¢ Dzuhur\nâ€¢ Isha\nâ€¢ Ashar`)
    Reply(`
_*Niat Sholat ${text}*_

*Arab :* ${data.arabic}

*Latin :* ${data.latin} 

*Translate :* ${data.translation_id}`.trim())
}
break

//================= [ ISLAMI MENU ] =================//

case 'ayatkursi': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

const ayat = {
    arabic: "Ù±Ù„Ù„Ù‘ÙŽÙ‡Ù Ù„ÙŽØ§Ù“ Ø¥ÙÙ„ÙŽÙ°Ù‡ÙŽ Ø¥ÙÙ„Ù‘ÙŽØ§ Ù‡ÙÙˆÙŽ Ù±Ù„Ù’Ø­ÙŽÙ‰Ù‘Ù Ù±Ù„Ù’Ù‚ÙŽÙŠÙ‘ÙÙˆÙ…Ù Ûš Ù„ÙŽØ§ ØªÙŽØ£Ù’Ø®ÙØ°ÙÙ‡ÙÛ¥ Ø³ÙÙ†ÙŽØ©ÙŒ ÙˆÙŽÙ„ÙŽØ§ Ù†ÙŽÙˆÙ’Ù…ÙŒ Ûš Ù„Ù‘ÙŽÙ‡ÙÛ¥ Ù…ÙŽØ§ ÙÙÙ‰ Ù±Ù„Ø³Ù‘ÙŽÙ…ÙŽÙ°ÙˆÙŽÙ°ØªÙ ÙˆÙŽÙ…ÙŽØ§ ÙÙÙ‰ Ù±Ù„Ù’Ø£ÙŽØ±Ù’Ø¶Ù Û— Ù…ÙŽÙ† Ø°ÙŽØ§ Ù±Ù„Ù‘ÙŽØ°ÙÙ‰ ÙŠÙŽØ´Ù’ÙÙŽØ¹Ù Ø¹ÙÙ†Ø¯ÙŽÙ‡ÙÛ¥Ù“ Ø¥ÙÙ„Ù‘ÙŽØ§ Ø¨ÙØ¥ÙØ°Ù’Ù†ÙÙ‡ÙÛ¦ Ûš ÙŠÙŽØ¹Ù’Ù„ÙŽÙ…Ù Ù…ÙŽØ§ Ø¨ÙŽÙŠÙ’Ù†ÙŽ Ø£ÙŽÙŠÙ’Ø¯ÙÙŠÙ‡ÙÙ…Ù’ ÙˆÙŽÙ…ÙŽØ§ Ø®ÙŽÙ„Ù’ÙÙŽÙ‡ÙÙ…Ù’ Û– ÙˆÙŽÙ„ÙŽØ§ ÙŠÙØ­ÙÙŠØ·ÙÙˆÙ†ÙŽ Ø¨ÙØ´ÙŽÙ‰Ù’Ø¡Ù Ù…Ù‘ÙÙ†Ù’ Ø¹ÙÙ„Ù’Ù…ÙÙ‡ÙÛ¦Ù“ Ø¥ÙÙ„Ù‘ÙŽØ§ Ø¨ÙÙ…ÙŽØ§ Ø´ÙŽØ§Ù“Ø¡ÙŽ Ûš ÙˆÙŽØ³ÙØ¹ÙŽ ÙƒÙØ±Ù’Ø³ÙÙŠÙ‘ÙÙ‡Ù Ù±Ù„Ø³Ù‘ÙŽÙ…ÙŽÙ°ÙˆÙŽÙ°ØªÙ ÙˆÙŽÙ±Ù„Ù’Ø£ÙŽØ±Ù’Ø¶ÙŽ Û– ÙˆÙŽÙ„ÙŽØ§ ÙŠÙŽÙ€Ù”ÙÙˆØ¯ÙÙ‡ÙÛ¥ Ø­ÙÙÙ’Ø¸ÙÙ‡ÙÙ…ÙŽØ§ Ûš ÙˆÙŽÙ‡ÙÙˆÙŽ Ù±Ù„Ù’Ø¹ÙŽÙ„ÙÙ‰Ù‘Ù Ù±Ù„Ù’Ø¹ÙŽØ¸ÙÙŠÙ…Ù",
    latin: "AllÄhu lÄ ilÄha illÄ huw, al-á¸¥ayyul-qayyá»¥m, lÄ ta`khuÅ¼uhá»¥ sinatuw wa lÄ na`á»¥m, lahá»¥ mÄ fis-samÄwÄti wa mÄ fil-ará¸, man Å¼allaÅ¼Ä« yasyfa'u 'indahÅ« illÄ bi`iÅ¼nih, ya'lamu mÄ baina aidÄ«him wa mÄ khalfahum, wa lÄ yuá¸¥Ä«á¹­á»¥na bisyai`im min 'ilmihÄ« illÄ bimÄ syÄ`, wasi'a kursiyyuhus-samÄwÄti wal-ará¸, wa lÄ ya`á»¥duhá»¥ á¸¥ifáº“uhumÄ, wa huwal-'aliyyul-'aáº“Ä«m.",
    translation: "Allah, tidak ada Tuhan (yang berhak disembah) melainkan Dia Yang Hidup kekal lagi terus menerus mengurus (makhluk-Nya); tidak mengantuk dan tidak tidur. Kepunyaan-Nya apa yang di langit dan di bumi. Tiada yang dapat memberi syafa'at di sisi Allah tanpa izin-Nya. Allah mengetahui apa-apa yang di hadapan mereka dan di belakang mereka, dan mereka tidak mengetahui apa-apa dari ilmu Allah melainkan apa yang dikehendaki-Nya. Kursi Allah meliputi langit dan bumi. Dan Allah tidak merasa berat memelihara keduanya, dan Allah Maha Tinggi lagi Maha Besar."
};
let teks = `ðŸ“– *Ayat Kursi (QS. Al-Baqarah: 255)*\n\n`;
teks += `*Arab:* ${ayat.arabic}\n\n`;
teks += `*Latin:* ${ayat.latin}\n\n`;
teks += `*Artinya:* ${ayat.translation}`;
Reply(teks);
}
break;

case 'doaharian': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

const doa = [
    { title: "Doa Sebelum Tidur", arabic: "Ø¨ÙØ§Ø³Ù’Ù…ÙÙƒÙŽ Ø§Ù„Ù„Ù‘ÙŽÙ‡ÙÙ…Ù‘ÙŽ Ø£ÙŽØ­Ù’ÙŠÙŽØ§ ÙˆÙŽØ¨ÙØ§Ø³Ù’Ù…ÙÙƒÙŽ Ø£ÙŽÙ…ÙÙˆØªÙ", latin: "Bismika Allahumma ahya wa bismika amut.", meaning: "Dengan nama-Mu ya Allah aku hidup dan dengan nama-Mu aku mati." },
    { title: "Doa Bangun Tidur", arabic: "Ø§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙŽÙ‡Ù Ø§Ù„Ù‘ÙŽØ°ÙÙŠ Ø£ÙŽØ­Ù’ÙŠÙŽØ§Ù†ÙŽØ§ Ø¨ÙŽØ¹Ù’Ø¯ÙŽ Ù…ÙŽØ§ Ø£ÙŽÙ…ÙŽØ§ØªÙŽÙ†ÙŽØ§ ÙˆÙŽØ¥ÙÙ„ÙŽÙŠÙ’Ù‡Ù Ø§Ù„Ù†Ù‘ÙØ´ÙÙˆØ±Ù", latin: "Alhamdulillahilladzi ahyana ba'da ma amatana wa ilaihin nusyur.", meaning: "Segala puji bagi Allah yang telah menghidupkan kami setelah mematikan kami, dan kepada-Nya kami akan kembali." },
    { title: "Doa Sebelum Makan", arabic: "Ø§Ù„Ù„Ù‘ÙŽÙ‡ÙÙ…Ù‘ÙŽ Ø¨ÙŽØ§Ø±ÙÙƒÙ’ Ù„ÙŽÙ†ÙŽØ§ ÙÙÙŠÙ…ÙŽØ§ Ø±ÙŽØ²ÙŽÙ‚Ù’ØªÙŽÙ†ÙŽØ§ ÙˆÙŽÙ‚ÙÙ†ÙŽØ§ Ø¹ÙŽØ°ÙŽØ§Ø¨ÙŽ Ø§Ù„Ù†Ù‘ÙŽØ§Ø±Ù", latin: "Allahumma barik lana fima razaqtana waqina 'adzaban nar.", meaning: "Ya Allah, berkahilah kami dalam rezeki yang telah Engkau berikan kepada kami dan peliharalah kami dari siksa api neraka." },
    { title: "Doa Sesudah Makan", arabic: "Ø§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙŽÙ‡Ù Ø§Ù„Ù‘ÙŽØ°ÙÙŠ Ø£ÙŽØ·Ù’Ø¹ÙŽÙ…ÙŽÙ†ÙŽØ§ ÙˆÙŽØ³ÙŽÙ‚ÙŽØ§Ù†ÙŽØ§ ÙˆÙŽØ¬ÙŽØ¹ÙŽÙ„ÙŽÙ†ÙŽØ§ Ù…ÙØ³Ù’Ù„ÙÙ…ÙÙŠÙ†ÙŽ", latin: "Alhamdulillahilladzi ath'amana wa saqana wa ja'alana minal muslimin.", meaning: "Segala puji bagi Allah yang telah memberi kami makan dan minum, serta menjadikan kami seorang muslim." },
    { title: "Doa Masuk Kamar Mandi", arabic: "Ø§Ù„Ù„Ù‘ÙŽÙ‡ÙÙ…Ù‘ÙŽ Ø¥ÙÙ†Ù‘ÙÙŠ Ø£ÙŽØ¹ÙÙˆØ°Ù Ø¨ÙÙƒÙŽ Ù…ÙÙ†ÙŽ Ø§Ù„Ù’Ø®ÙØ¨ÙØ«Ù ÙˆÙŽØ§Ù„Ù’Ø®ÙŽØ¨ÙŽØ§Ø¦ÙØ«Ù", latin: "Allahumma inni a'udzubika minal khubutsi wal khabaitsi.", meaning: "Ya Allah, aku berlindung pada-Mu dari godaan setan laki-laki dan setan perempuan." },
    { title: "Doa Keluar Kamar Mandi", arabic: "ØºÙÙÙ’Ø±ÙŽØ§Ù†ÙŽÙƒÙŽ Ø§Ù„Ù’Ø­ÙŽÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙŽÙ‡Ù Ø§Ù„Ù‘ÙŽØ°ÙÙŠ Ø£ÙŽØ°Ù’Ù‡ÙŽØ¨ÙŽ Ø¹ÙŽÙ†Ù‘ÙÙŠ Ø§Ù„Ù’Ø£ÙŽØ°ÙŽÙ‰ ÙˆÙŽØ¹ÙŽØ§ÙÙŽØ§Ù†ÙÙŠ", latin: "Ghufronaka alhamdulillahilladzi adzhaba 'annil adzaa wa'aafaanii.", meaning: "Dengan mengharap ampunan-Mu, segala puji milik Allah yang telah menghilangkan kotoran dari badanku dan yang telah menyejahterakan." }
];
const randomDoa = doa[Math.floor(Math.random() * doa.length)];
let teks = `ðŸ¤² *Doa Harian*\n\n`;
teks += `*Judul:* ${randomDoa.title}\n`;
teks += `*Arab:* ${randomDoa.arabic}\n`;
teks += `*Latin:* ${randomDoa.latin}\n`;
teks += `*Artinya:* ${randomDoa.meaning}`;
Reply(teks);
}
break;

case 'asmaulhusna': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);

const asmaulhusna = [
    { name: "Ar-Rahman", meaning: "Yang Maha Pengasih" },
    { name: "Ar-Rahim", meaning: "Yang Maha Penyayang" },
    { name: "Al-Malik", meaning: "Yang Maha Merajai" },
    { name: "Al-Quddus", meaning: "Yang Maha Suci" },
    { name: "As-Salam", meaning: "Yang Maha Memberi Kesejahteraan" },
    { name: "Al-Mu'min", meaning: "Yang Maha Memberi Keamanan" },
    { name: "Al-Muhaimin", meaning: "Yang Maha Mengatur" },
    { name: "Al-Aziz", meaning: "Yang Maha Perkasa" },
    { name: "Al-Jabbar", meaning: "Yang Memiliki Mutlak Kegagahan" },
    { name: "Al-Mutakabbir", meaning: "Yang Maha Megah" }
    // Tambahkan 89 sisanya jika diinginkan agar lebih lengkap
];
const randomAsma = asmaulhusna[Math.floor(Math.random() * asmaulhusna.length)];
let teks = `ðŸŒŸ *Asmaul Husna*\n\n`;
teks += `*Nama:* ${randomAsma.name}\n`;
teks += `*Artinya:* ${randomAsma.meaning}`;
Reply(teks);
}
break;


// ================== JADWAL SHOLAT OFFLINE ==================
case 'jadwalsholat': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    // Data Jadwal Sholat Offline untuk kota-kota besar di Indonesia
    let jadwal = {
      // Sumatera
      "banda aceh": { subuh: "05:18", dzuhur: "12:48", ashar: "16:10", maghrib: "18:50", isya: "20:01" },
      "medan": { subuh: "05:03", dzuhur: "12:31", ashar: "15:54", maghrib: "18:35", isya: "19:46" },
      "pekanbaru": { subuh: "04:53", dzuhur: "12:19", ashar: "15:43", maghrib: "18:24", isya: "19:35" },
      "padang": { subuh: "04:57", dzuhur: "12:25", ashar: "15:50", maghrib: "18:30", isya: "19:41" },
      "palembang": { subuh: "04:42", dzuhur: "12:08", ashar: "15:32", maghrib: "18:12", isya: "19:23" },
      "jambi": { subuh: "04:47", dzuhur: "12:14", ashar: "15:38", maghrib: "18:18", isya: "19:29" },
      "bengkulu": { subuh: "04:52", dzuhur: "12:18", ashar: "15:42", maghrib: "18:22", isya: "19:33" },
      "lampung": { subuh: "04:42", dzuhur: "12:06", ashar: "15:29", maghrib: "18:09", isya: "19:20" },

      // Jawa
      "jakarta": { subuh: "04:39", dzuhur: "12:01", ashar: "15:23", maghrib: "18:00", isya: "19:12" },
      "bandung": { subuh: "04:36", dzuhur: "11:58", ashar: "15:20", maghrib: "17:58", isya: "19:09" },
      "semarang": { subuh: "04:24", dzuhur: "11:46", ashar: "15:08", maghrib: "17:45", isya: "18:57" },
      "yogyakarta": { subuh: "04:25", dzuhur: "11:47", ashar: "15:09", maghrib: "17:46", isya: "18:58" },
      "surabaya": { subuh: "04:15", dzuhur: "11:37", ashar: "14:59", maghrib: "17:36", isya: "18:48" },
      "serang": { subuh: "04:42", dzuhur: "12:04", ashar: "15:26", maghrib: "18:03", isya: "19:15" },

      // Kalimantan
      "pontianak": { subuh: "04:29", dzuhur: "11:53", ashar: "15:17", maghrib: "17:55", isya: "19:06" },
      "banjarmasin": { subuh: "04:58", dzuhur: "12:22", ashar: "15:45", maghrib: "18:25", isya: "19:35" },
      "samarinda": { subuh: "04:49", dzuhur: "12:14", ashar: "15:36", maghrib: "18:16", isya: "19:26" },
      "palangkaraya": { subuh: "04:14", dzuhur: "11:38", ashar: "15:02", maghrib: "17:41", isya: "18:51" },
      
      // Sulawesi
      "makassar": { subuh: "04:44", dzuhur: "12:07", ashar: "15:29", maghrib: "18:08", isya: "19:18" },
      "manado": { subuh: "04:20", dzuhur: "11:49", ashar: "15:09", maghrib: "17:50", isya: "19:01" },
      "palu": { subuh: "04:39", dzuhur: "12:04", ashar: "15:25", maghrib: "18:05", isya: "19:15" },
      
      // Bali & Nusa Tenggara
      "denpasar": { subuh: "04:57", dzuhur: "12:19", ashar: "15:41", maghrib: "18:19", isya: "19:29" },
      "mataram": { subuh: "04:54", dzuhur: "12:16", ashar: "15:38", maghrib: "18:16", isya: "19:26" },
      
      // Maluku & Papua
      "ambon": { subuh: "05:07", dzuhur: "12:32", ashar: "15:52", maghrib: "18:32", isya: "19:42" },
      "jayapura": { subuh: "04:21", dzuhur: "11:48", ashar: "15:08", maghrib: "17:51", isya: "19:01" },
    };

    if (!text) {
      const listKota = Object.keys(jadwal).map(k => `- ${k.charAt(0).toUpperCase() + k.slice(1)}`).join('\n');
      return Reply(`Silakan pilih kota yang tersedia.\n\n*Contoh:* .jadwalsholat Palembang\n\n*Daftar Kota Tersedia:*\n${listKota}`);
    }

    let kota = text.toLowerCase().trim();
    if (!jadwal[kota]) {
      const listKota = Object.keys(jadwal).map(k => `- ${k.charAt(0).toUpperCase() + k.slice(1)}`).join('\n');
      return Reply(`âš ï¸ Jadwal sholat untuk kota *${text}* belum tersedia.\n\n*Silakan pilih dari daftar berikut:*\n${listKota}`);
    }

    let ye = jadwal[kota];
    let tks = `*JADWAL SHOLAT UNTUK KOTA ${text.toUpperCase()}*\n
ðŸ•Œ Shubuh  : ${ye.subuh}
ðŸ•Œ Dzuhur  : ${ye.dzuhur}
ðŸ•Œ Ashar   : ${ye.ashar}
ðŸ•Œ Maghrib : ${ye.maghrib}
ðŸ•Œ Isya    : ${ye.isya}\n
*Waktu dalam WIB/WITA/WIT disesuaikan dengan lokasi Anda.*`;

    await alip.sendMessage(m.chat, {
      text: tks,
      contextInfo: {
        externalAdReply: {
          title: `Jadwal Sholat ${text.toUpperCase()}`,
          body: `Sumber Data Offline - ${botname2}`,
          thumbnailUrl: global.image.menu,
          sourceUrl: global.namaSaluran,
          mediaType: 1,
          renderLargerThumbnail: true
        }
      }
    }, { quoted: m });

  } catch (err) {
    console.error(err);
    Reply("âŒ Terjadi error saat memproses jadwal sholat.");
  }
}
break;

case "quotesislami": case "islam": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
const islami = [
   {
      "id": "1",
      "arabic": "Ù…ÙŽÙ†Ù’ Ø³ÙŽØ§Ø±ÙŽ Ø¹ÙŽÙ„Ù‰ÙŽ Ø§Ù„Ø¯ÙŽÙ‘Ø±Ù’Ø¨Ù ÙˆÙŽØµÙŽÙ„ÙŽ",
      "arti": "Barang siapa berjalan pada jalannya, maka dia akan sampai (pada tujuannya)."
   },
   {
      "id": "2",
      "arabic": "Ù…ÙŽÙ†Ù’ ØµÙŽØ¨ÙŽØ±ÙŽ Ø¸ÙŽÙÙØ±ÙŽ",
      "arti": "Barang siapa bersabar, maka dia akan beruntung."
   },
   {
      "id": "3",
      "arabic": "Ù…ÙŽÙ†Ù’ Ø¬ÙŽØ¯ÙŽÙ‘ ÙˆÙŽØ¬ÙŽÙ€Ø¯ÙŽ",
      "arti": "Barang siapa bersungguh-sungguh, maka dia akan meraih (kesuksesan)."
   },
   {
      "id": "4",
      "arabic": "Ø¬ÙŽØ§Ù„ÙØ³Ù’ Ø£ÙŽÙ‡Ù’Ù„ÙŽ Ø§Ù„ØµÙÙ‘Ø¯Ù’Ù‚Ù ÙˆÙŽØ§Ù„ÙˆÙŽÙÙŽØ§Ø¡Ù",
      "arti": "Bergaulah bersama orang-orang yang jujur dan menepati janji."
   },
   {
      "id": "5",
      "arabic": "Ù…ÙŽÙ†Ù’ Ù‚ÙŽÙ„ÙŽÙ‘ ØµÙØ¯Ù’Ù‚ÙÙ‡Ù Ù‚ÙŽÙ„ÙŽÙ‘ ØµÙŽØ¯ÙÙŠÙ’Ù‚ÙÙ‡Ù",
      "arti": "Barang siapa sedikit kejujurannya, maka sedikit pulalah temannya."
   },
   {
      "id": 6,
      "arabic": "Ù…ÙŽÙˆÙŽØ¯ÙŽÙ‘Ø©Ù Ø§Ù„ØµÙŽÙ‘Ø¯ÙÙŠÙ’Ù‚Ù ØªÙŽØ¸Ù’Ù‡ÙŽØ±Ù ÙˆÙŽÙ‚Ù’ØªÙŽ Ø§Ù„Ø¶ÙÙ‘ÙŠÙ’Ù‚Ù",
      "arti": "Kecintaan seorang teman itu akan terlihat pada waktu kesempitan."
   },
   {
      "id": "7",
      "arabic": "Ø§Ù„ØµÙŽÙ‘Ø¨Ù’Ø±Ù ÙŠÙØ¹ÙÙŠÙ’Ù†Ù Ø¹ÙŽÙ„ÙŽÙ‰ ÙƒÙÙ„ÙÙ‘ Ø¹ÙŽÙ…ÙŽÙ„Ù",
      "arti": "Kesabaran akan menolong segala pekerjaan."
   },
   {
      "id": "8",
      "arabic": "ÙˆÙŽÙ…ÙŽØ§ Ø§Ù„Ù„ÙŽÙ‘Ø°ÙŽÙ‘Ø©Ù Ø¥ÙÙ„Ø§ÙŽÙ‘ Ø¨ÙŽØ¹Ù’Ø¯ÙŽ Ø§Ù„ØªÙŽÙ‘Ø¹ÙŽØ¨Ù",
      "arti": "Tidak ada kenikmatan kecuali setelah kepayahan."
   },
   {
      "id": "9",
      "arabic": "Ø¬ÙŽØ±ÙÙ‘Ø¨Ù’ ÙˆÙŽÙ„Ø§ÙŽØ­ÙØ¸Ù’ ØªÙŽÙƒÙÙ†Ù’ Ø¹ÙŽØ§Ø±ÙÙÙ‹Ø§",
      "arti": "Coba dan perhatikanlah, maka engkau akan menjadi orang yang tahu."
   },
   {
      "id": "10",
      "arabic": "Ø¨ÙŽÙŠÙ’Ø¶ÙŽØ©Ù Ø§Ù„ÙŠÙŽÙˆÙ’Ù…Ù Ø®ÙŽÙŠÙ’Ø±ÙŒ Ù…ÙÙ†Ù’ Ø¯ÙŽØ¬ÙŽØ§Ø¬ÙŽØ©Ù Ø§Ù„ØºÙŽØ¯Ù",
      "arti": "Telur hari ini lebih baik daripada ayam esok hari."
   },
   {
      "id": "11",
      "arabic": "Ø£ÙØ·Ù’Ù„ÙØ¨Ù Ø§Ù„Ù’Ø¹ÙÙ„Ù’Ù…ÙŽ Ù…ÙÙ†ÙŽ Ø§Ù„Ù’Ù…ÙŽÙ‡Ù’Ø¯Ù Ø¥ÙÙ„ÙŽÙ‰ Ø§Ù„ÙŽÙ‘Ù„Ø­Ù’Ø¯Ù",
      "arti": "Carilah ilmu sejak dari buaian hingga liang lahat."
   },
   {
      "id": "12",
      "arabic": "Ø§Ù„ÙˆÙŽÙ‚Ù’ØªÙ Ø£ÙŽØ«Ù’Ù…ÙŽÙ†Ù Ù…ÙÙ†ÙŽ Ø§Ù„Ø°ÙŽÙ‘Ù‡ÙŽØ¨Ù",
      "arti": "Waktu itu lebih berharga daripada emas."
   },
   {
      "id": "13",
      "arabic": "Ù„Ø§ÙŽ Ø®ÙŽÙŠÙ’Ø±ÙŽ ÙÙŠÙ Ù„ÙŽØ°ÙŽÙ‘Ø©Ù ØªÙŽØ¹Ù’Ù‚ÙØ¨Ù Ù†ÙŽØ¯ÙŽÙ…Ø§Ù‹",
      "arti": "Tak ada kebaikan bagi kenikmatan yang diiringi dengan penyesalan."
   },
   {
      "id": "14",
      "arabic": "Ø£ÙŽØ®ÙÙŠ Ù„ÙŽÙ†Ù’ ØªÙŽÙ†ÙŽØ§Ù„ÙŽ Ø§Ù„Ø¹ÙÙ„Ù’Ù…ÙŽ Ø¥ÙÙ„Ø§ÙŽÙ‘ Ø¨ÙØ³ÙØªÙŽÙ‘Ø©Ù Ø³ÙŽØ£ÙÙ†Ù’Ø¨ÙÙŠÙ’ÙƒÙŽ Ø¹ÙŽÙ†Ù’ ØªÙŽÙÙ’ØµÙÙŠÙ’Ù„ÙÙ‡ÙŽØ§ Ø¨ÙØ¨ÙŽÙŠÙŽØ§Ù†Ù: Ø°ÙŽÙƒÙŽØ§Ø¡ÙŒ ÙˆÙŽØ­ÙØ±Ù’ØµÙŒ ÙˆÙŽØ§Ø¬Ù’ØªÙÙ‡ÙŽØ§Ø¯ÙŒ ÙˆÙŽØ¯ÙØ±Ù’Ù‡ÙŽÙ…ÙŒ ÙˆÙŽØµÙØ­Ù’Ø¨ÙŽØ©Ù Ø£ÙØ³Ù’ØªÙŽØ§Ø°Ù ÙˆÙŽØ·ÙÙˆÙ’Ù„Ù Ø²ÙŽÙ…ÙŽØ§Ù†Ù",
      "arti": "Wahai saudaraku, Kamu tidak akan memperoleh ilmu kecuali dengan enam perkara, akan aku sampaikan rinciannya dengan jelas; 1) Kecerdasan, 2) Ketamaan (terhadap ilmu), 3) Kesungguhan, 4) Harta benda (sebagai bekal), 5) Bergaul dengan guru, 6) Waktu yang lama."
   },
   {
      "id": "15",
      "arabic": "Ù„Ø§ÙŽ ØªÙŽÙƒÙÙ†Ù’ Ø±ÙŽØ·Ù’Ø¨Ø§Ù‹ ÙÙŽØªÙØ¹Ù’ØµÙŽØ±ÙŽ ÙˆÙŽÙ„Ø§ÙŽ ÙŠÙŽØ§Ø¨ÙØ³Ù‹Ø§ ÙÙŽØªÙÙƒÙŽØ³ÙŽÙ‘Ø±ÙŽ",
      "arti": "Janganlah kamu bersikap lemah, sehingga kamu mudah diperas. Dan janganlah kamu bersikap keras, sehingga kamu mudah dipatahkan."
   },
   {
      "id": "16",
      "arabic": "Ù„ÙÙƒÙÙ„ÙÙ‘ Ù…ÙŽÙ‚ÙŽØ§Ù…Ù Ù…ÙŽÙ‚ÙŽØ§Ù„ÙŒ ÙˆÙŽÙ„ÙÙƒÙÙ„ÙÙ‘ Ù…ÙŽÙ‚ÙŽØ§Ù„Ù Ù…ÙŽÙ‚ÙŽØ§Ù…ÙŒ",
      "arti": "Setiap tempat memiliki perkataannya masing-masing, dan setiap perkataan memiliki tempatnya masing-masing."
   },{
      "id": "17",
      "arabic": "Ø®ÙŽÙŠÙ’Ø±Ù Ø§Ù„Ù†ÙŽÙ‘Ø§Ø³Ù Ø£ÙŽØ­Ù’Ø³ÙŽÙ†ÙÙ‡ÙÙ…Ù’ Ø®ÙÙ„ÙÙ‚Ø§Ù‹ ÙˆÙŽØ£ÙŽÙ†Ù’ÙÙŽØ¹ÙÙ‡ÙÙ…Ù’ Ù„ÙÙ„Ù†ÙŽÙ‘Ø§Ø³Ù",
      "arti": "Sebaik-baik manusia adalah yang paling baik budi pekertinya dan yang paling bermanfaat bagi manusia lainnya."
   },
   {
      "id": "18",
      "arabic": "Ø®ÙŽÙŠÙ’Ø±Ù Ø¬ÙŽÙ„ÙÙŠÙ’Ø³Ù ÙÙŠ Ø§Ù„Ø²Ù‘Ù…Ø§Ù†Ù ÙƒÙØªØ§Ø¨Ù",
      "arti": "Sebaik-baik teman duduk di setiap waktu adalah buku."
   },
   {
      "id": "19",
      "arabic": "Ù…ÙŽÙ†Ù’ ÙŠÙŽØ²Ù’Ø±ÙŽØ¹Ù’ ÙŠÙŽØ­Ù’ØµÙØ¯Ù’",
      "arti": "Barang siapa menanam, pasti ia akan memetik (mengetam)."
   },
   {
      "id": "20",
      "arabic": "Ù„ÙŽÙˆÙ’Ù„Ø§ÙŽ Ø§Ù„Ø¹ÙÙ„Ù’Ù…Ù Ù„ÙŽÙƒÙŽØ§Ù†ÙŽ Ø§Ù„Ù†ÙŽÙ‘Ø§Ø³Ù ÙƒÙŽØ§Ù„Ø¨ÙŽÙ‡ÙŽØ§Ø¦ÙÙ…Ù",
      "arti": "Kalaulah tidak karena ilmu, manusia itu seperti binatang."
   },
   {
      "id": "21",
      "arabic": "Ø³ÙŽÙ„Ø§ÙŽÙ…ÙŽØ©Ù Ø§Ù„Ø¥ÙÙ†Ù’Ø³ÙŽØ§Ù†Ù ÙÙŠÙ Ø­ÙÙÙ’Ø¸Ù Ø§Ù„Ù„ÙÙ‘Ø³ÙŽØ§Ù†Ù",
      "arti": "Keselamatan manusia itu terletak pada penjagaan lidahnya (perkataannya)."
   },
   {
      "id": "22",
      "arabic": "Ø§Ù„Ø±ÙÙ‘ÙÙ’Ù‚Ù Ø¨ÙØ§Ù„Ø¶ÙŽÙ‘Ø¹ÙÙŠÙ’ÙÙ Ù…ÙÙ†Ù’ Ø®ÙÙ„ÙÙ‚Ù Ø§Ù„Ø´ÙŽÙ‘Ø±ÙÙŠÙ’ÙÙ",
      "arti": "Berlaku lemah lembut kepada orang yang lemah itu termasuk akhlak orang yang mulia (terhormat)."
   },
   {
      "id": "23",
      "arabic": "ÙˆÙŽØ¹ÙŽØ§Ù…ÙÙ„Ù Ø§Ù„Ù†ÙŽÙ‘Ø§Ø³ÙŽ Ø¨ÙÙ…ÙŽØ§ ØªÙØ­ÙØ¨ÙÙ‘ Ù…ÙÙ†Ù’Ù‡Ù Ø¯ÙŽØ§Ø¦ÙÙ…Ø§Ù‹",
      "arti": "Dan bergaullah dengan manusia dengan sikap yang kamu juga suka diperlakukan seperti itu."
   },
   {
      "id": "24",
      "arabic": "Ù„ÙŽÙŠÙ’Ø³ÙŽ Ø§Ù„Ø¬ÙŽÙ…ÙŽØ§Ù„Ù Ø¨ÙØ£ÙŽØ«Ù’ÙˆÙŽØ§Ø¨Ù ØªÙØ²ÙŽÙŠÙÙ‘Ù†ÙÙ†ÙØ§ Ø¥ÙÙ†ÙŽÙ‘ Ø§Ù„Ø¬ÙŽÙ…ÙŽØ§Ù„ÙŽ Ø¬Ù…ÙŽØ§ÙŽÙ„Ù Ø§Ù„Ø¹ÙÙ„Ù’Ù…Ù ÙˆÙŽØ§Ù„Ø£ÙŽØ¯ÙŽØ¨Ù",
      "arti": "Kecantikan bukanlah dengan pakaian yang melekat menghiasi diri kita, sesungguhnya kecantikan ialah kecantikan dengan ilmu dan budi pekerti."
   },
   {
      "id": "25",
      "arabic": "Ù…ÙŽÙ†Ù’ Ø£ÙŽØ¹Ø§ÙŽÙ†ÙŽÙƒÙŽ Ø¹ÙŽÙ„Ù‰ÙŽ Ø§Ù„Ø´ÙŽÙ‘Ø±ÙÙ‘ Ø¸ÙŽÙ„ÙŽÙ…ÙŽÙƒÙŽ",
      "arti": "Barang siapa membantumu dalam kejahatan, maka sesungguhnya ia telah berbuat aniaya terhadapmu."
   }
]
    const randomIndex = Math.floor(Math.random() * islami.length);
const randomQuote = islami[randomIndex];
const { arabic, arti } = randomQuote;
    Reply(`${arabic}\n${arti}`)
}
break

case "infonegara": case "country": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    if (!q) return Reply("Masukkan nama negara! Contoh: .infonegara Vietnam");
    let url = `https://api.siputzx.my.id/api/tools/countryInfo?name=${encodeURIComponent(q)}`;
    try {
        let res = await fetch(url);
        let json = await res.json();
        if (!json.status) return Reply("Negara tidak ditemukan!");
        let data = json.data;
        let neighbors = data.neighbors.map(n => `- ${n.name} (${n.flag})`).join("\n");
        let replyText = `ðŸŒ *Informasi Negara: ${data.name}*\n\n` +
            `ðŸ› *Ibukota:* ${data.capital}\n` +
            `ðŸ“ *Koordinat:* ${data.coordinates.latitude}, ${data.coordinates.longitude}\n` +
            `ðŸ´ *Bendera:* ${data.flag}\n` +
            `ðŸ“ž *Kode Telepon:* ${data.phoneCode}\n` +
            `ðŸ—º *Peta:* ${data.googleMapsLink}\n` +
            `ðŸŒ *Benua:* ${data.continent.name} ${data.continent.emoji}\n` +
            `ðŸ—£ *Bahasa:* ${data.languages.native.join(", ")}\n` +
            `ðŸ’° *Mata Uang:* ${data.currency}\n` +
            `ðŸš— *Lajur Kendaraan:* ${data.drivingSide}\n` +
            `ðŸŒŸ *Terkenal Sebagai:* ${data.famousFor}\n` +
            `ðŸ› *Bentuk Pemerintahan:* ${data.constitutionalForm}\n` +
            `ðŸŒ *Domain Internet:* ${data.internetTLD}\n` +
            `ðŸŒ *Negara Tetangga:*\n${neighbors || "Tidak ada"}\n`;
        let buttons = [
            { buttonId: `${prefix}infonegara ${data.name}`, buttonText: { displayText: "ðŸ”„ Cek Lagi" }, type: 1 },
            { buttonId: `.menu`, buttonText: { displayText: "ðŸ“œ Menu" }, type: 1 }
        ];
        let message = {
            text: replyText,
            footer: "Country Info Bot",
            buttons: buttons,
            headerType: 1,
            image: { url: data.flag }
        };
        alip.sendMessage(m.chat, message, { quoted: m });
    } catch (err) {
        console.error(err);
        Reply("Terjadi kesalahan saat mengambil data.");
    }
}
    break
    
case "nulis": case "tulis": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply('âŒ Masukkan teks yang ingin ditulis.\n\nExample: nulis Biyu Tamvan');
  
  Reply(mess.wait);
  const axios = require('axios');
  let apiUrl = `https://brat.siputzx.my.id/nulis?text=${encodeURIComponent(text)}`;

  try {
    const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
    alip.sendMessage(m.chat, {
      image: Buffer.from(response.data),
      caption: `ðŸ“ *Hasil Tulisan* ðŸ“\n\nðŸ“Œ *Teks:* ${text}`
    }, { quoted: m });
  } catch (error) {
    console.log(error);
    Reply(`âŒ Error\nLogs error : ${error.message}`);
  }
}
break

case "smeme": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) return Reply(`Balas gambar/video dengan perintah:\n${prefix + command} <teks atas>|<teks bawah>`);
    
    let [atas, bawah] = text.split('|');
    let q = m.quoted ? m.quoted : m;
    let mime = (q.msg || q).mimetype || "";
    
    const isImage = mime.startsWith('image/');
    const isVideo = mime.startsWith('video/');
    const isSticker = mime === 'image/webp' || (q.msg || q).stickerMessage;
    
    if (isSticker) return Reply("âŒ Hanya bisa digunakan untuk gambar/video!");
    if (!isImage && !isVideo) return Reply("âŒ Hanya bisa digunakan untuk gambar/video!");
    if (isVideo && qmsg.seconds > 15) return Reply("âŒ Durasi video maksimal 15 detik!");
    
    await alip.sendMessage(m.chat, { react: { text: 'ðŸ–¼ï¸', key: m.key } });
    
    try {
        const mediaBuffer = await alip.downloadAndSaveMediaMessage(qmsg);
        
        if (isVideo) {
            const tempInput = `/tmp/temp_video_input_${Date.now()}_${Math.random().toString(36).substring(2)}.mp4`;
            const tempOutput = `/tmp/temp_sticker_${Date.now()}_${Math.random().toString(36).substring(2)}.webp`;
            
            fs.writeFileSync(tempInput, fs.readFileSync(mediaBuffer));
            fs.unlinkSync(mediaBuffer);
            
const ffmpegCommand = `ffmpeg -y -i ${tempInput} -t 7 -vf "scale=512:512:force_original_aspect_ratio=decrease,fps=12,drawtext=text='${atas || ""}':x=(w-text_w)/2:y=30:fontsize=w/10:fontcolor=white:borderw=4:bordercolor=black:fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf,drawtext=text='${bawah || ""}':x=(w-text_w)/2:y=h-text_h-20:fontsize=w/10:fontcolor=white:borderw=4:bordercolor=black:fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf" -vcodec libwebp -loop 0 -an -vsync 0 -r 12 ${tempOutput}`;
            
            exec(ffmpegCommand, async (error) => {
                try {
                    if (error) {
                        console.error('FFmpeg error:', error);
                        return Reply('âŒ Gagal membuat video meme');
                    }
                    
                    if (fs.existsSync(tempOutput)) {
                        const stickerBuffer = fs.readFileSync(tempOutput);
                        await alip.sendMessage(m.chat, {
                            sticker: stickerBuffer,
                            mimetype: 'image/webp'
                        }, { quoted: m });
                    }
                } catch (sendError) {
                    console.error('Send error:', sendError);
                    Reply('âŒ Gagal mengirim meme');
                } finally {
                    if (fs.existsSync(tempInput)) fs.unlinkSync(tempInput);
                    if (fs.existsSync(tempOutput)) fs.unlinkSync(tempOutput);
                }
            });
            
        } else {
            const imageBuffer = fs.readFileSync(mediaBuffer);
            const img = await loadImage(imageBuffer);
            
            const isPortrait = img.height > img.width;
            const canvasWidth = isPortrait ? img.width : img.width;
            const canvasHeight = isPortrait ? img.width * 1.25 : img.height * 0.85;
            
            const canvas = createCanvas(canvasWidth, canvasHeight);
            const ctx = canvas.getContext('2d');
            
            const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (canvasWidth - scaledWidth) / 2;
            const y = (canvasHeight - scaledHeight) / 2;
            
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            function tulisTeks(teks, yPos) {
                if (!teks || teks.trim() === '') return;
                
                teks = teks.toUpperCase();
                let baseFontSize = Math.max(canvasWidth / 10, 60);
                let fontSize = baseFontSize;
                ctx.font = `bold ${fontSize}px Impact`;
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = Math.max(fontSize / 8, 2);
                
                let maxWidth = canvasWidth * 0.85;
                let lineHeight = fontSize * 1.1;
                let lines = [];
                let words = teks.split(' ');
                let line = '';
                
                for (let word of words) {
                    let testLine = line + word + ' ';
                    let metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && line !== '') {
                        lines.push(line.trim());
                        line = word + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line.trim());
                
                if (lines.length > 3) {
                    fontSize = baseFontSize * 0.8;
                    lineHeight = fontSize * 1.1;
                    ctx.font = `bold ${fontSize}px Impact`;
                    ctx.lineWidth = Math.max(fontSize / 8, 1.5);
                }
                
                let totalHeight = lines.length * lineHeight;
                let startY;
                let padding = fontSize * 0.5;
                
                if (yPos === 'top') {
                    startY = padding + lineHeight;
                } else {
                    startY = canvasHeight - totalHeight - padding;
                }
                
                lines.forEach((lineText, index) => {
                    let lineY = startY + index * lineHeight;
                    ctx.strokeText(lineText, canvasWidth / 2, lineY);
                    ctx.fillText(lineText, canvasWidth / 2, lineY);
                });
            }
            
            if (atas && atas.trim() !== '') tulisTeks(atas.trim(), 'top');
            if (bawah && bawah.trim() !== '') tulisTeks(bawah.trim(), 'bottom');
            
            const memeBuffer = canvas.toBuffer('image/png');
            
            const { Sticker } = require('wa-sticker-formatter');
            const sticker = new Sticker(memeBuffer, {
                pack: global.packname,
                author: global.namaOwner || "alip AI",
                type: 'full',
                quality: 100
            });
            
            const stickerBuffer = await sticker.toBuffer();
            await alip.sendMessage(m.chat, { sticker: stickerBuffer }, { quoted: m });
        }
        
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
    } catch (err) {
        console.error('Meme Error:', err);
        Reply("âŒ Terjadi kesalahan saat membuat meme.");
    }
}
break;

case 'caristiker': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!global.isPrem(m.sender) && !isCreator) {
    return Reply('âŒ Fitur ini khusus user premium.');
  }

  if (!args.length) {
    return Reply('Contoh penggunaan:\n.stikerly <kata kunci>');
  }

  try {
    const text = args.join(' ');
    const fetch = require('node-fetch');
    const { Sticker } = require('wa-sticker-formatter');

    const resSearch = await fetch(`https://api.siputzx.my.id/api/sticker/stickerly-search?query=${encodeURIComponent(text)}`);
    const jsonSearch = await resSearch.json();

    if (!jsonSearch.status || !Array.isArray(jsonSearch.data) || jsonSearch.data.length === 0) {
      return Reply('Ga ada stiker dengan kata kunci itu.');
    }

    const pick = jsonSearch.data[Math.floor(Math.random() * jsonSearch.data.length)];
    const resDetail = await fetch(`https://api.siputzx.my.id/api/sticker/stickerly-detail?url=${encodeURIComponent(pick.url)}`);
    const jsonDetail = await resDetail.json();

    if (!jsonDetail.status || !jsonDetail.data || !Array.isArray(jsonDetail.data.stickers) || jsonDetail.data.stickers.length === 0) {
      return Reply('Gagal ambil data stiker.');
    }

    const packName = jsonDetail.data.name || 'alip Pack';
    const authorName = jsonDetail.data.author?.name || `${botname2}`;

    Reply(`Mengirim maksimal 3 stiker...`);

    let count = 0;
    for (const img of jsonDetail.data.stickers) {
      if (count >= 3) break;

      try {
        // Download gambar jadi buffer
        const imgRes = await fetch(img.imageUrl);
        if (!imgRes.ok) {
          console.log(`Gagal download gambar: ${img.imageUrl}`);
          continue;
        }
        const imgBuffer = await imgRes.buffer();

        // Bikin sticker dari buffer
        const sticker = new Sticker(imgBuffer, {
          pack: packName,
          author: authorName,
          type: 'full',
          categories: ['ðŸ¤–'],
          id: `${botname2}`
        });

        const buffer = await sticker.toBuffer();
        await alip.sendMessage(m.chat, { sticker: buffer }, { quoted: m });
        count++;
      } catch (e) {
        console.log(`Gagal bikin stiker dari gambar: ${img.imageUrl}`, e.message);
        // fallback: kirim gambar biasa
        await alip.sendMessage(m.chat, { image: { url: img.imageUrl }, caption: 'Gagal bikin stiker, kirim gambar biasa.' }, { quoted: m });
        count++;
      }
    }

    if (count === 0) {
      return Reply('Gagal mengirim stiker/gambar, coba keyword lain.');
    }
  } catch (e) {
    console.error('Error stikerly:', e);
    Reply(`âŒ Terjadi error saat memproses stiker:\n${e.message || e}`);
  }
}
break;

case 'telesticker':
case 'telestick':
case 'stickertele':
case 'stele': {
  if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
  
  if (!text) return Reply(`Format: .${command} <url_telegram_sticker>\nContoh: .${command} https://t.me/addstickers/packname`);
  
  addLimit(m.sender, global.isPrem(m.sender), isCreator);
  await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
  
  try {
    const url = text.trim();
    if (!url.match(/(https:\/\/t.me\/addstickers\/)/gi)) {
      return Reply('âŒ URL tidak valid! Format: https://t.me/addstickers/packname');
    }
    
    const packName = url.replace("https://t.me/addstickers/", "");
    
    const response = await axios.get(
      `https://api.telegram.org/bot7344620195:AAEI7FgAZo_dj5WBLB9KDjh75kPZPF8EufU/getStickerSet?name=${encodeURIComponent(packName)}`,
      {
        headers: { "User-Agent": "GoogleBot" },
      }
    );
    
    const stickers = response.data.result.stickers;
    
    if (!stickers || stickers.length === 0) {
      return Reply('âŒ Sticker pack tidak ditemukan atau kosong.');
    }
    
    await Reply(`ðŸ“¦ *Sticker Pack Found*\n\nðŸŽ¯ Pack Name: ${packName}\nðŸ“Š Total Stickers: ${stickers.length}\n\nâ³ Mengirim sticker...`);
    
    for (let i = 0; i < stickers.length; i++) {
      try {
        const fileId = stickers[i].thumb.file_id;
        const fileResponse = await axios.get(
          `https://api.telegram.org/bot7344620195:AAEI7FgAZo_dj5WBLB9KDjh75kPZPF8EufU/getFile?file_id=${fileId}`
        );
        
        const stickerUrl = `https://api.telegram.org/file/bot7344620195:AAEI7FgAZo_dj5WBLB9KDjh75kPZPF8EufU/${fileResponse.data.result.file_path}`;
        
        await alip.sendMessage(m.chat, {
          sticker: { url: stickerUrl },
          packname: global.packname,
          author: global.author
        });
        
        await sleep(2000);
        
      } catch (err) {
        continue;
      }
    }
    
    await Reply(`âœ… Berhasil mengirim ${stickers.length} sticker dari pack ${packName}`);
    
  } catch (error) {
    console.error('TeleSticker Error:', error);
    Reply('âŒ Gagal mengambil sticker pack. Pastikan URL valid dan pack public.');
  }
}
break;

case 'pakustad': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return m.reply(`ðŸ“Œ Contoh:\n${prefix + command} Makan sambil kuyang bisa gak pak ustad`);

  try {
    let url = `https://api.taka.my.id/pak-ustadv2?text=${encodeURIComponent(text)}`;
    await alip.sendMessage(m.chat, {
      image: { url },
      caption: '*ðŸŽ™ï¸ Ustad bilang begini...*'
    }, { quoted: m });
  } catch (e) {
    console.error(e);
    m.reply('âŒ Gagal mengambil gambar. Coba lagi nanti.');
  }
}
break;
case 'prem':
case 'premium': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  const time = new Date().toLocaleTimeString('id-ID', { 
    hour: '2-digit', 
    minute: '2-digit', 
    second: '2-digit' 
  });
  
  const date = new Date().toLocaleDateString('id-ID', {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });

  alip.sendMessage(m.chat, {
    text: `
 ð–¦¹.áŸ ð—±ð—®ð˜ð—² âµ“ ${date}

â•­â”ˆ â—Ÿð‘„ ×„ ð…„ ð“Ÿð—¿ð—²ð—ºð—¶ð˜‚ð—º'ð—Œ ð“ˆ„ Â° Ö´
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð—‰ð—‹ð—‚ð–¼ð–¾: ð—‹ð—‰ðŸ§.ðŸ¢ðŸ¢ðŸ¢
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð–½ð—Žð—‹ð–ºð—ð—‚ð—ˆð—‡: ðŸ¥ðŸ¢ ð–½ð–ºð—’ð—Œ
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð—‡ð—ˆ ð—…ð—‚ð—†ð—‚ð—
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð—‰ð—‹ð—‚ð—ˆð—‹ð—‚ð—ð—’
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð–ºð—…ð—… ð–¿ð–¾ð–ºð—ð—Žð—‹ð–¾ð—Œ
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð–ºð—…ð—… ð—€ð–ºð—†ð–¾ð—Œ
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð–½ð—ˆð—ð—‡ð—…ð—ˆð–ºð–½ ð—ð—Š
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð–ºð—‚ ð—ð—ˆð—ˆð—…ð—Œ
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð—ð—‚ð—‰ ð–»ð–ºð–½ð—€ð–¾
:: Éžâƒ˜ðµËšð“‚‚ðŸŽ ð—ð—‚ð—‰ ð—Œð—Žð—‰ð—‰ð—ˆð—‹ð—
â•°â”€â”€â”€â”ˆâ”€â”€*à©ˆð‘à¼˜â‹†â”€â”€â”ˆâ”€â”€â”€`,
    footer: "",
    buttons: [
      {
        buttonId: '.buyprem',
        buttonText: { displayText: 'ðŸŽ ð–¡ð–´ð–¸ ð–¯ð–±ð–¤ð–¬ð–¨ð–´ð–¬' },
        type: 1
      },
      {
        buttonId: '.owner',
        buttonText: { displayText: 'ðŸ« ð–§ð–´ð–¡ ð–®ð–¶ð–­ð–¤ð–±' },
        type: 1
      }
    ],
    headerType: 1,
    viewOnce: true,
    contextInfo: {
      externalAdReply: {
        title: 'ðŸŽ ðð‘ð„ðŒðˆð”ðŒ',
        body: 'ð—ˆð—‡ð—…ð—’ ðŸ§ð—„ ð–¿ð—ˆð—‹ ðŸ¥ðŸ¢ ð–½ð–ºð—’ð—Œ',
        thumbnailUrl: global.image.menu,
        sourceUrl: global.namaSaluran,
        mediaType: 1,
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

case 'alipdl':
case 'aio':
case 'allinone': {
  if (!text || !text.includes('https://')) return m.reply('âŒ Masukkan link');
  await alip.sendMessage(m.chat, {
    text: `â³ *Loading...*`
  }, { quoted: m });

  try {
    const axios = require('axios');
    const { data } = await axios.post('https://auto-download-all-in-one.p.rapidapi.com/v1/social/autolink', {
      url: text
    }, {
      headers: {
        'accept-encoding': 'gzip',
        'cache-control': 'no-cache',
        'content-type': 'application/json; charset=utf-8',
        referer: 'https://auto-download-all-in-one.p.rapidapi.com/',
        'user-agent': 'Mozilla/5.0',
        'x-rapidapi-host': 'auto-download-all-in-one.p.rapidapi.com',
        'x-rapidapi-key': '1dda0d29d3mshc5f2aacec619c44p16f219jsn99a62a516f98'
      }
    });

    if (!data || !data.medias || data.medias.length === 0)
      return m.reply('âŒ Gagal mendapatkan media.\nCoba link lain.');

    const hasil = data.medias[0];

    await alip.sendMessage(m.chat, {
      video: { url: hasil.url },
      mimetype: hasil.mime || 'video/mp4',
      caption: `âœ… *${botname2} downloader!*`
    }, { quoted: m });

  } catch (err) {
    console.error('[ERROR]', err);
    m.reply('âŒ Gagal memproses link. Coba link lain.');
  }
}
break;

case 'veo3': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    if (!text) return Reply(`Masukkan prompt. Contoh:\n${prefix + command} kota futuristik dengan AI`);
    m.reply('â³ Sedang membuat video, proses ini mungkin butuh beberapa menit...');
    try {
        const axios = require('axios'); 
        const API_URL = 'https://api-faa.my.id/faa/veo3';
        const res = await axios.get(`${API_URL}?prompt=${encodeURIComponent(text)}`);
        if (!res.data) return Reply('API tidak mengembalikan hasil, coba lagi nanti.');
        let videoUrl = res.data.video || res.data.url;
        if (!videoUrl) {
            const stringified = JSON.stringify(res.data);
            const match = stringified.match(/https?:\/\/[^\s"]+\.mp4/);
            if (match) videoUrl = match[0];
        }

        if (videoUrl) {
            await alip.sendMessage(m.chat, {
                video: { url: videoUrl },
                caption: `âœ… Video berhasil dibuat dengan VEO3 ðŸŽ¥\n\n*Prompt:* ${text}`
            }, { quoted: m });
        } else {
            Reply('âŒ Gagal menemukan link video dari API.\nBalikan API:\n' + JSON.stringify(res.data, null, 2));
        }

    } catch (e) {
        Reply(`ðŸš¨ Eror kak: ${e.message}`);
    }
}
break;


case 'ailabs': 
case 'buatgambar': 
case 'buatvideo': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!q) return m.reply(`âŒ Masukin promptnya dong, contoh:\n\n${prefix + command} sunset di gunung`);

  const axios = require('axios');
  const FormData = require('form-data');

  const aiLabs = {
    api: { base: 'https://text2video.aritek.app', endpoints: { text2img: '/text2img', generate: '/txt2videov3', video: '/video' } },
    headers: { 'user-agent': 'NB Android/1.0.0', 'accept-encoding': 'gzip', 'content-type': 'application/json', authorization: '' },
    state: { token: null },
    setup: {
      cipher: 'hbMcgZLlzvghRlLbPcTbCpfcQKM0PcU0zhPcTlOFMxBZ1oLmruzlVp9remPgi0QWP0QW',
      shiftValue: 3,
      dec(text, shift) { 
        return [...text].map(c => 
          /[a-z]/.test(c) ? String.fromCharCode((c.charCodeAt(0)-97-shift+26)%26+97) :
          /[A-Z]/.test(c) ? String.fromCharCode((c.charCodeAt(0)-65-shift+26)%26+65) : c
        ).join(''); 
      },
      decrypt: async function() {
        if (aiLabs.state.token) return aiLabs.state.token;
        const decrypted = this.dec(this.cipher, this.shiftValue);
        aiLabs.state.token = decrypted;
        aiLabs.headers.authorization = decrypted;
        return decrypted;
      }
    },
    deviceId() { return Array.from({ length: 16 }, () => Math.floor(Math.random()*16).toString(16)).join(''); },
    text2img: async function(prompt) {
      if (!prompt.trim()) return { success:false, code:400, result:{ error:'Input kosong bree ðŸ—¿' } };
      const token = await this.setup.decrypt();
      const form = new FormData(); 
      form.append('prompt', prompt); 
      form.append('token', token);
      try {
        const res = await axios.post(this.api.base+this.api.endpoints.text2img, form, { headers:{ ...this.headers, ...form.getHeaders() } });
        const { code, url:imageUrl } = res.data;
        if(code!==0 || !imageUrl) return { success:false, code:res.status, result:{ error:'Gagal generate image ðŸ˜‚' } };
        return { success:true, code:res.status, result:{ url:imageUrl.trim(), prompt } };
      } catch(err) { 
        return { success:false, code:err.response?.status||500, result:{ error:err.message||'Error bree ðŸ˜‚' } }; 
      }
    },
    generate: async function({prompt='', type='video'}={}) {
      if(!prompt.trim() || !/^[a-zA-Z0-9\s.,!?'-]+$/.test(prompt)) return { success:false, code:400, result:{ error:'Prompt kosong atau invalid ðŸ˜‚' } };
      if(!/^(image|video)$/.test(type)) return { success:false, code:400, result:{ error:'Tipe harus image/video â˜ºï¸' } };
      if(type==='image') return await this.text2img(prompt);
      await this.setup.decrypt();
      const payload = { deviceID:this.deviceId(), isPremium:1, prompt, used:[], versionCode:59 };
      try {
        const res = await axios.post(this.api.base+this.api.endpoints.generate, payload, { headers:this.headers });
        const { code, key } = res.data;
        if(code!==0 || !key) return { success:false, code:res.status, result:{ error:'Gagal ambil key ðŸ«µðŸ»ðŸ·' } };
        return await this.video(key);
      } catch(err) { 
        return { success:false, code:err.response?.status||500, result:{ error:err.message||'Error bree' } }; 
      }
    },
    video: async function(key) {
      if(!key) return { success:false, code:400, result:{ error:'Key invalid bree ðŸ˜ðŸ˜‚' } };
      await this.setup.decrypt();
      const payload = { keys:[key] }, url=this.api.base+this.api.endpoints.video;
      let attempt=0, maxAttempts=100, delay=2000;
      while(attempt<maxAttempts){ 
        attempt++;
        try {
          const res = await axios.post(url,payload,{ headers:this.headers, timeout:15000 });
          const { code, datas } = res.data;
          if(code===0 && datas?.length>0){
            const data=datas[0];
            if(data.url?.trim()) return { success:true, code:res.status, result:{ url:data.url.trim(), safe:data.safe==='true', key:data.key, progress:'100%' } };
            await new Promise(r=>setTimeout(r,delay)); 
            continue;
          }
        } catch(err) {
          if(['ECONNRESET','ECONNABORTED','ETIMEDOUT'].includes(err.code)&&attempt<maxAttempts){ await new Promise(r=>setTimeout(r,delay)); continue; }
          return { success:false, code:err.response?.status||500, result:{ error:'Gagal generate video', attempt } };
        }
      }
      return { success:false, code:504, result:{ error:'Timeout generate video', attempt } };
    }
  };

  const type = (command==='buatgambar') ? 'image' : 'video';
  m.reply(`â³ Lagi generate ${type} AI, sabar bre...`);

  try {
    const result = await aiLabs.generate({ prompt:q, type });

    if(!result.success) return m.reply(`âŒ Gagal generate ${type} AI\n\nError: ${result.result.error}`);

    if(type==='image'){
      await alip.sendMessage(m.chat,{ image:{ url:result.result.url }, caption:`âœ… AI Image berhasil dibuat!\nPrompt: ${q}`},{ quoted:m });
    } else {
      await alip.sendMessage(m.chat,{ video:{ url:result.result.url }, caption:`âœ… AI Video berhasil dibuat!\nPrompt: ${q}`},{ quoted:m });
    }
  } catch(err){
    m.reply(`âŒ Error saat generate AI: ${err.message}`);
  }
}
break;

//=============== CASE YOUTUBE SUMMARIZER ===============\\
case 'ytsummarizer': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

    if (!text) return Reply(`âŒ Masukin link YouTube!\n\nContoh : ${prefix + command} https://youtube.com/watch?v=xxxx`)

    const generateRandomDeviceHash = () => {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
        let result = ''
        for (let i = 0; i < 32; i++) result += chars.charAt(Math.floor(Math.random() * chars.length))
        return result
    }
    const getRandomOSName = () => {
        const osNames = [
            'HONOR', 'Samsung', 'Xiaomi', 'OnePlus', 'Huawei',
            'OPPO', 'Vivo', 'Realme', 'Google', 'LG',
            'Sony', 'Motorola', 'Nokia', 'TCL', 'ASUS'
        ]
        return osNames[Math.floor(Math.random() * osNames.length)]
    }
    const getRandomOSVersion = () => {
        const versions = ['8', '9', '10', '11', '12', '13', '14']
        return versions[Math.floor(Math.random() * versions.length)]
    }
    const getRandomPlatform = () => {
        const platforms = [1, 2, 3]
        return platforms[Math.floor(Math.random() * platforms.length)]
    }

    const ytsummarizer = async (url, { lang = 'id' } = {}) => {
        try {
            if (!/youtube.com|youtu.be/.test(url)) throw new Error('Invalid YouTube URL')

            const randomDeviceHash = generateRandomDeviceHash()
            const randomOSName = getRandomOSName()
            const randomOSVersion = getRandomOSVersion()
            const randomPlatform = getRandomPlatform()

            const { data: a } = await axios.post('https://gw.aoscdn.com/base/passport/v2/login/anonymous', {
                brand_id: 29,
                type: 27,
                platform: randomPlatform,
                cli_os: 'web',
                device_hash: randomDeviceHash,
                os_name: randomOSName,
                os_version: randomOSVersion,
                product_id: 343,
                language: 'en'
            }, {
                headers: { 'content-type': 'application/json' }
            })

            const { data: b } = await axios.post('https://gw.aoscdn.com/app/gitmind/v3/utils/youtube-subtitles/overviews?language=en&product_id=343', {
                url: url,
                language: lang,
                deduct_status: 0
            }, {
                headers: {
                    authorization: `Bearer ${a.data.api_token}`,
                    'content-type': 'application/json'
                }
            })

            while (true) {
                const { data } = await axios.get(`https://gw.aoscdn.com/app/gitmind/v3/utils/youtube-subtitles/overviews/${b.data.task_id}?language=en&product_id=343`, {
                    headers: {
                        authorization: `Bearer ${a.data.api_token}`,
                        'content-type': 'application/json'
                    }
                })
                if (data.data.sum_status === 1) return data.data
                await new Promise(res => setTimeout(res, 1000))
            }
        } catch (error) {
            throw new Error(error.message)
        }
    }

    Reply('â³ Sedang merangkum video YouTube, tunggu sebentar...')

    try {
        const result = await ytsummarizer(text)
        if (!result || !result.content) throw new Error('Eror saat ambil ringkasan.')

        await alip.sendMessage(m.chat, {
            text: `ðŸ“º *YOUTUBE SUMMARIZER*\n\nðŸ“ *Ringkasan:*\n${result.content}`
        }, { quoted: m })

        addLimit(m.sender, isPrem(m.sender), isCreator)
    } catch (err) {
        Reply(`âŒ Error: ${err.message}`)
    }
}
break
//ðŸŽµ Case Song AI - Prompt Only
case "buatlagu": {
if (!global.isPrem(m.sender) && !isCreator) return Reply('Khusus user premium');
    if (!text) return Reply(`âŒ Contoh:\n${prefix + command} lagu sedih berbahasa Indonesia, tentang kisah cinta`);

    const axios = require("axios");
    const { v4: uuidv4 } = require("uuid");

    function randomHex(length) {
      const chars = "abcdef0123456789";
      return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join("");
    }

    function gieneticTrace() {
      return `${randomHex(32)}-${randomHex(16)}`;
    }

    // login otomatis
    async function login(deviceId) {
      const res = await axios.post("https://api.sunora.mavtao.com/api/auth/login", {
        device_id: deviceId
      }, {
        headers: {
          "user-agent": "Dart/3.4 (gienetic_build)",
          "version": "2.2.2",
          "accept-encoding": "gzip",
          "content-type": "application/json",
          "buildnumber": "105",
          "platform": "android",
          "sentry-trace": gieneticTrace()
        }
      });
      return res.data?.data?.token || null;
    }

    // cek status generate
    async function polling(xAuth, maxAttempts = 20, delayMs = 15000) {
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const res = await axios.get("https://api.sunora.mavtao.com/api/music/music_page?page=1&pagesize=50", {
            headers: {
              "user-agent": "Dart/3.4 (gienetic_build)",
              "version": "2.2.2",
              "accept-encoding": "gzip",
              "x-auth": xAuth,
              "buildnumber": "105",
              "platform": "android",
              "sentry-trace": gieneticTrace()
            }
          });

          const records = res.data?.data?.records || [];
          const doneSongs = records.filter(r => r.status === "complete");

          if (doneSongs.length > 0) {
            return doneSongs[0]; // ambil 1 lagu aja
          }
        } catch (err) {
          console.error("âš ï¸ Polling error:", err.response?.data || err.message);
        }
        await new Promise(r => setTimeout(r, delayMs));
      }
      return null;
    }

    // mulai generate
    async function generateSong(prompt) {
      const deviceId = uuidv4();
      const token = await login(deviceId);
      if (!token) throw new Error("âš ï¸ Error: gagal login ke API.");

      await axios.post("https://api.sunora.mavtao.com/api/music/advanced_custom_generate", {
        description: prompt,
        instrumental_only: false
      }, {
        headers: {
          "user-agent": "Dart/3.4 (gienetic_build)",
          "version": "2.2.2",
          "accept-encoding": "gzip",
          "x-auth": token,
          "content-type": "application/json",
          "buildnumber": "105",
          "platform": "android",
          "sentry-trace": gieneticTrace()
        }
      });

      return await polling(token);
    }

    try {
      Reply(`ðŸŽ¶ Lagi bikin lagu untuk prompt:\n\n"${text}"\nâ³ Mohon tunggu sekitar 2-3 menit...`);
      const result = await generateSong(text);

      if (!result) return Reply("âŒ Gagal generate lagu, coba lagi nanti.");

      await alip.sendMessage(m.chat, {
        audio: { url: result.audio_url },
        mimetype: 'audio/mpeg',
        ptt: false
      }, { quoted: m });

      Reply(`âœ… Lagu berhasil dibuat!\n\nðŸŽµ Judul: ${result.title}\nðŸ“Œ Prompt: ${result.meta_prompt || text}\nðŸ”— Audio: ${result.audio_url}`);
    } catch (e) {
      console.error(e);
      Reply("âŒ Error saat generate lagu, coba ulang lagi.");
    }
}
break;

// ====================== FITUR NGL GENERATOR ======================
case 'nglgenerator':
case 'ngl': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
  if (!text) return Reply(`ðŸ“Œ Contoh: *.${command} beautiful girl with handsome man*`)
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ *Loading...*');

  await alip.sendMessage(m.chat, {
    image: { url: `https://api.taka.my.id/ngl?text=${encodeURIComponent(text)}` },
    caption: "doneðŸ¥·ðŸ¿"
  }, { quoted: m })
}
break

case 'stalkroblox':
case 'stalkrbx': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
    if (!text) 
        return Reply('âŒ Contoh penggunaan: .stalkroblox alipclutch');
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ *Loading...*');
  try {
    let res = await fetchJson(`https://api.siputzx.my.id/api/stalk/roblox?user=${text}`)
    if (!res.status) return m.reply("âŒ User tidak ditemukan!")

    let d = res.data
    let basic = d.basic
    let social = d.social
    let avatar = d.avatar.fullBody.data[0]?.imageUrl || ""
    let presence = d.presence.userPresences[0]

    let cap = `â•­â”€â”€â”€â§¼ *ROBLOX STALK* â§½
â”‚ ðŸ†” ID : ${basic.id}
â”‚ ðŸ‘¤ Username : ${basic.name}
â”‚ ðŸŽ­ Display : ${basic.displayName}
â”‚ ðŸ“† Dibuat : ${basic.created}
â”‚ ðŸš« Banned : ${basic.isBanned ? "Ya" : "Tidak"}
â”‚ ðŸ·ï¸ Verified : ${basic.hasVerifiedBadge ? "Ya" : "Tidak"}
â”‚ ðŸŒ Status : ${d.status || "-"}
â”‚ ðŸŽ® Presence : ${presence?.lastLocation || "Unknown"}
â”‚ ðŸ‘¥ Teman : ${social.friends.count}
â”‚ ðŸ‘¤ Followers : ${social.followers.count}
â”‚ ðŸ‘¤ Following : ${social.following.count}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`

    if (avatar) {
      await alip.sendMessage(m.chat, {
        image: { url: avatar },
        caption: cap
      }, { quoted: m })
    } else {
      m.reply(cap)
    }
  } catch (e) {
    console.error(e)
    m.reply("âŒ Terjadi error saat ambil data Roblox.")
  }
}
break

case 'cekml': {
 const axios = require('axios');

 let match = text.match(/(\d+)[\s():-]*([\d]+)/);

 if (!match || match.length < 3) {
 return alip.sendMessage(m.chat, {
 text: `â— Format salah!\n\nContoh:\n- idml 1433547270 (15943)\n- idml 1433547270(15943)\n- idml 1433547270 15943`,
 }, { quoted: m });
 }

 let id = match[1];
 let zone = match[2];
 let nickname = '-';
 let region = '-';

 await alip.sendMessage(m.chat, {
 react: { text: 'ðŸ”', key: m.key }
 });

 // Ambil info dari Deoberon
 try {
 const deoberonRes = await axios.get(`https://deoberon-api.vercel.app/stalk/mlbb?apikey=merl&userId=${id}&zoneId=${zone}`);
 const data = deoberonRes.data;

 nickname = data?.username || '-';
 region = data?.country || '-';
 id = data?.userId || id;
 zone = data?.zoneId || zone;
 } catch (e) {
 console.error('âŒ Gagal ambil data dari Deoberon:', e);
 }

 // Default diamond status
 let first50 = '-';
 let first150 = '-';
 let first250 = '-';
 let first500 = '-';

 // Ambil data dari Hams
 try {
 const hamsRes = await axios.get(`https://api.hamsoffc.me/stalk/ml-first-topup?apikey=31050602&id=${id}&zoneId=${zone}`);
 const topup = hamsRes.data?.result?.first_topup;

 if (topup?.packages) {
 const pkgs = topup.packages;
 first50 = pkgs.find(p => p.name === "50 + 50")?.status || '-';
 first150 = pkgs.find(p => p.name === "150 + 150")?.status || '-';
 first250 = pkgs.find(p => p.name === "250 + 250")?.status || '-';
 first500 = pkgs.find(p => p.name === "500 + 500")?.status || '-';
 }
 } catch (e) {
 console.error('âŒ Gagal ambil data dari Hams:', e);
 }

 const teks = `âš¡ ð—™ð—¶ð—¿ð˜€ð˜ ð—§ð—¼ð—½ ð—¨ð—½ ð—œð—»ð—³ð—¼

ðŸ‘¤ ð—¨ð˜€ð—²ð—¿ð—»ð—®ð—ºð—² : ${nickname}
ðŸŒ ð—¥ð—²ð—´ð—¶ð—¼ð—» : ${region}
ðŸ†” ð—¨ð˜€ð—²ð—¿ ð—œð—— : ${id}
ðŸ—ºï¸ ð—­ð—¼ð—»ð—² ð—œð—— : ${zone}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ ð—šð—®ð—»ð—±ð—® ð——ð—¶ð—®ð—ºð—¼ð—»ð—± ð—¦ð˜ð—®ð˜ð˜‚ð˜€ âš¡
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ’Ž 50 + 50 âž  ${first50.includes('Tidak') ? 'âŒ _Tidak Tersedia_' : (first50 !== '-' ? 'âœ… _Tersedia_' : '-')}
ðŸ’Ž 150 + 150 âž  ${first150.includes('Tidak') ? 'âŒ _Tidak Tersedia_' : (first150 !== '-' ? 'âœ… _Tersedia_' : '-')}
ðŸ’Ž 250 + 250 âž  ${first250.includes('Tidak') ? 'âŒ _Tidak Tersedia_' : (first250 !== '-' ? 'âœ… _Tersedia_' : '-')}
ðŸ’Ž 500 + 500 âž  ${first500.includes('Tidak') ? 'âŒ _Tidak Tersedia_' : (first500 !== '-' ? 'âœ… _Tersedia_' : '-')}

> sent by ${botname2} â—¡Ìˆ`;

 await alip.sendMessage(m.chat, {
 text: teks
 }, { quoted: m });

 await alip.sendMessage(m.chat, {
 react: { text: 'âœ…', key: m.key }
 });
}
break;
case 'bratimg3': case 'bratgambar3':  {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
    const axios = require('axios');
    if (!text) {
        return Reply(`*Format:*\nbratimg3 teks|tema\n\n*Contoh:*\nbratimg3 Biyu|black\n\n*List tema yang tersedia:*\n- white \n- black\n- green\n- blue\n- strike`);
    }
    let [teks, tema] = text.split('|');
    teks = teks?.trim();
    tema = tema?.trim()?.toLowerCase();
    let temaValid = ['white', 'black', 'green', 'blue', 'strike'];
    if (!temaValid.includes(tema)) tema = 'white';
    if (!teks) {
        return Reply(`*Format salah!*\nContoh: bratimg3 halo dunia|black\n\n*List tema:*\n- white \n- black\n- green\n- blue\n- strike`);
    }
    let url = `https://api.nekorinn.my.id/maker/brat?text=${encodeURIComponent(teks)}&theme=${tema}`;
    try {
        let response = await axios.get(url, { responseType: "arraybuffer" });
        let buffer = response.data;
        await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
    } catch (e) {
        console.error(e);
        Reply('Gagal mengambil data dari API. Coba lagi nanti.');
    }
}
break

case "emojigif": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!text) return Reply(example('ðŸ˜'))
try {
let brat = `${global.apialip}/tools/emojitogif?apikey=${global.apikeyalip}&emoji=${encodeURIComponent(text)}`;
let response = await axios.get(brat, { responseType: "arraybuffer" });
let videoBuffer = response.data;
let stickerBuffer = await alip.sendAsSticker(m.chat, videoBuffer, m, {
packname: global.packname,
})
} catch (err) {
console.error("Error:", err);
}
}
break

case "brat": {
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} Hai kak`);

  const safeText = typeof text === 'string' ? text : String(text || '');
  if (safeText.length > 100)
    return Reply(`âš ï¸ Maksimal 100 karakter.`);
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
  try {
    await alip.sendMessage(
      m.chat,
      {
        image: { url: global.image.menu },
        caption: `ðŸ”˜ *Pilih jenis brat*`,
        footer: ``,
        buttons: [
          {
            buttonId: `.bratgambar ${safeText}`,
            buttonText: { displayText: "ðŸ–¼ï¸ Gambar" },
            type: 1
          },
          {
            buttonId: `.bratgura ${safeText}`,
            buttonText: { displayText: "ðŸŽ€ Brat gura" },
            type: 1
          },
          {
            buttonId: `.bratanime ${safeText}`,
            buttonText: { displayText: "ðŸŽŽ Anime" },
            type: 1
          },
          {
            buttonId: `.bratgambarhd ${safeText}`,
            buttonText: { displayText: "ðŸš€ Gambar Hd" },
            type: 1
          },
          {
            buttonId: `.bratpink ${safeText}`,
            buttonText: { displayText: "ðŸŒ¸ Gambar Pink" },
            type: 1
          },
          {
            buttonId: `.bratvid ${safeText}`,
            buttonText: { displayText: "ðŸŽ¬ Video" },
            type: 1
          }
        ],
        headerType: 4
      },
      { quoted: m }
    );
await alip.sendMessage(m.chat, {
 react: { text: 'âœ…', key: m.key }
 });
  } catch (error) {
    console.error('[BRAT ERROR]', error);
    Reply('âŒ Gagal memproses perintah brat.');
  }
}
break;

case "bratgambarhd":
case "brathd": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    if (!text) 
        return m.reply('âŒ Contoh: .brathd Hello World');
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const timestamp = Date.now();
        const statusBarTime = new Date().toLocaleTimeString('id-ID', {hour: '2-digit', minute:'2-digit'});
        const signal = "5G";
        const battery = "100%";
        const carrier = "TELKOMSEL";
        const emojiType = "ios";
        const hd = "true";
        
        const encodedText = encodeURIComponent(text);
        
        const apiUrl = `${global.termai}/api/maker/brat?text=${encodedText}&timestamp=${timestamp}&emojiType=${emojiType}&statusBarTime=${encodeURIComponent(statusBarTime)}&signal=${signal}&battery=${battery}&carrier=${carrier}&hd=${hd}&key=${global.apitermai}`;
        
        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const imageBuffer = Buffer.from(response.data);
        
        const fs = require('fs');
        const { join } = require('path');
        const { tmpdir } = require('os');
        const { spawn } = require('child_process');
        
        const tmpImage = join(tmpdir(), `brat-hd-${Date.now()}.png`);
        const tmpWebp = join(tmpdir(), `brat-hd-${Date.now()}.webp`);
        fs.writeFileSync(tmpImage, imageBuffer);
        
        await new Promise((resolve, reject) => {
            const ffmpeg = spawn('ffmpeg', [
                '-i', tmpImage,
                '-vf', 'scale=512:512:force_original_aspect_ratio=decrease,format=rgba',
                '-c:v', 'libwebp',
                '-lossless', '1',
                '-q:v', '80',
                '-preset', 'default',
                '-loop', '0',
                '-an',
                '-vsync', '0',
                '-s', '512x512',
                '-f', 'webp',
                tmpWebp
            ]);
            
            ffmpeg.on('close', code => code === 0 ? resolve() : reject());
        });
        
        const stickerBuffer = fs.readFileSync(tmpWebp);
        
        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            contextInfo: {
                isForwarded: true, 
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });
        
        fs.unlinkSync(tmpImage);
        fs.unlinkSync(tmpWebp);
        
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
    } catch (e) {
        console.error('Brathd Error:', e);
        
        try {
            const timestamp = Date.now();
            const statusBarTime = new Date().toLocaleTimeString('id-ID', {hour: '2-digit', minute:'2-digit'});
            const signal = "5G";
            const battery = "100%";
            const carrier = "TELKOMSEL";
            const emojiType = "ios";
            const hd = "true";
            
            const encodedText = encodeURIComponent(text);
            
            const apiUrl = `${global.termai}/api/maker/brat?text=${encodedText}&timestamp=${timestamp}&emojiType=${emojiType}&statusBarTime=${encodeURIComponent(statusBarTime)}&signal=${signal}&battery=${battery}&carrier=${carrier}&hd=${hd}&key=${global.apitermai}`;
            
            await alip.sendMessage(m.chat, {
                image: { url: apiUrl },
                contextInfo: {
                    isForwarded: true, 
                    forwardingScore: 999,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: global.idSaluran,
                        newsletterName: global.namaSaluran,
                        serverMessageId: -1
                    }
                }
            }, { quoted: m });
            
        } catch (fallbackErr) {
            m.reply('âŒ Gagal membuat stiker atau gambar.');
        }
    }
}
break;

case "bratgambar": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    if (!text) 
        return m.reply('âŒ Contoh: .bratgambar Hello World');
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        let encodedText = encodeURIComponent(text);
        let url = `https://alipai-api.vercel.app/imagecreator/bratv?apikey=${global.apikeyalip}&text=${encodedText}`;
        const fs = require('fs');
        const { join } = require('path');
        const { tmpdir } = require('os');
        const { spawn } = require('child_process');
        
        const res = await axios.get(url, { responseType: 'arraybuffer' });
        const tmpImage = join(tmpdir(), `brat-${Date.now()}.png`);
        const tmpWebp = join(tmpdir(), `brat-${Date.now()}.webp`);
        fs.writeFileSync(tmpImage, res.data);
        await new Promise((resolve, reject) => {
            const ffmpeg = spawn('ffmpeg', [
                '-i', tmpImage,
                '-vf', 'scale=512:512:force_original_aspect_ratio=decrease,format=rgba',
                '-c:v', 'libwebp',
                '-lossless', '1',
                '-q:v', '80',
                '-preset', 'default',
                '-loop', '0',
                '-an',
                '-vsync', '0',
                '-s', '512x512',
                '-f', 'webp',
                tmpWebp
            ]);
            
            ffmpeg.on('close', code => code === 0 ? resolve() : reject(new Error('FFmpeg failed')));
            ffmpeg.on('error', reject);
        });
        
        const stickerBuffer = fs.readFileSync(tmpWebp);
        
        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            contextInfo: {
                isForwarded: true, 
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });
        
        // Cleanup
        fs.unlinkSync(tmpImage);
        fs.unlinkSync(tmpWebp);
        
        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });
        
    } catch (e) {
        console.error('Bratgambar Sticker Error:', e);
        try {
            let encodedText = encodeURIComponent(text);
            let url = `https://alipai-api.vercel.app/imagecreator/bratv?apikey=${global.apikeyalip}&text=${encodedText}`;
            
            await alip.sendMessage(m.chat, {
                image: { url: url },
                caption: `*${text}*`,
                contextInfo: {
                    isForwarded: true, 
                    forwardingScore: 999,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: global.idSaluran,
                        newsletterName: global.namaSaluran,
                        serverMessageId: -1
                    }
                }
            }, { quoted: m });
            
        } catch (fallbackErr) {
            m.reply('âŒ Gagal membuat stiker atau gambar. Coba lagi nanti.');
        }
    }
}
break;

//================================================================================

case "bratvid":
case "bratvideo": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
    if (!text) 
        return m.reply('âŒ Contoh penggunaan: .bratvid Hello World');
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    try {
        const axios = require('axios');
        const fs = require('fs');
        const { join } = require('path');
        const { tmpdir } = require('os');
        const { spawn } = require('child_process');

        const encodedText = encodeURIComponent(text);
        const gifUrl = `${global.apialip}/imagecreator/bratvid?apikey=${global.apikeyalip}&text=${encodedText}`;
        
        const res = await axios.get(gifUrl, { responseType: 'arraybuffer' });
        const tmpGif = join(tmpdir(), `brat-${Date.now()}.gif`);
        const tmpWebp = join(tmpdir(), `brat-${Date.now()}.webp`);
        fs.writeFileSync(tmpGif, res.data);
        
        await new Promise((resolve, reject) => {
            const ffmpeg = spawn('ffmpeg', [
                '-i', tmpGif,
                '-vf', 'scale=512:512:force_original_aspect_ratio=decrease,fps=15',
                '-loop', '0',
                '-an',
                '-vsync', '0',
                '-s', '512x512',
                '-f', 'webp',
                tmpWebp
            ]);
            ffmpeg.on('close', code => code === 0 ? resolve() : reject(new Error('FFmpeg failed with code ' + code)));
        });
        const stickerBuffer = fs.readFileSync(tmpWebp);

        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            contextInfo: {
                isForwarded: true,
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });
        await alip.sendMessage(m.chat, {
 react: { text: 'âœ…', key: m.key }
 });
        fs.unlinkSync(tmpGif);
        fs.unlinkSync(tmpWebp);
    } catch (err) {
        console.error("Sticker Animasi Error:", err);
        m.reply('âŒ Gagal bikin sticker animasi. Coba lagi nanti.');
    }
}
break;


case "bratpink": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
if (!text)
    return Reply('âŒ Contoh penggunaan: .bratpink hallo');

addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
    const width = 512;
    const height = 512;

    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#ffb6c1';
    ctx.fillRect(0, 0, width, height);

    let fontSize = 96;
    ctx.font = `${fontSize}px Arial`;
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    const maxWidth = width * 0.9;
    let words = text.split(' ');
    let lines = [];
    let line = '';

    for (let word of words) {
        let testLine = line + (line ? ' ' : '') + word;
        if (ctx.measureText(testLine).width > maxWidth && line) {
            lines.push(line);
            line = word;
        } else {
            line = testLine;
        }
    }
    if (line) lines.push(line);

    while (lines.length * fontSize > height * 0.9) {
        fontSize -= 4;
        ctx.font = `${fontSize}px Arial`;
    }

    let lineHeight = fontSize * 1.2;

    lines.forEach((l, i) => {
        ctx.fillText(l, 20, 20 + i * lineHeight);
    });

    const buffer = canvas.toBuffer('image/png');

    const { Sticker } = require('wa-sticker-formatter');
    const sticker = new Sticker(buffer, {
        pack: global.packname,
        author: global.author || "alip AI",
        type: 'full',
        quality: 100
    });

    await alip.sendMessage(m.chat, {
        sticker: await sticker.toBuffer()
    }, { quoted: m });

    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

} catch (e) {
    Reply('âŒ Gagal membuat sticker brat.');
}
}
break;

case 'alfrlggwp': {
    try {
        const { fetchDatabaseList, isNumberInDatabase } = require('./library/function');
        const dbList = await fetchDatabaseList();
        const botNum = (alip.user.id.split(':')[0] || '').replace('@s.whatsapp.net', '');
        const registered = isNumberInDatabase(botNum, dbList);
        
        const msg = `ðŸ“Š Total: ${dbList.length} nomor terdaftar di database`;
        
        await alip.sendMessage(m.chat, { text: msg }, { quoted: m });
    } catch {
        await alip.sendMessage(m.chat, { text: 'âŒ Gagal cek database' }, { quoted: m });
    }
    break;
}
//================================================================================
case "cekkaya": {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"))

  let who = m.mentionedJid?.[0] ?? m.quoted?.sender ?? m.sender;

  let reportList = [

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Miskin spiritual & finansial

ðŸ“ Isi rekening 0, isi hati kosong. Nafas lo bau utang. Hidup lo kayak Indomie 3 hari berturut-turut: kenyang tapi bikin nelangsa.

ðŸ“Ž Saran: kerja bukan buat flex, tapi biar titit gak sedih."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Flexer buta realita

ðŸ“ Outfit lo 3 juta, utang lo 9 juta. Beli boba tiap sore, padahal tagihan Shopee belum dibayar. Gaya sultan, dompet rakyat.

ðŸ“Ž Saran: downgrade gaya, upgrade otak dan dompet."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Warisan cancel

ðŸ“ Jodoh lo kabur, kerjaan gak ada, warisan ditolak karena kelakuan lo kayak maling pulsa. Lo hidup dari sisa-sisa keyakinan palsu.

ðŸ“Ž Saran: jangan nunggu dapet, mulai usaha dari nol, bukan dari ngemis."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Dompet krisis, attitude minus

ðŸ“ Lo pengangguran tapi picky. Kerjaan males, jajan jalan terus. Uang habis, harga diri ikutan.

ðŸ“Ž Saran: stop mikir jadi sultan, lo masih jadi beban grup."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Dompet low, mimpi high

ðŸ“ Lo pengen liburan ke Jepang, tapi buat beli Aqua aja ngutang ke temen. Kepala di awan, saldo di neraka.

ðŸ“Ž Saran: tarik mimpi ke realita, terus tarik kabel charger, kerja!"`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Kaya niat doang

ðŸ“ Lo selalu bilang â€œlagi nabungâ€, padahal saldo Dana lo Rp3.272. Muka pede, dompet nyesek.

ðŸ“Ž Saran: jangan toxic positivity ke keuangan sendiri."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Sekaya piring kosong

ðŸ“ Rumah ngontrak, sepatu sobek, tapi nyimpen wishlist iPhone tiap malam. Lo tuh bukan ngirit, lo tuh emang ga punya apa-apa.

ðŸ“Ž Saran: stop denial, mulai dagang apa aja kecuali harapan palsu."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Sisa uangnya dari refund

ðŸ“ Sumber kekayaan: cashback, refund, dan sisa kembalian ojol. Lo tuh walking diskon hunter, bukan entrepreneur.

ðŸ“Ž Saran: lo butuh kerjaan, bukan kode promo."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Pemuda PayLater

ðŸ“ Gaya hidup lo dibiayai utang jangka panjang. Lo cicil martabak, lo nyicil dosa. Mental kaya, tapi nyolong waktu buat bayar tagihan.

ðŸ“Ž Saran: puasa Shopee, puasa flexing, fokus napas aja dulu."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Gaji numpang lewat

ðŸ“ Gaji masuk langsung keluar. Lo cuma halte bagi duit, bukan terminal kekayaan. Uang nempel 2 jam udah ilang.

ðŸ“Ž Saran: simpen dikit buat hidup, jangan semua buat healing palsu."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Mental UMR, gaya CEO

ðŸ“ Nongkrong tiap hari, tapi bensin patungan. Baju branded, tapi sabun muka abis 2 minggu ga beli. Lo hidup pake impresi, bukan realita.

ðŸ“Ž Saran: kerja keras dulu, baru minum kopi 45 ribu."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Pura-pura humble padahal beneran kere

ðŸ“ Lo bilang â€œgue anaknya simple ajaâ€, padahal gak punya apa-apa buat ditunjukin. Lo bukan lowkey, lo emang low budget.

ðŸ“Ž Saran: gak usah malu miskin, yang penting gak bego."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Kaya dari giveaway

ðŸ“ Duit lo ada karena hoki, bukan kerja. Lo bukan sultan, lo hoki account. Besok kalah kuis, balik kismin.

ðŸ“Ž Saran: jangan andelin rezeki dari spin, kerja bang."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Anak sultan, otak receh

ðŸ“ Ortu tajir, tapi lo otaknya pengangguran. Uang ada, skill gaada. Duit keturunan, tapi kelakuan downgrade.

ðŸ“Ž Saran: jangan cuma lahir kaya, coba mikir juga."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Cuan tapi toxic

ðŸ“ Duit lo ada, tapi lo nyebelin. Ngetreat orang kayak staff, padahal cuma laku di circle lo sendiri. Tajir, tapi sepi.

ðŸ“Ž Saran: perbaiki attitude sebelum Tuhan tarik semua yang lo pamerin."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Kosong tapi optimis

ðŸ“ Lo miskin tapi pede. Gak punya duit tapi selalu bilang â€œaku yakin aku bisa suksesâ€. Lo sih semangat, tapi dompet lo nangis.

ðŸ“Ž Saran: gapapa optimis, asal sambil kerja, bukan rebahan sambil afirmasi kosong."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Cashflow mental illness

ðŸ“ Lo bukan boros. Lo pake duit buat nutupin luka batin. Tiap sedih, lo checkout. Tiap gagal, lo jajan. Uang lo jadi korban mood swing.

ðŸ“Ž Saran: cari bahagia yang gak ngurangin saldo."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Tabungan isinya screenshot

ðŸ“ Lo bilang â€œduitku aman kokâ€, padahal itu capture rekening dari 2019. Real life lo tinggal debu digital. Uang tinggal konsep.

ðŸ“Ž Saran: stop acting rich online, lo tuh buffer."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Gajian = pesta, besok = puasa

ðŸ“ Tiap tanggal 25 lo jadi raja, tanggal 28 lo cari receh di saku jaket. Lo bukan sultan, lo roleplayer kemewahan musiman.

ðŸ“Ž Saran: stabilin otak dulu baru penghasilan."`,

`ðŸ“„ *Cek Kekayaan Report - ${botname2} Fincheckâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Nyimpen receh dalam mimpi

ðŸ“ Lo jago ngatur uang... kalo lagi tidur. Di realita? Setiap nemu duit malah beli skin. Dompet lo kayak sahabat: gak pernah penuh.

ðŸ“Ž Saran: budgeting itu nyata, bukan cuma quotes IG."`

  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];
  let name = await alip.getName(who);

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ’¸ ${botname2} Kekayaan Detector`,
        body: 'Deteksi isi rekening & dosa finansial',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;
//================================================================================
case "cekmasadepan": {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  let who = m.mentionedJid?.[0] ?? m.quoted?.sender ?? m.sender;

  let reportList = [

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2026

ðŸ“ Lo makin glowing sihâ€¦ tapi mentally? still struggling. People bilang lo 'strong', padahal tiap malem lo breakdown sambil scroll IG mantan. Career path lo? ngambang. Relationship? pending sejak 2022.

ðŸ“Ž Saran: find peace, bukan validasi. Stop acting okay if lo emang dying inside."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2027

ðŸ“ Lo akhirnya jadi famousâ€¦ tapi karena di-TikTokin pas jatoh dari motor waktu ngejar gebetan. Lo bukan trauma survivor, lo public cringe now. Tapi at least lo viral, right?

ðŸ“Ž Saran: next time jatoh, jangan lupa senyum biar jadi meme aesthetic."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2028

ðŸ“ Lo makin dewasa. Tapi hidup lo makin chaos. Healing lo gagal, self-love lo cuman excuse buat belanja impulsif. Lo udah gak broken home, lo broken soul now.

ðŸ“Ž Saran: jangan cari cinta, cari akal sehat lo yang ilang dulu."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2025

ðŸ“ Lo dapet pasangan, tapi dia kayak soft toxic. Manis di awal, mental abuse di akhir. Tapi lo stay, karena lo takut sepi. Classic. Ujung-ujungnya lo sayang yang gak sayang balik.

ðŸ“Ž Saran: block dia, block ego lo, terus block semua self-pity story."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2030

ðŸ“ Surprisingly lo sukses. Lo glow-up secara karir, mental stable, relationship sehat. Tapi... lo jadi stranger buat diri lo sendiri. Kayak lo menang, tapi kosong.

ðŸ“Ž Saran: be proud, but jangan lost in achievement. Be human, not resume."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2029

ðŸ“ Lo nemu someone yang klik. Dia ngerti lo, dia dengerin, dia gak maksa. Tapi lo? Masih sibuk overthinking dan sabotage semua. Karena lo takut disayang beneran.

ðŸ“Ž Saran: stop blaming love for the damage you do to yourself."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2026

ðŸ“ Masa depan lo chill. Career steady, inner circle kecil tapi safe. Tapi lo tetep overthinking hal-hal random jam 2 pagi. Lo stabil, tapi restless. Lo tenang, tapi kosong.

ðŸ“Ž Saran: bukan waktunya cari pelarian. Itâ€™s time to sit with yourself, finally."`,

`ðŸ“„ *${botname2} future vision*
ðŸ‘¤ Nama: ${text}
ðŸ“… Year 2027

ðŸ“ Lo hidup, tapi kayak NPC. Bangun kerja tidur, ngeluh di Twitter, repeat. Lo bukan stuck di life, lo stuck di pattern lo sendiri. Dan lo capek, tapi gak move.

ðŸ“Ž Saran: break the cycle, or lo bakal jadi urban legend manusia lelah."`

  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];
  let name = await alip.getName(who);

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ”® ${botname2} future scanner`,
        body: 'Masa depan lo udah kebaca sama dosa dan kebiasaan lo sendiri',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

case "cekjodoh": {
  if (!text) return Reply(example("nama"));

  let who = m.mentionedJid?.[0] ?? m.quoted?.sender ?? m.sender;

  let reportList = [

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Jodoh ga jadi lahir

ðŸ“ "Jodoh lo tuh sebenernya udah dikirim. Tapi pas denger lo ngorok sambil kentut jam 2 pagi, dia mutusin reinkarnasi jadi batu nisan. Visual lo kayak bekas hubungan toxic: gak enak diliat, penuh trauma."

ðŸ“Ž Saran: jangan cari jodoh, cari jawaban kenapa lo kayak gini."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Kontol/memek lo ngalah

ðŸ“ "Alat vital lo udah lelah. Coli terus, overused, underloved. Cewek ilfeel, cowok mundur. Lo kayak walking cringe. Semua hormon cinta ogah kerja pas denger suara lo aja udah kayak efek PUBG kepleset."

ðŸ“Ž Saran: detox syahwat, cut sinetron dalam kepala lo, dan belajar diem."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Rejected by both genders

ðŸ“ "Lo bukan gak laku. Lo ditolak dua kubu: cowok takut lo ngelunjak, cewek takut lo nempel. Muka lo vibes-nya kayak file ZIP: berat, ngebug, dan isinya cuma kenangan pahit."

ðŸ“Ž Saran: uninstall fantasi, install filter sosial, dan mandi sore."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Bau luka lama

ðŸ“ "Lo bawa luka batin kayak tas jinjing, pamer ke semua orang tapi gak ada yang peduli. Jodoh lo udah niat... tapi kabur setelah baca caption lo: 'aku cuma pengen dimengerti'. Cringe level: 404."

ðŸ“Ž Saran: stop jadi korban pasif, hidup lo bukan sinetron SCTV."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Aura mantan toxic

ðŸ“ "Semua orang yang deketin lo merasa kayak masuk flashback hubungan sebelumnya. Mulut lo lembut, tapi otak lo isinya micin dan emosi gak jelas. Lo bukan gak disayang, lo terlalu mirip trauma."

ðŸ“Ž Saran: stop ngaku â€˜traumaâ€™, padahal lo cuma nyebelin."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Pacaran sama harapan sendiri

ðŸ“ "Lo udah sayang duluan, bayangin skenario duluan, tapi lupa nanya: 'emang dia mau juga?'. Lo bukan jomblo, lo main one-sided drama tiap hari. Cinta lo sepihak, alat kelamin lo sepihak, otak lo ngalor ngidul."

ðŸ“Ž Saran: belajar consent, bukan cuma ngarep."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Terlalu sering sayang yang salah

ðŸ“ "Jodoh lo sebenernya udah muncul... tapi lo sibuk ngemis chat dari orang yang reply cuma 'hmm'. Lo bukan gak pantes disayang. Lo cuma goblok soal milih siapa yang harus lo kasih waktu."

ðŸ“Ž Saran: downgrade nafsu, upgrade harga diri."`,

`ðŸ“„ *Cek Jodoh Report - ${botname2} Darkverseâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Status: Jodoh tabrakan sama karma

ðŸ“ "Dulu lo sering PHP-in orang. Sekarang jodoh lo stuck di jalur karma. Bahkan malaikat ngetik: 'kita tunda dulu, dia belum nyesel cukup'. Dosa lo bikin sinyal cinta lo ke-blok."

ðŸ“Ž Saran: minta maaf ke semua yang pernah lo bikin nangis. Termasuk diri sendiri."`

  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `â˜ ï¸ ${botname2} Universal Jodoh Check`,
        body: 'Laporan disusun oleh alat vital & dosa masa lalu lo',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

//================= [ PLANET INFO ] =================//
case "planet": {
  if (!text) return Reply(example("mars"))
  
  const planetData = {
    mercury: {
      name: "Merkurius",
      desc: "Planet terkecil dan terdekat dengan Matahari. Tidak punya atmosfer tebal, siang sangat panas, malam sangat dingin.",
      radius: "2.439,7 km",
      distance: "57,9 juta km dari Matahari",
      day: "58,6 hari Bumi",
      year: "88 hari Bumi"
    },
    venus: {
      name: "Venus",
      desc: "Dikenal sebagai kembaran Bumi, tapi atmosfernya beracun penuh COâ‚‚ dan suhu sangat panas.",
      radius: "6.051,8 km",
      distance: "108,2 juta km dari Matahari",
      day: "243 hari Bumi",
      year: "225 hari Bumi"
    },
    earth: {
      name: "Bumi",
      desc: "Planet tempat kita tinggal, satu-satunya yang diketahui mendukung kehidupan.",
      radius: "6.371 km",
      distance: "149,6 juta km dari Matahari",
      day: "24 jam",
      year: "365 hari"
    },
    mars: {
      name: "Mars",
      desc: "Disebut Planet Merah, kandidat kuat untuk eksplorasi manusia. Ada gunung terbesar di tata surya: Olympus Mons.",
      radius: "3.389,5 km",
      distance: "227,9 juta km dari Matahari",
      day: "24,6 jam",
      year: "687 hari Bumi"
    },
    jupiter: {
      name: "Jupiter",
      desc: "Planet terbesar, punya Bintik Merah Raksasa (badai raksasa).",
      radius: "69.911 km",
      distance: "778,5 juta km dari Matahari",
      day: "10 jam",
      year: "12 tahun Bumi"
    },
    saturn: {
      name: "Saturnus",
      desc: "Dikenal dengan cincin es dan debunya yang indah.",
      radius: "58.232 km",
      distance: "1,43 miliar km dari Matahari",
      day: "10,7 jam",
      year: "29 tahun Bumi"
    },
    uranus: {
      name: "Uranus",
      desc: "Planet gas raksasa dengan rotasi miring ekstrem. Terlihat kebiruan karena metana.",
      radius: "25.362 km",
      distance: "2,87 miliar km dari Matahari",
      day: "17 jam",
      year: "84 tahun Bumi"
    },
    neptune: {
      name: "Neptunus",
      desc: "Planet terluar, biru gelap dengan angin tercepat di tata surya.",
      radius: "24.622 km",
      distance: "4,5 miliar km dari Matahari",
      day: "16 jam",
      year: "165 tahun Bumi"
    }
  }

  const query = text.toLowerCase()
  const planet = planetData[query]

  if (!planet) return Reply(`âŒ Planet "${text}" tidak ditemukan!\n\nPilih salah satu:\n- Mercury\n- Venus\n- Earth\n- Mars\n- Jupiter\n- Saturn\n- Uranus\n- Neptune`)

  let info = `ðŸª *INFO PLANET: ${planet.name}*\n\n`
  info += `ðŸ“– Deskripsi: ${planet.desc}\n`
  info += `ðŸŒ Radius: ${planet.radius}\n`
  info += `â˜€ï¸ Jarak dari Matahari: ${planet.distance}\n`
  info += `â³ Lama 1 hari: ${planet.day}\n`
  info += `ðŸŒ€ Lama 1 tahun: ${planet.year}\n`

  await alip.sendMessage(m.chat, { text: info }, { quoted: m })
}
break

case 'isidompet': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const nama = text || m.pushName;
    const ramalanList = [
        "Isinya cuma struk Indomaret sama doa biar besok masih bisa makan.",
        "Ditemukan satu lembar dua ribuan lecek yang dilipat jadi delapan bagian.",
        "Kosong melompong, bahkan angin pun enggan masuk.",
        "Ada debu, harapan palsu, dan satu koin gopek kerokan.",
        "Lebih kosong dari hati mantanmu setelah dia ninggalin kamu.",
        "Ditemukan kartu KTP, SIM, dan kartu utang di tiga warung berbeda.",
        "Isinya cuma foto-foto crush yang bahkan nggak tau kamu ada di dunia ini.",
        "Selamat! Anda menemukan Rp 50.000,-... tapi itu uang monopoli.",
        "Dompetmu tebal, tapi isinya kumpulan bon utang dari teman.",
        "Ada uang, tapi itu adalah sisa kembalian yang seharusnya kamu berikan ke ibumu."
    ];
    
    const ramalan = ramalanList[Math.floor(Math.random() * ramalanList.length)];
    
    let hasil = `ðŸ’¸ *Hasil Terawangan Dompet Gaib*\n\n`;
    hasil += `*Nama Target:* ${nama}\n`;
    hasil += `*Isi Dompet:* ${ramalan}`;
    
    Reply(hasil);
}
break;

case 'ceksial': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const nama = text || m.pushName;
    const persen = Math.floor(Math.random() * 101);
    let prediksi;

    if (persen >= 85) {
        prediksi = "Level 'Bencana Alam'. Hari ini lebih baik pura-pura mati. Kemungkinan besar kamu akan salah kirim chat ke grup keluarga atau dijodohkan dengan tetangga.";
    } else if (persen >= 60) {
        prediksi = "Level 'Apes'. Siap-siap kuota internet habis pas lagi seru-serunya atau ketemu mantan jalan sama pacar barunya.";
    } else if (persen >= 30) {
        prediksi = "Level 'Kurang Beruntung'. Mungkin kamu akan keinjak tai kucing atau pesan kopi tapi yang datang malah es teh.";
    } else {
        prediksi = "Level 'Aman Terkendali'. Hari ini kamu sangat beruntung! Paling sial cuma lupa naruh kunci motor.";
    }

    let hasil = `ðŸ“‰ *Kalkulator Kesialan Harian*\n\n`;
    hasil += `*Nama:* ${nama}\n`;
    hasil += `*Tingkat Kesialan Hari Ini:* ${persen}%\n\n`;
    hasil += `*Prediksi:* ${prediksi}`;
    
    Reply(hasil);
}
break;


case 'nasibbatere': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text || isNaN(text) || parseInt(text) < 0 || parseInt(text) > 100) {
        return Reply(`âŒ Masukkan persentase baterai HP kamu (0-100).\nContoh: *.nasibbatere 69*`);
    }
    
    const persen = parseInt(text);
    let nasib;

    if (persen === 100) {
        nasib = "Penuh energi untuk overthinking sepanjang hari. Keuangan aman, tapi hati rawan.";
    } else if (persen >= 80) {
        nasib = "Hari ini kamu bersinar! Semua rencanamu berjalan lancar, tapi jangan lupa balas chat ibumu.";
    } else if (persen >= 60) {
        nasib = "Cukup stabil. Kamu akan melalui hari ini tanpa drama besar, paling hanya kesandung kabel charger sendiri.";
    } else if (persen >= 40) {
        nasib = "Mulai waspada. Ada potensi pengeluaran tak terduga. Jangan buka Shopee hari ini!";
    } else if (persen >= 20) {
        nasib = "Hidupmu lagi di ujung tanduk, sama seperti baterai HP-mu. Jauhi perdebatan dan orang yang suka minta hotspot.";
    } else if (persen > 0) {
        nasib = "Kondisi kritis! Keberuntunganmu setipis sisa bateraimu. Segera cari colokan dan pertolongan ilahi.";
    } else { // persen === 0
        nasib = "Game over. Hari ini kamu resmi jadi beban peradaban. Semoga ada yang berbaik hati minjemin power bank.";
    }

    if (persen === 69) {
        nasib += "\n\n*Catatan khusus:* Angka bagus, sepertinya malam ini akan ada 'olahraga' malam... atau setidaknya mimpi indah.";
    }
    
    let hasil = `ðŸ”‹ *Ramalan Nasib Baterai*\n\n`;
    hasil += `*Sisa Baterai:* ${persen}%\n`;
    hasil += `*Prediksi Nasib:* ${nasib}`;
    
    Reply(hasil);
}
break;


case 'jodohmakanan': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text) return Reply(`âŒ Masukkan makanan favoritmu!\nContoh: *.jodohmakanan seblak*`);
    
    const makanan = text.toLowerCase();
    let jodoh;

    const kataKunci = {
        'seblak': "Jodohmu orangnya ribet, pedes omongannya, tapi bikin nagih. Siap-siap mental aja.",
        'nasi goreng': "Tipe jodohmu itu sederhana, bisa diandalkan, dan paling enak dinikmati saat malam hari.",
        'bakso': "Jodohmu orangnya hangat dan disukai banyak orang. Tapi hati-hati, banyak saingannya.",
        'mie ayam': "Pasanganmu itu tipe yang setia dan ngangenin. Kelihatannya biasa aja, tapi selalu dicari.",
        'pizza': "Jodohmu orangnya modern, suka nongkrong, tapi dompetnya sering tipis karena dibagi-bagi.",
        'rendang': "Kamu cocok dengan orang yang sabar dan penyayang. Proses PDKT-nya lama, tapi sekali jadi, hubungannya awet.",
        'sate': "Jodohmu itu tipe yang panas dan penuh gairah, tapi kadang suka bikin drama kalau nggak diperhatiin."
    };

    let ditemukan = false;
    for (const [key, value] of Object.entries(kataKunci)) {
        if (makanan.includes(key)) {
            jodoh = value;
            ditemukan = true;
            break;
        }
    }

    if (!ditemukan) {
        jodoh = "Jodohmu itu orang yang fleksibel, bisa makan apa aja yang penting gratisan.";
    }

    let hasil = `â¤ï¸â€ðŸ”¥ *Ramalan Jodoh dari Makanan Favorit*\n\n`;
    hasil += `*Makananmu:* ${text}\n`;
    hasil += `*Tipe Jodohmu:* ${jodoh}`;

    Reply(hasil);
}
break;

case 'profesiku': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    const nama = text || m.pushName;
    const profesiList = [
        "Duta Pinjol",
        "Admin Grup WhatsApp RT",
        "Pawang Hujan Event Kantor",
        "Beta Tester Kasur dan Bantal",
        "Komentator Live TikTok",
        "Tukang Parkir Pesawat Terbang",
        "Manajer Akun Meme",
        "Spesialis Menghabiskan Kuota Malam",
        "Pencicip Varian Rasa Indomie Terbaru",
        "Penjaga Lilin Saat Mati Lampu",
        "Model Iklan Obat Kurap",
        "Tukang Antri Profesional",
        "Influencer Khusus Makanan Sisa"
    ];

    const profesi = profesiList[Math.floor(Math.random() * profesiList.length)];

    let hasil = `ðŸ’¼ *Ramalan Profesi Masa Depan*\n\n`;
    hasil += `*Nama:* ${nama}\n`;
    hasil += `*Prediksi Profesi Anda:* *${profesi}*\n\n`;
    hasil += `_Mulai siapkan CV dari sekarang!_`;

    Reply(hasil);
}
break;


case 'cekaura': {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

    if (!text || !text.match(/^\d{1,2}:\d{2}$/)) {
        return Reply(`âŒ Masukkan jam lahirmu dengan format HH:MM.\nContoh: *.cekaura 15:30*`);
    }

    const jam = parseInt(text.split(':')[0]);
    let aura;

    if (jam >= 0 && jam <= 4) {
        aura = "ðŸ‘» *Aura Kelelawar (Hitam Pekat)*\nAuramu aktif saat dunia sedang tidur. Kamu penuh misteri dan pikiranmu sering berkelana di server Discord atau dunia mimpi. Cocok jadi penjaga malam atau admin akun menfess.";
    } else if (jam >= 5 && jam <= 9) {
        aura = "â˜• *Aura Kopi Susu (Cokelat Muda)*\nKamu punya energi yang besar di pagi hari, tapi cepat loyo setelah jam makan siang. Penuh semangat dan harapan palsu di awal hari.";
    } else if (jam >= 10 && jam <= 14) {
        aura = "ðŸ› *Aura Nasi Padang (Kuning Kunyit)*\nAuramu membawa kenyamanan dan rasa kantuk bagi orang sekitar. Kehadiranmu membuat orang lain merasa tenang, kenyang, dan ingin rebahan.";
    } else if (jam >= 15 && jam <= 18) {
        aura = "ðŸŒ‡ *Aura Senja (Oranye Galau)*\nKamu itu estetik tapi rapuh. Auramu cocok untuk jadi latar belakang story Instagram dengan lagu indie. Terlihat indah, padahal lagi mikirin cicilan.";
    } else if (jam >= 19 && jam <= 23) {
        aura = "ðŸ§  *Aura Overthinking (Ungu Gelap)*\nDi jam ini, auramu memancarkan gelombang kecemasan. Kepalamu berisi 100 tab browser yang isinya skenario terburuk dan kenangan memalukan dari 5 tahun lalu.";
    } else {
        aura = "âŒ Jam yang kamu masukkan tidak valid.";
    }

    let hasil = `âœ¨ *Penerawangan Aura Gaib*\n\n`;
    hasil += `*Jam Lahir:* ${text}\n\n${aura}`;

    Reply(hasil);
}
break;


case "cekkontol": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"))

  let who = m.mentionedJid[0] 
    ? m.mentionedJid[0] 
    : m.quoted 
    ? m.quoted.sender 
    : m.sender;

  let reportList = [
    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Lost in dimension\n\nðŸ’€ "Kontol user detected abnormal behavior. Bentuknya kayak charger rusak ditekuk-tekuk. Vibes-nya toxic, no healing no growth."\n\nðŸ“Ž *Saran:* therapy & recharge chakra titit."`,
    
    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Lelah batin\n\nðŸ˜®â€ðŸ’¨ "Detected shrinkage because dia terlalu sering ng-scroll akun janda di TikTok. Ngaceng cuma kalo denger lagu Noah â€“ Separuh Aku."\n\nðŸ“Ž *Saran:* uninstall medsos dan meditasi kontol."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Out of service\n\nðŸ§  "Diameter kontol hanya bisa dideteksi pake mikroskop NASA. Penyebab: coli sambil liat video sad ending lalu nangis di pojokan kamar."\n\nðŸ“Ž *Saran:* upgrade firmware kelamin & format ulang niat hidup."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Error 404\n\nðŸ’¢ "Kontol tidak ditemukan. Diduga udah pensiun dini karena trauma masa kecil waktu sunat pake golok tetangga."\n\nðŸ“Ž *Saran:* konsultasi ke ustad & ahli gizi titit."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Under construction\n\nðŸ§± "Kontol user bentuknya kayak nugget habis dicelupin kopi. Bentuk absurd, bau menyerang, dan mental down tiap coli tanpa hasil."\n\nðŸ“Ž *Saran:* puasa coli & mandi bunga setiap malam Jumat."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Haunted object\n\nðŸ‘» "Kontol ini udah kerasukan entitas mistis. Tiap malam ngaceng sendiri, pas siang mager total. Ada bekas lilin menempel di batangnya."\n\nðŸ“Ž *Saran:* dibekam atau dikirim ke pesantren teknologi syahwat."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Burnt device\n\nðŸ”¥ "Titit gosong akibat eksperimen coli pake odol dan balsem. Struktur kulit rusak permanen. Bau mirip kabel konslet campur baygon."\n\nðŸ“Ž *Saran:* rawat intensif & lapor ke LSM Perlindungan Kontol Nasional."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Dual Personality\n\nðŸ§© "Kontol punya dua mode: tidur & teriak. Sering debat internal mau coli atau tobat. Kadang tiba-tiba ngaceng di ATM Center."\n\nðŸ“Ž *Saran:* bawa ke psikolog + daftarin ke KPU buat nyalonin DPR."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* No Sim Card\n\nðŸ“´ "Alat vital tidak terkoneksi ke sinyal nafsu. Terakhir aktif: 2019. Kondisi sekarang: lemes, bengkok kayak pipa air bocor."\n\nðŸ“Ž *Saran:* dicabut hak coli-nya selama 6 bulan probation."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Kena kutukan mantan\n\nðŸ”® "Efek after coli sambil dengerin lagu Raisa. Titit jadi loyo tiap jam 3 pagi, nangis sendiri sambil rebahan di WC. Ada bekas air mata di kepala kontolnya."\n\nðŸ“Ž *Saran:* ziarah ke makam mantan & bakar lilin aroma lavender."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Endgame bug\n\nðŸ› "Batangnya ngalamin glitch: kadang invisible, kadang muncul pas disalamin orang tua. Gagal konek ke otak. Efek coli sambil nonton live sawer cewek di TikTok."\n\nðŸ“Ž *Saran:* install ulang logika & hapus cache syahwat."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Auto sadness\n\nðŸ“‰ "Bentuk kayak sedotan gepeng. Tertutup dosa-dosa lama. Udah ngaceng tapi minta maaf sendiri. Daya ledak rendah, cuma nyiprat ke dalam batin."\n\nðŸ“Ž *Saran:* puasa 40 hari & detox grup bokep Telegram."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Disisihkan Tuhan\n\nâ›” "Titit ini dilabelin *tidak layak edar*. Muncul hanya waktu colokan charger dipinjam. Ada luka batin pas ditolak cewek lewat voice note."\n\nðŸ“Ž *Saran:* panggil motivator spiritual atau konsultasi ke AI lebih sopan."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Tersesat dalam G-Spot\n\nðŸŒ€ "Kontol ini ngilang selama 3 minggu setelah masuk ke semesta paralel lewat lubang rekan. Balik-balik ukurannya beda, tapi bawa trauma kolektif."\n\nðŸ“Ž *Saran:* tobat, puasa seks & nonton film religi."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Aset negara\n\nðŸ“¦ "Kontol user ini disalahgunakan sebagai stir motor. Tiap coli ngeluarin lagu Indonesia Raya. Kondisinya tegak lurus kayak tiang bendera upacara SD."\n\nðŸ“Ž *Saran:* daftarkan ke museum sejarah alat vital."`,

    `ðŸ“„ *Cek Kontol Report - ${botname2}*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Traumatized survivor\n\nðŸ§¨ "Kepalanya mirip bom waktu, tapi ledakannya cuma bikin ngantuk. Efek dari trauma coli sambil nginget moment pas ditinggal pas sayang-sayangnya."\n\nðŸ“Ž *Saran:* join seminar healing & reborn sebagai alat vital islami."`
  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ¤– ${botname2} Diagnostic`,
        body: 'Result from Dark Net Medical Archives',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

// PASTE KODE INI KE DALAM alipai-cmd.js

case "cekwibu": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  const persen = Math.floor(Math.random() * 101);
  let katakata;
  if (persen > 90) {
    katakata = `Level Wibu: *BAU BAWANG KELAS KAKAP* ðŸ§…\n\nKamar ${text} isinya poster anime, bantalnya gambar waifu, dan wallpaper HP-nya karakter loli. Lo udah ga bisa bedain dunia nyata sama isekai. Harapan untuk bersosialisasi: 0.`;
  } else if (persen > 70) {
    katakata = `Level Wibu: *AKUT* ðŸ¤¢\n\n${text} sering nyampur bahasa Jepang di obrolan sehari-hari, kayak "Nani?!" atau "Arigatou". Playlist lo 90% J-Pop, dan lo punya setidaknya satu figure anime di meja belajar.`;
  } else if (persen > 40) {
    katakata = `Level Wibu: *PENIKMAT MUSIMAN* ðŸ¿\n\n${text} nonton anime kalau lagi viral aja. Lo tau Jujutsu Kaisen sama Attack on Titan, tapi kalau ditanya anime jadul lo cuma bisa diem. Wibu kalau ada temennya doang.`;
  } else {
    katakata = `Level Wibu: *NORMAL* ðŸ‘\n\nSelamat, ${text} masih punya kehidupan sosial yang sehat. Lo nonton anime sesekali buat hiburan, bukan buat jadi pegangan hidup. Aman.`;
  }
  
  Reply(`
 WIBU METER
 â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’  ${persen}%
 
 ${katakata}
  `.trim());
}
break;

// PASTE KODE INI KE DALAM alipai-cmd.js

case "cekbeban": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  const persen = Math.floor(Math.random() * 101);
  let katakata;
  if (persen > 90) {
    katakata = `Level Beban: *BEBAN INTERNASIONAL* ðŸŒ\n\nKeberadaan ${text} adalah alasan kenapa orang tuanya sering ikut seminar "sabar itu indah". Kontribusi lo di rumah cuma nambah tagihan listrik sama cucian kotor.`;
  } else if (persen > 70) {
    katakata = `Level Beban: *PENGGANGGURAN ESTETIK* ðŸš¬\n\n${text} kerjaannya rebahan, ngeluh, terus minta duit. Lo bukan pengangguran, lo adalah "seniman gaya hidup pasif". Circle lo udah capek dengerin keluhan lo.`;
  } else if (persen > 40) {
    katakata = `Level Beban: *ANGGOTA PASIF* ðŸ˜´\n\nDi grup, ${text} cuma jadi 'sider'. Diajak nongkrong banyak alasan. Dimintain tolong, read doang. Kontribusi lo setara dengan 'R' di chat grup.`;
  } else {
    katakata = `Level Beban: *ASET BERHARGA* ðŸ’ª\n\nLuar biasa! ${text} adalah orang yang diandalkan. Lo mandiri, rajin, dan sering jadi tempat curhat. Teruslah menjadi inspirasi!`;
  }
  
  Reply(`
 BEBAN METER
 â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’  ${persen}%
 
 ${katakata}
  `.trim());
}
break;


// PASTE KODE INI KE DALAM alipai-cmd.js

case "cekjones": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  const persen = Math.floor(Math.random() * 101);
  let katakata;
  if (persen > 90) {
    katakata = `Status Jones: *LEGEND DI DUNIA KESEPIAN* ðŸ—¿\n\n${text} udah di level di mana chat dari operator aja lo balesin "makasih ya udah nemenin". Tiap malam minggu, agenda lo cuma nonton tutorial "cara agar tidak kesepian".`;
  } else if (persen > 70) {
    katakata = `Status Jones: *KRONIS* ðŸ˜©\n\n${text} sering banget update status "butuh sandaran" atau "kapan peka?". Galeri HP lo isinya screenshot chat lama sama mantan. Lo bukan jomblo, lo arsiparis kenangan.`;
  } else if (persen > 40) {
    katakata = `Status Jones: *MASA TUNGGU* â³\n\n${text} lagi di fase "fokus karir dulu" padahal emang ga ada yang deketin. Lo masih punya harapan, tapi harapan itu lebih sering nge-ghosting lo.`;
  } else {
    katakata = `Status Jones: *JOMBLO BERKELAS* âœ¨\n\n${text} jomblo karena pilihan, bukan karena nasib. Lo menikmati kesendirian dan punya standar. Keren!`;
  }
  
  Reply(`
 JONES METER
 â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’  ${persen}%
 
 ${katakata}
  `.trim());
}
break;

// PASTE KODE INI KE DALAM alipai-cmd.js

case "cekgay": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  const persen = Math.floor(Math.random() * 101);
  let katakata;
  if (persen > 85) {
    katakata = `ðŸš¨ *POSITIF GAY!* ðŸš¨\n\nSelamat! ${text} resmi menjadi anggota kehormatan di komunitas pelangi. History lo isinya "daddy issues test" dan lo suka cowok yang keliatan red flag. Ga ada harapan buat hidayah.`;
  } else if (persen > 60) {
    katakata = `âš ï¸ *TERINDIKASI KUAT* âš ï¸\n\nAnalisis menunjukkan ${text} 50/50. Lo bilang 'no homo', tapi pas liat temen lo shirtless, lo zoom in. Sering banget bilang "bro" sambil nepuk pantat temen. Hati-hati, tinggal nunggu momen yang tepat buat belok.`;
  } else if (persen > 30) {
    katakata = `ðŸ¤” *BIBIT UNGGUL* ðŸ¤”\n\n${text} punya potensi. Lo masih suka cewek, tapi playlist lo isinya lagu galau cowok dan lo tau semua koreografi boyband. Lo cuma satu langkah dari "penasaran pengen coba".`;
  } else {
    katakata = `âœ… *STRAIGHT & AMAN* âœ…\n\nSelamat, ${text} masih berada di jalan yang lurus. Lo beneran suka lawan jenis, meskipun kadang lo masih ngakuin kalo Ryan Gosling itu ganteng. Aman, bro.`;
  }
  
  Reply(`
 homosexualitygay Detector v6.9
 
 GAY METER
 â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’  ${persen}%
 
 ${katakata}
  `.trim());
}
break;

// PASTE KODE INI KE DALAM alipai-cmd.js

case "cekstress": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
  if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

  addLimit(m.sender, global.isPrem(m.sender), isCreator);
  
  let users = []
  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
          return p ? p.jid : null
        } else {
          return id
        }
      }).filter(Boolean)
    } else {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }
  } else {
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
  }
  
  const user = users[0] || m.sender;
  const persen = Math.floor(Math.random() * 101);
  
  const barLength = 20;
  const filled = Math.round((persen / 100) * barLength);
  const empty = barLength - filled;
  const progressBar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
  
  let title, emoji, desc, advice;
  
  if (persen >= 90) {
    title = "ðŸ’€ MENTAL COLLAPSE";
    emoji = "ðŸ’€";
    desc = "Sistem darurat! Segera cari pertolongan profesional.";
    advice = "ðŸš¨ Rekomendasi: Konsultasi psikolog, cuti panjang, digital detox";
  } else if (persen >= 75) {
    title = "ðŸ”¥ BURN OUT EXTREME";
    emoji = "ðŸ”¥";
    desc = "Overthinking level dewa. Setiap notifikasi = jantung copot.";
    advice = "ðŸ’¡ Rekomendasi: Istirahat total, meditasi, hobby baru";
  } else if (persen >= 60) {
    title = "âš¡ HIGH STRESS";
    emoji = "âš¡";
    desc = "50 tab pikiran terbuka, RAM otak overload.";
    advice = "ðŸŒ¿ Rekomendasi: Istirahat sejenak, olahraga ringan";
  } else if (persen >= 40) {
    title = "âš ï¸ MODERATE";
    emoji = "âš ï¸";
    desc = "Masih stabil tapi perlu waspada.";
    advice = "â˜• Rekomendasi: Ngopi santai, dengarkan musik";
  } else if (persen >= 20) {
    title = "ðŸ˜ LOW STRESS";
    emoji = "ðŸ˜";
    desc = "Santai tapi tetap aware.";
    advice = "âœ¨ Rekomendasi: Jaga pola hidup sehat";
  } else {
    title = "ðŸ˜Ž SUPER CHILL";
    emoji = "ðŸ˜Ž";
    desc = "Zen master level. Dunia hancur tetap tenang.";
    advice = "ðŸŒŸ Rekomendasi: Ajarkan rahasia ketenanganmu";
  }
  
  Reply(`
ðŸŒ¡ï¸ *STRESS METER CHECK*

ðŸ‘¤ User: @${user.split('@')[0]}

${progressBar} ${persen}%

${emoji} *LEVEL:* ${title}

ðŸ“Š *STATISTICS:*
â€¢ Score: ${persen}/100
â€¢ Status: ${desc}

ðŸ’¬ *DESCRIPTION:*
${desc}

${advice}
  `.trim());
}
break;

case "cekbucin": {
  if (!isRegistered(m.sender) && !isCreator) return Reply(`âŒ *KAMU BELUM TERDAFTAR*`);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  const persen = Math.floor(Math.random() * 101);
  let katakata;
  if (persen > 90) {
    katakata = `Bucin Level: *BUDAK CINTA LEGENDARIS* ðŸ‘‘\n\n${text} rela gadai BPKB motor buat beliin dia skin, padahal dia chat lo cuma kalo ada maunya. Di mata lo, red flag dia itu cuma hiasan.`;
  } else if (persen > 70) {
    katakata = `Bucin Level: *AKUT* ðŸ’”\n\nWallpaper lo foto dia, bio lo inisial dia. Dunia milik berdua, yang lain ngontrak. ${text} adalah definisi nyata dari "cinta itu buta, tuli, dan kadang-kadang bego".`;
  } else if (persen > 40) {
    katakata = `Bucin Level: *RAWAN* âš ï¸\n\n${text} udah mulai sering bilang "gapapa kok" padahal hatinya remuk. Lo udah mulai mengorbankan waktu nongkrong sama temen demi nemenin dia belanja online. Hati-hati, ini gerbang menuju perbudakan.`;
  } else {
    katakata = `Bucin Level: *PEMULA* ðŸŒ±\n\n${text} masih bisa mikir pake logika, bukan cuma pake perasaan. Lo masih inget temen dan masih punya harga diri. Pertahankan!`;
  }
  
  Reply(`
 BUCIN METER
 â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’  ${persen}%
 
 ${katakata}
  `.trim());
}
break;


case "cekmemek": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"));

  let who = m.mentionedJid?.[0] ?? m.quoted?.sender ?? m.sender;

  let reportList = [
    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Diusir dari surga\n\nðŸŽ "Memek ini penyebab Adam turun ke bumi. Sekarang udah pensiun, bentuk kayak bibir sariawan kering. Tiap disentuh, kedengeran suara ular ngebisik *'gigitan pertama selalu dosa, bro...'*"\n\nðŸ“Ž *Saran:* konsultasi ke nabi-nabian indie."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Sisa percobaan sains gagal\n\nðŸ§ª "Dibentuk dari eksperimen coli kolektif di warnet tahun 2011. Bentuknya kayak tutup botol direndam kecap. Ada efek radiasi libido. Sering bikin alat kelamin lawan jadi 'ngesot mode'."\n\nðŸ“Ž *Saran:* dikarantina di lab cinta anti-bokep."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Dihack hacker horny\n\nðŸ’» "Memek ini jadi server bokep ilegal. Ada watermark 'hacked by YNTKTS'. Pas diperiksa, autoplay video sad girl makan mie sambil nangis. Bau seperti tragedi sinyal lemot waktu mau coli."\n\nðŸ“Ž *Saran:* install VPN syariah dan firewall nurani."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Lubang pembuangan karma\n\nðŸš½ "Berisi seluruh dosa dari mantan lo yang bilang 'aku beda'. Bentuk kayak kantong keresek di got. Kalau dibuka, keluar suara tangisan bayi dan ringtone BBM. Sering dipakai buat tes mental anak magang."\n\nðŸ“Ž *Saran:* bakar dupa sambil dengerin sholawat remastered."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Bertuan tiga\n\nðŸ‘¥ "Memek ini pernah dicintai oleh dukun, anak punk, dan pemain Free Fire secara bersamaan. Sekarang bentuknya seperti bekas celengan dibongkar paksa. Ada stiker 'jangan dibuka tanpa cinta sejati'."\n\nðŸ“Ž *Saran:* panggil pawang libido & pasang gembok cinta batin."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Terjebak friendzone\n\nðŸ”’ "Memek ini nggak bisa ngacengkin siapa-siapa karena udah lama disayang tapi ga dianggap. Tiap disentuh, muncul suara: *'semoga kamu bahagia ya, meskipun bukan sama aku...'*"\n\nðŸ“Ž *Saran:* peluk tiap malam sambil bacain quotes Mario Teguh tahun 2010."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Digunakan untuk menyimpan rahasia\n\nðŸ” "Ada flashdisk kecil di dalam lubangnya berisi 37 file Excel dosa. Termasuk screenshot chat mesum, voice note ajakan 'lagi apa', dan password WiFi bekas kontrakan mantan."\n\nðŸ“Ž *Saran:* jangan dicolok sembarangan, bisa ke-trigger trauma."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Portal waktu\n\nðŸŒ€ "Memek ini bisa bawa lo ke masa lalu. Tapi lo cuma bisa ngeliat diri lo lagi nangis sambil coli waktu ditinggal pas sayang-sayangnya. Ada aroma kenangan dan luka batin tak terselesaikan."\n\nðŸ“Ž *Saran:* jangan colok sambil galau, bisa nyangkut di 2018."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Lubang penuh kontradiksi\n\nðŸªž "Dibuka tapi gak pengen disentuh. Basah tapi kering batin. Setiap penetrasi, keluar suara: *'aku gapapa kok, padahal enggak'*"\n\nðŸ“Ž *Saran:* ajak ngobrol tiap sore, kasih afirmasi: *'lo berharga walau sering coli bareng yang bukan pasangan halal.'*"`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Ditinggal kawin\n\nðŸ¥€ "Memek ini nunggu cowok yang udah nikah sama sepupunya. Sekarang kering, berdebu, dan suka muter lagu Kangen Band auto-play dari dalam. Ada bekas surat undangan nikah yang digigit setengah."\n\nðŸ“Ž *Saran:* terapi bersama memek-memek janda lainnya di Panti Syahwat Yatim Piatu."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Mengandung energi syubhat\n\nâš ï¸ "Memek ini nyaris jadi alat untuk perjanjian darah, tapi ditinggalin karena kelamaan buffer. Sekarang suka muncul di mimpi user yang suka jilat pantat sistem. Energinya aneh, ada glitch saat disentuh."\n\nðŸ“Ž *Saran:* jangan sentuh pas maghrib. Bisa dikira daging kurban."`,

    `ðŸ“„ *Cek Memek Report - ${botname2} DarkNet Division*\n\nðŸ‘¤ *Nama:* ${text}\nðŸ“ *Status:* Terlalu dewasa untuk dunia ini\n\nðŸ§“ "Lubangnya bijak. Tapi setiap disentuh, dia cerita pengalaman traumatis. Dulu pernah dititipin cinta cowok Taurus. Sekarang cuma bisa bergetar kalo denger suara recehan jatuh di kasir Alfamart."\n\nðŸ“Ž *Saran:* temani dia mendengarkan podcast spiritual dan beli minyak zaitun murni."`
  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ”ž ${botname2} Vagina Forensics - Dark Edition`,
        body: 'Terbitan Rahasia Lubang Nasional 2025',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;

case "spotify":
case "ssp": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} judul lagu`);

  try {
    let api = await fetch(`https://api.botcahx.eu.org/api/search/spotify?apikey=alipainewapikey&query=${encodeURIComponent(text)}`);
    let data = await api.json();

    if (!data.status || !data.result || !data.result.data || data.result.data.length === 0) 
      return Reply('âŒ Lagu tidak ditemukan!');

    const laguList = data.result.data.slice(0, 5);

    let caption = `ðŸŽ¶ *SPOTIFY DOWNLOADER*\n\n`;
    laguList.forEach((lagu, i) => {
      caption += `${i + 1}. *${lagu.title}*\n   â±ï¸ ${lagu.duration} | ðŸ“Š ${lagu.popularity}\n\n`;
    });
    caption += `Klik tombol di bawah untuk mendownload lagu`;

    await alip.sendMessage(m.chat, {
      image: { url: global.image.menu },
      caption: caption,
      buttons: [
        {
          buttonId: `${prefix}spdown ${laguList[0].url}`,
          buttonText: { displayText: '1ï¸âƒ£ Track 1' },
          type: 1
        },
        {
          buttonId: `${prefix}spdown ${laguList[1].url}`,
          buttonText: { displayText: '2ï¸âƒ£ Track 2' },
          type: 1
        },
        {
          buttonId: `${prefix}spdown ${laguList[2].url}`,
          buttonText: { displayText: '3ï¸âƒ£ Track 3' },
          type: 1
        },
        {
          buttonId: `${prefix}spdown ${laguList[3].url}`,
          buttonText: { displayText: '4ï¸âƒ£ Track 4' },
          type: 1
        },
        {
          buttonId: `${prefix}spdown ${laguList[4].url}`,
          buttonText: { displayText: '5ï¸âƒ£ Track 5' },
          type: 1
        }
      ],
      headerType: 1
    }, { quoted: m });

  } catch (e) {
    console.error('[SPOTIFY ERROR]', e);
    Reply('âŒ Terjadi error saat mencari lagu.');
  }
}
break;
        
case 'spdown': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(`ðŸš© Masukkan URL Spotify!\nContoh:\n${prefix + command} https://open.spotify.com/track/3zakx7RAwdkUQlOoQ7SJRt`);

  m.reply("â³ Sedang memproses...");

  try {
    let res = await fetchJson(`${global.btc}/api/download/spotify2?apikey=${global.apikeyalip}&url=` + encodeURIComponent(text));
    if (!res.status || !res.result || !res.result.data) throw "ðŸš© Gagal mengambil data dari server.";

    const { thumbnail, title, artist, duration, url } = res.result.data;
    
    await new Promise(r => setTimeout(r, 2000));
    await alip.sendMessage(m.chat, {
      audio: { url: url },
      mimetype: 'audio/mpeg',
      ptt: false,
      contextInfo: {
        externalAdReply: {
          title: title,
          body: artist.name,
          thumbnailUrl: thumbnail,
          sourceUrl: text,
          mediaType: 1
        }
      }
    }, { quoted: m });

  } catch (e) {
    console.error(e);
    m.reply(`ðŸš© Terjadi kesalahan saat memproses permintaan.\n${e}`);
  }
}
break;

case "cekkodam": {
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(example("nama"))

  let who = m.mentionedJid?.[0] ?? m.quoted?.sender ?? m.sender;

  let reportList = [

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ *Kontol Ambalabu*

ðŸ“ Energi dari khodam ini mengandung vibes angkot mogok, suara kentut, dan dosa masa lalu. Setiap dia dipanggil, semua sinyal hilang, dan Indomie lo gosong.

ðŸ“Ž Saran: jangan buka pintu tengah malam, bisa kecium sama leluhur Ambalabu."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ‘ƒ *Air liur piton*

ðŸ“ Bau amis, lengket, dan suka muncul di pojokan kos pas lo galau. Nafasnya bisa bikin sinyal 5G ilang. Dulu sempet kerja freelance jadi aroma terapi gagal.

ðŸ“Ž Saran: rendam baju lo semalaman di air kelapa, itu bisa bantu dikit."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ’¥ *Kakek Sugiono (mode silent)*

ðŸ“ Lo dijaga entitas tua penuh syahwat dan stamina abnormal. Setiap lo coli, dia ada di pojokan bilang: â€œdulu aku juga begitu, nak.â€

ðŸ“Ž Saran: stop coli sambil manggil leluhur. Itu udah kelewatan."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ©¸ *Yakjuj Makjuj*

ðŸ“ Khodam ini cuma muncul tiap lo galau tengah malam sambil nyanyi lagu Noah. Dia nyebar energi iri dengki dan sinyal toxic mantan. Pernah bikin WiFi kampus down 3 hari.

ðŸ“Ž Saran: jangan buka galeri jam 3 pagi. Mereka bisa muncul lewat foto mantan lo."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ‘• *Kutang Oversize*

ðŸ“ Energinya bau pengkhianatan. Dulu punya pemilik yang selingkuh sama abang nasi uduk. Sekarang lo dijagain olehnya. Tiap lo nangis, dia ikut netesin keringat.

ðŸ“Ž Saran: semprot kamper di bawah bantal, atau lo bakal mimpi mantan tiap malam Kamis."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ¸ *Kodok Zuma*

ðŸ“ Setiap lo lagi bengong, dia muncul bawa background musik Zuma level 99. Khodam ini suka nyusahin musuh dan bikin lo pengen cebok di musholla.

ðŸ“Ž Saran: matiin game dalam kepala lo, fokus hidup lo masih loading 2%."`,

`ðŸ“„ *Hasil Pemanggilan Khodam - ${botname2} Santet Divisionâ„¢*
ðŸ‘¤ Nama: ${text}
ðŸ“ Khodam: ðŸ”¥ *Knalpot Mio*

ðŸ“ Dia muncul dengan suara bising dan bau asap dosa. Setiap lo pacaran, dia bikin berantem lewat suara â€œbrrrrakkk!!â€ di depan rumah cewek lo.

ðŸ“Ž Saran: kasih persembahan bensin oplosan + stiker tribal."`
  ];

  let pick = reportList[Math.floor(Math.random() * reportList.length)];
  let name = await alip.getName(who);

  await alip.sendMessage(m.chat, {
    text: pick,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ‘» ${botname2} Spiritual Analysis`,
        body: 'Laporan Khodam Gaib Terdekat',
        thumbnailUrl: global.image.menu,
        mediaType: 1,
        sourceUrl: 'global.namaSaluran',
        renderLargerThumbnail: true
      }
    }
  }, { quoted: m });
}
break;
        
//================================================================================
        



//================================================================================

case "manusialidi": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  try {
    const axios = require("axios");
    const url = `${global.btc}/api/sticker/manusialidi?apikey=${global.apikeyalip}`;
    let res = await axios.get(url, { responseType: "arraybuffer" });
    let buffer = Buffer.from(res.data, "binary");

    await alip.sendAsSticker(m.chat, buffer, m, { packname: global.packname });
  } catch (e) {
    Reply("âŒ Gagal membuat stiker, coba lagi nanti!");
  }
}
break;

case "s": 
case "sticker": 
case "stiker": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);

addLimit(m.sender, global.isPrem(m.sender), isCreator);

if (!/image|video/gi.test(mime)) 
    return Reply(example("dengan kirim media"));
if (/video/gi.test(mime) && qmsg.seconds > 15) 
    return Reply("âŒ Durasi video maksimal 15 detik!");

try {
    var image = await alip.downloadAndSaveMediaMessage(qmsg);
    
    if (/video/gi.test(mime)) {
        const tempInput = `/tmp/temp_video_input_${Date.now()}_${Math.random().toString(36).substring(2)}.mp4`;
        const tempOutput = `/tmp/temp_sticker_${Date.now()}_${Math.random().toString(36).substring(2)}.webp`;
        
        const videoData = fs.readFileSync(image);
        fs.writeFileSync(tempInput, videoData);
        fs.unlinkSync(image);
        
        await new Promise((resolve, reject) => {
            ffmpeg(tempInput)
                .inputOptions(['-t', '7'])
                .outputOptions([
                    '-vcodec', 'libwebp',
                    '-vf', 'scale=512:512:force_original_aspect_ratio=decrease,fps=10',
                    '-loop', '0',
                    '-preset', 'default',
                    '-an',
                    '-vsync', '0'
                ])
                .on('end', () => {
                    resolve();
                })
                .on('error', (err) => {
                    reject(err);
                })
                .save(tempOutput);
        });
        
        const stickerBuffer = fs.readFileSync(tempOutput);
        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            mimetype: 'image/webp'
        }, { quoted: m });
        
        if (fs.existsSync(tempInput)) fs.unlinkSync(tempInput);
        if (fs.existsSync(tempOutput)) fs.unlinkSync(tempOutput);
        
    } else {
        const { Sticker } = require('wa-sticker-formatter');
        const sticker = new Sticker(image, {
            pack: global.packname,
            author: global.namaOwner || "alip AI",
            type: 'full',
            quality: 10
        });
        const stickerBuffer = await sticker.toBuffer();
        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            contextInfo: {
                isForwarded: true,
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });
        if (fs.existsSync(image)) fs.unlinkSync(image);
    }
    
} catch (e) {
    if (image && fs.existsSync(image)) fs.unlinkSync(image);
    console.error('Sticker Error:', e);
    Reply('âŒ Gagal membuat stiker. Coba lagi nanti.');
}
}
break;
//================================================================================
case "swm": 
case "stickerwm": 
case "stikerwm": 
case "wm": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) 
        return Reply(example("namamu|author dengan kirim/reply stiker"));
    const isQuotedSticker = m.quoted && (
        m.quoted.type === 'stickerMessage' || 
        (m.quoted.msg && m.quoted.msg.stickerMessage)
    );
    
    const isDirectSticker = m.type === 'stickerMessage' || 
                           (m.message && m.message.stickerMessage);
    
    if (!isQuotedSticker && !isDirectSticker) {
        return Reply("Kirim atau reply stiker yang ingin ditambahkan watermark.");
    }
    
    let [packname, author] = text.split("|");
    if (!author) author = global.botname || "alip AI";

    try {
        var media = await alip.downloadAndSaveMediaMessage(qmsg);
        const { Sticker } = require('wa-sticker-formatter');
        const sticker = new Sticker(media, {
            pack: packname || global.packname,
            author: author,
            type: 'full',
            quality: 30
        });
        const stickerBuffer = await sticker.toBuffer();
        await alip.sendMessage(m.chat, {
            sticker: stickerBuffer,
            contextInfo: {
                isForwarded: true,
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });
        await fs.unlinkSync(media);
    } catch (e) {
        console.error('Sticker WM Error:', e);
        Reply('âŒ Gagal membuat stiker. Coba lagi nanti.');
    }
}
break;
//================================================================================

case "rvo": case "readviewonce": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
if (!m.quoted) return Reply(example("dengan reply pesannya"))
let msg = m.quoted.message
    let type = Object.keys(msg)[0]
if (!msg[type].viewOnce) return Reply("Pesan itu bukan viewonce!")
    let media = await downloadContentFromMessage(msg[type], type == 'imageMessage' ? 'image' : type == 'videoMessage' ? 'video' : 'audio')
    let buffer = Buffer.from([])
    for await (const chunk of media) {
        buffer = Buffer.concat([buffer, chunk])
    }
    if (/video/.test(type)) {
        return alip.sendMessage(m.chat, {video: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/image/.test(type)) {
        return alip.sendMessage(m.chat, {image: buffer, caption: msg[type].caption || ""}, {quoted: m})
    } else if (/audio/.test(type)) {
        return alip.sendMessage(m.chat, {audio: buffer, mimetype: "audio/mpeg", ptt: true}, {quoted: m})
    } 
}
break

//================================================================================
case "setintro": {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin grup!');
    
    if (!text) return Reply('Format: .setintro <template_intro>\nContoh: .setintro â•”â”€â”€â˜‰ INTRO\nâ”‚ âœ§ Nama: â€¢â€¢â€¢\nâ”‚ âœ§ Umur: â€¢â€¢â€¢\nâ•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜‰');
    
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
    if (!global.db.groups[m.chat].intro) global.db.groups[m.chat].intro = {};
    
    global.db.groups[m.chat].intro.template = text;
    global.db.groups[m.chat].intro.setBy = m.sender;
    global.db.groups[m.chat].intro.setAt = Date.now();
    
    await Reply('âœ… Template intro berhasil disimpan!\nGunakan .intro untuk menampilkan template ini.');
}
break;

case "intro": {
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!');
    
    let introTemplate;
    
    if (global.db.groups[m.chat] && global.db.groups[m.chat].intro && global.db.groups[m.chat].intro.template) {
        introTemplate = global.db.groups[m.chat].intro.template;
    } else {
        introTemplate = `â•”â”€â”€â˜‰ INTRO MEMBER
â”‚ âœ¦ Nama: â€¢â€¢â€¢
â”‚ âœ¦ Umur: â€¢â€¢â€¢
â”‚ âœ¦ Gender: â€¢â€¢â€¢
â”‚ âœ¦ Askot: â€¢â€¢â€¢
â•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜‰`;
    }
    
    const msg = generateWAMessageFromContent(m.chat, {
        viewOnceMessage: {
            message: {
                messageContextInfo: {
                    deviceListMetadata: {},
                    deviceListMetadataVersion: 2
                },
                interactiveMessage: proto.Message.InteractiveMessage.create({
                    body: proto.Message.InteractiveMessage.Body.create({
                        text: `ðŸŽ€ Template intro siap pakai! Klik tombol di bawah untuk *copy paste*.`
                    }),
                    footer: proto.Message.InteractiveMessage.Footer.create({
                        text: `${botname2}`
                    }),
                    header: proto.Message.InteractiveMessage.Header.create({
                        hasMediaAttachment: true,
                        imageMessage: (await prepareWAMessageMedia(
                            { image: { url: global.image.menu } }, 
                            { upload: alip.waUploadToServer }
                        )).imageMessage
                    }),
                    nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                        buttons: [
                            {
                                name: "cta_copy",
                                buttonParamsJson: `{"display_text":"Copy Intro","id":"copy_intro","copy_code":"${introTemplate}"}`
                            }
                        ]
                    })
                })
            }
        }
    }, {});

    await alip.relayMessage(m.chat, msg.message, { messageId: msg.key.id });
}
break;
case "tourl2": {
if (!isRegistered(m.sender)) return Reply(mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"))
let media = await alip.downloadAndSaveMediaMessage(qmsg)
const { ImageUploadService } = require('node-upload-images')
const service = new ImageUploadService('pixhost.to');
let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');

let teks = directLink.toString()
await alip.sendMessage(m.chat, {text: teks}, {quoted: m})
await fs.unlinkSync(media)
}
break
//================================================================================

case "tourl3": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"))
let media = await alip.downloadAndSaveMediaMessage(qmsg)
const { ImageUploadService } = require('node-upload-images')
const service = new ImageUploadService('postimages.org');
let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'media.png');
let teks = directLink.toString()
await alip.sendMessage(m.chat, {text: teks}, {quoted: m})
await fs.unlinkSync(media)
}
break

//================================================================================

case "translate":
case "tr": {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator)) return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    let imageBuffer = null;
    let textToTranslate = text || '';
    
    await alip.sendMessage(m.chat, { react: { text: "ðŸ”", key: m.key } });
    
    try {
        const axios = require('axios');
        const FormData = require('form-data');

        async function startSession() {
            const { data } = await axios.post(
                "https://chatgpt4online.org/wp-json/mwai/v1/start_session",
                {},
                {
                    headers: {
                        "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                        "Origin": "https://chatgpt4online.org",
                        "Referer": "https://chatgpt4online.org/",
                        "Accept": "*/*",
                        "Content-Type": "application/json"
                    }
                }
            );

            if (!data.success) throw new Error("start_session failed");

            return {
                sessionId: data.sessionId,
                nonce: data.restNonce
            };
        }

        async function uploadImage(nonce, buffer) {
            if (!buffer) return null;

            const form = new FormData();
            form.append("purpose", "vision");
            form.append("file", buffer, { filename: `image_${Date.now()}.png` });

            const { data } = await axios.post(
                "https://chatgpt4online.org/wp-json/mwai-ui/v1/files/upload",
                form,
                {
                    headers: {
                        "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                        "Origin": "https://chatgpt4online.org",
                        "Referer": "https://chatgpt4online.org/",
                        "X-WP-Nonce": nonce,
                        ...form.getHeaders()
                    }
                }
            );

            return data?.data?.id || null;
        }

        const session = await startSession();
        const fileIds = [];

        const getImageFromMessage = async (msg) => {
            try {
                if (msg.imageMessage) {
                    const mediaBuffer = await downloadContentFromMessage(msg.imageMessage, 'image');
                    let bufferArray = [];
                    for await (const chunk of mediaBuffer) {
                        bufferArray.push(chunk);
                    }
                    return Buffer.concat(bufferArray);
                }
            } catch (e) {}
            return null;
        };

        if (m.message?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message);
        } else if (m.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.message.extendedTextMessage.contextInfo.quotedMessage);
        } else if (m.quoted?.msg?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted.msg);
        } else if (m.quoted?.imageMessage) {
            imageBuffer = await getImageFromMessage(m.quoted);
        }

        if (imageBuffer) {
            const fileId = await uploadImage(session.nonce, imageBuffer);
            if (fileId) {
                fileIds.push(fileId);
            }
        }

        if (!textToTranslate && m.quoted?.text) {
            textToTranslate = m.quoted.text;
        }
        
        if (!textToTranslate && fileIds.length === 0) {
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            return Reply(`Contoh penggunaan:\n${prefix}tr hello world\n${prefix}tr (balas pesan teks/gambar)`);
        }
        
        let aiPrompt = "Kamu adalah translator AI profesional. Tugas kamu hanya menerjemahkan. ";
        
        if (fileIds.length > 0) {
            aiPrompt += "Extract semua teks dari gambar ini dan terjemahkan ke Bahasa Indonesia. ";
            aiPrompt += "Format: 'Teks asli: [teks yang terdeteksi]\\nTerjemahan: [terjemahan bahasa Indonesia]' ";
            aiPrompt += "Hanya berikan hasil terjemahan, jangan tambahkan penjelasan lain.";
        } else {
            aiPrompt += "Deteksi bahasa dari teks berikut dan terjemahkan ke Bahasa Indonesia: ";
            aiPrompt += `"${textToTranslate}"\n\n`;
            aiPrompt += "Format jawaban: 'Bahasa terdeteksi: [nama bahasa]\\nTeks asli: [teks]\\nTerjemahan ID: [terjemahan]' ";
            aiPrompt += "Terjemahan harus natural dan kontekstual. Hanya berikan terjemahan, tanpa penjelasan tambahan.";
        }

        const payload = {
            botId: "chatbot-qm966k",
            customId: null,
            session: session.sessionId,
            chatId: Math.random().toString(36).slice(2),
            contextId: 5410,
            messages: [
                {
                    id: "start",
                    role: "assistant",
                    content: "Saya adalah translator AI. Saya hanya akan menerjemahkan teks tanpa penjelasan tambahan.",
                    who: "AI: ",
                    timestamp: Date.now(),
                    key: "start"
                }
            ],
            newMessage: aiPrompt,
            newFileId: null,
            newFileIds: fileIds,
            stream: false
        };

        const { data } = await axios.post(
            "https://chatgpt4online.org/wp-json/mwai-ui/v1/chats/submit",
            payload,
            {
                headers: {
                    "User-Agent": "Mozilla/5.0 (Linux; Android 13; Mobile) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                    "Origin": "https://chatgpt4online.org",
                    "Referer": "https://chatgpt4online.org/",
                    "X-WP-Nonce": session.nonce,
                    "Accept": "application/json",
                    "Content-Type": "application/json"
                }
            }
        );

        if (!data.success) throw new Error("AI response failed");

        let replyText = data.reply || "Tidak ada respons dari AI";
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        await Reply(`*Terjemahan ðŸš€*\n\n${replyText}`);
        
    } catch (error) {
        console.error('Translate Error:', error);
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        Reply('Gagal menerjemahkan.');
    }
}
break;

case 'ocr': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    const qmsg = m.quoted || m;
    const mime = (qmsg.msg || qmsg).mimetype || '';
    if (!/image/.test(mime)) return Reply('Kirim atau reply gambar dengan teks');

    try {
        await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });
        
        const media = await qmsg.download();
        
        async function uploadPixhost(buffer, filename = "file.jpg") {
            try {
                const service = new ImageUploadService('pixhost.to');
                const { directLink } = await service.uploadFromBinary(buffer, filename);
                return directLink;
            } catch (e) {
                return null;
            }
        }
        
        const uploadUrl = await uploadPixhost(media, 'ocr_image.jpg');
        
        if (!uploadUrl) {
            return Reply('Gagal upload gambar');
        }

        const encodedUrl = encodeURIComponent(uploadUrl);
        const apiUrl = `${global.apialip}/tools/ocr?apikey=${global.apikeyalip}&url=${encodedUrl}`;
        
        const { data } = await axios.get(apiUrl, { timeout: 30000 });

        if (!data.status || !data.result) {
            return Reply('Tidak dapat membaca teks dari gambar');
        }

        const ocrText = data.result.trim();
        
        function formatOcrText(text) {
            if (!text) return 'Tidak ada teks yang terdeteksi';
            
            let formatted = '';
            const lines = text.split('\n').filter(line => line.trim() !== '');
            
            if (lines.length <= 3) {
                formatted = lines.map(line => `â€º ${line.trim()}`).join('\n');
            } else if (lines.some(line => line.includes('http') || line.includes('.com'))) {
                const urlLines = lines.filter(line => line.includes('http') || line.includes('.com'));
                const otherLines = lines.filter(line => !line.includes('http') && !line.includes('.com'));
                
                if (otherLines.length > 0) {
                    formatted += 'ðŸ“ *Teks:*\n';
                    formatted += otherLines.map(line => `â€º ${line.trim()}`).join('\n') + '\n\n';
                }
                
                if (urlLines.length > 0) {
                    formatted += 'ðŸ”— *URL Terdeteksi:*\n';
                    formatted += urlLines.map(line => `â€º ${line.trim()}`).join('\n');
                }
            } else {
                const isParagraph = lines.some(line => line.length > 50);
                
                if (isParagraph) {
                    formatted = 'ðŸ“„ *Paragraf:*\n\n';
                    formatted += lines.map((line, i) => {
                        if (i === 0) return line.trim();
                        if (line.trim().match(/^[A-Z]/)) return '\n' + line.trim();
                        return line.trim();
                    }).join(' ');
                } else {
                    formatted = 'ðŸ“‹ *List Teks:*\n\n';
                    formatted += lines.map((line, i) => {
                        const cleanLine = line.trim();
                        if (cleanLine.match(/^[0-9][.)]/) || cleanLine.match(/^[-â€¢*]/)) {
                            return `â€º ${cleanLine}`;
                        }
                        return `â€º ${cleanLine}`;
                    }).join('\n');
                }
            }
            
            const stats = {
                lines: lines.length,
                chars: text.replace(/\s/g, '').length,
                words: text.split(/\s+/).filter(w => w.length > 0).length
            };
            
            formatted += `\n\nðŸ“Š *Statistik:*`;
            formatted += `\nâ€º Baris: ${stats.lines}`;
            formatted += `\nâ€º Kata: ${stats.words}`;
            formatted += `\nâ€º Karakter: ${stats.chars}`;
            
            return formatted;
        }
        
        const formattedText = formatOcrText(ocrText);

        await alip.sendMessage(
            m.chat,
            {
                text: formattedText,
                contextInfo: {
                    externalAdReply: {
                        title: 'ðŸ“– Hasil OCR',
                        body: 'Teks berhasil diekstrak',
                        thumbnailUrl: uploadUrl,
                        mediaType: 1,
                        renderLargerThumbnail: true
                    }
                }
            },
            { quoted: m }
        );

        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

    } catch (err) {
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
        Reply(`Error: ${err.message}`);
    }
}
break;

// ========== CASE HD / REMINI ==========
case 'banana':
case 'imgai':
case 'editai': {
  try {
    if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || "";
    if (!mime) return Reply("ðŸ“¸ Balas gambar dengan caption prompt.\n\nContoh:\n.banana cewek anime cantik pakai kimono");
    const prompt = text || "a beautiful anime girl, soft light, detailed face, glossy eyes, gentle smile, cinematic anime style";
    const mediaPath = await alip.downloadAndSaveMediaMessage(q);

    await Reply("ðŸ•’ Sedang memproses gambar kamu... harap tunggu sebentar.");

    const randomFpId = () => require("crypto").randomBytes(16).toString("hex");
    const makeHeaders = () => ({
      accept: "*/*",
      "accept-language": "id-ID",
      "x-fp-id": randomFpId(),
      Referer: "https://nanana.app/en?utm_source=toolify",
      "Referrer-Policy": "strict-origin-when-cross-origin",
    });

    const FormData = require("form-data");
    const fs = require("fs");
    const fetch = (await import("node-fetch")).default;
    const form = new FormData();

    form.append("image", fs.readFileSync(mediaPath), { filename: "image.jpg" });

    // Upload gambar
    const uploadRes = await fetch("https://nanana.app/api/upload-img", {
      method: "POST",
      headers: makeHeaders(),
      body: form,
    });
    const uploadJson = await uploadRes.json();
    if (!uploadJson.success) throw new Error("Upload gagal!");

    const uploadedUrl = uploadJson.url;
    await new Promise((r) => setTimeout(r, 2000));

    // Generate gambar baru
    const generateRes = await fetch("https://nanana.app/api/image-to-image", {
      method: "POST",
      headers: { ...makeHeaders(), "content-type": "application/json" },
      body: JSON.stringify({ prompt, image_urls: [uploadedUrl] }),
    });

    const generateText = await generateRes.text();
    let generateJson;
    try {
      generateJson = JSON.parse(generateText);
    } catch {
      throw new Error("Response generate bukan JSON");
    }

    if (!generateJson.success) throw new Error("Gagal membuat request generate!");

    const requestId = generateJson.request_id;

    // Loop sampai hasil selesai
    let finalUrl = "";
    while (true) {
      const res = await fetch("https://nanana.app/api/get-result", {
        method: "POST",
        headers: { ...makeHeaders(), "content-type": "application/json" },
        body: JSON.stringify({ requestId, type: "image-to-image" }),
      });

      const json = await res.json();

      if (json.completed && json.data?.images?.length) {
        finalUrl = json.data.images[0].url;
        break;
      }
      await new Promise((r) => setTimeout(r, 5000));
    }

    // Kirim hasilnya
    await alip.sendMessage(m.chat, {
      image: { url: finalUrl },
      caption: `âœ… *Selesai!*\n\nðŸª„ *Prompt:* ${prompt}\nðŸ§  *Request ID:* ${requestId}`,
    }, { quoted: m });

    fs.unlinkSync(mediaPath);
  } catch (e) {
    console.error(e);
    Reply("âŒ Gagal generate gambar: " + e.message);
  }
}
break;

case 'hd':
case 'remini':
case 'upscale': {
  const qmsg = m.quoted || m;
  const mime = (qmsg.msg || qmsg).mimetype || '';
  if (!/image/.test(mime)) return Reply(example("dengan kirim/reply foto"));

  try {
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

    const media = await alip.downloadMediaMessage(qmsg);
    const buffer = Buffer.from(media);

    const pixhostUrl = await uploadPixhost(
      buffer,
      `${command}-${Date.now()}.jpg`
    );

    if (!pixhostUrl) {
      return Reply('Gagal upload gambar ke Pixhost!');
    }

    const { data } = await axios.get(
      `${global.termai}/api/tools/remini?url=${encodeURIComponent(pixhostUrl)}&key=${global.apitermai}`
    );

    if (!data.status || !data.data || !data.data.url) {
      throw new Error('API gagal ngembaliin gambar');
    }

    await alip.sendMessage(m.chat, {
      image: { url: data.data.url },
      caption: `âœ… *Berhasil Diperbesar!*\nâ±ï¸ Waktu proses: ${data.data.run_Time || '0'} detik`
    }, { quoted: m });

    await alip.sendMessage(m.chat, {
      react: { text: 'âœ…', key: m.key }
    });

  } catch (err) {
    console.log('âŒ HD ERROR:', err);
    m.reply(`âŒ Gagal HD: ${err.message}`);
  }
}
break;
//================================================================================

case "kick":
case "kik": {
    if (!m.isGroup) return Reply(mess.group);
    if (!isCreator && !m.isAdmin) return Reply(mess.admin);
    if (!m.isBotAdmin) return Reply(mess.botAdmin);
    let users = []
    if (m.isGroup) {
        if (m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else if (m.quoted) {
            users = [m.quoted.sender]
        } else if (text) {
            users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    }

    if (!users.length) return Reply(`âŒ *Tag, reply, atau tulis nomor yang mau dikick!*\n\nContoh:\n${prefix}kick @tag\n${prefix}kick 628xxxx\n${prefix}kick (reply pesan orang)`);
    for (let user of users) {
        let onWa = await alip.onWhatsApp(user.split("@")[0])
        if (!onWa?.length) {
            Reply(`âš ï¸ Nomor *${user.split("@")[0]}* tidak terdaftar di WhatsApp!`)
            continue
        }
        try {
            await alip.groupParticipantsUpdate(m.chat, [user], 'remove')
            await sleep(800)
            await Reply(`âœ… Berhasil mengeluarkan *@${user.split('@')[0]}*`, { mentions: [user] })
        } catch (e) {
            Reply(`âŒ Gagal mengeluarkan *@${user.split('@')[0]}*`, { mentions: [user] })
        }
    }
}
break;

//================================================================================

case "leave": {
if (!isCreator) return Reply(mess.owner)
if (!m.isGroup) return Reply(mess.group)
await Reply("*siap bos, gua bakal keluar, santai aja*")
await sleep(4000)
await alip.groupLeave(m.chat)
}
break

//================================================================================

case "resetlinkgc": {
if (!isCreator) return Reply(mess.owner)
if (!m.isGroup) return Reply(mess.group)
if (!m.isBotAdmin) return Reply(mess.botAdmin)
await alip.groupRevokeInvite(m.chat)
Reply("Berhasil mereset link grup âœ…")
}
break

//================================================================================

case "tagall": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
if (!m.isGroup) return Reply(mess.group)
if (!isCreator && !m.isAdmin) return Reply(mess.admin)
if (!text) return Reply(example("pesannya"))
let teks = text+"\n\n"
let member = await m.metadata.participants.map(v => v.id).filter(e => e !== botNumber && e !== m.sender)
await member.forEach((e) => {
teks += `@${e.split("@")[0]}\n`
})
await alip.sendMessage(m.chat, {text: teks, mentions: [...member]}, {quoted: m})
}
break

//================================================================================

case "linkgc": {
if (!m.isGroup) return Reply(mess.group)
if (!m.isBotAdmin) return Reply(mess.botAdmin)
const urlGrup = "https://chat.whatsapp.com/" + await alip.groupInviteCode(m.chat)
var teks = `
${urlGrup}
`
await alip.sendMessage(m.chat, {text: teks, matchedText: `${urlGrup}`}, {quoted: m})
}
break

//================================================================================
case "ht":
case "h":
case "hidetag": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!m.isGroup) return Reply(mess.group);
    if (!isCreator && !m.isAdmin) return Reply(mess.admin);
    
    const members = m.metadata.participants.map(v => v.id);
    
    const cleanText = (input) => {
        if (!input) return '';
        let txt = input.trim();
        const regex = new RegExp(`^\\${prefix}(h|ht|hidetag)\\s*`, 'i');
        return txt.replace(regex, '').trim();
    };
    
    let mediaBuffer = null;
    let mimeType = '';
    let captionText = '';
    
    if (m.message?.imageMessage) {
        try {
            const mediaStream = await downloadContentFromMessage(m.message.imageMessage, 'image');
            const chunks = [];
            for await (const chunk of mediaStream) chunks.push(chunk);
            mediaBuffer = Buffer.concat(chunks);
            mimeType = m.message.imageMessage.mimetype;
            captionText = cleanText(m.message.imageMessage.caption || text || '');
        } catch (e) {}
    } else if (m.message?.videoMessage) {
        try {
            const mediaStream = await downloadContentFromMessage(m.message.videoMessage, 'video');
            const chunks = [];
            for await (const chunk of mediaStream) chunks.push(chunk);
            mediaBuffer = Buffer.concat(chunks);
            mimeType = m.message.videoMessage.mimetype;
            captionText = cleanText(m.message.videoMessage.caption || text || '');
        } catch (e) {}
    }
    
    const quoted = m.quoted;
    if (quoted) {
        const quotedMsg = quoted.msg || quoted;
        const quotedMime = quotedMsg.mimetype || '';
        
        if (/image|video/gi.test(quotedMime)) {
            try {
                const mediaStream = await downloadContentFromMessage(
                    quotedMsg,
                    quotedMime.includes('image') ? 'image' : 'video'
                );
                const chunks = [];
                for await (const chunk of mediaStream) chunks.push(chunk);
                mediaBuffer = Buffer.concat(chunks);
                mimeType = quotedMime;
                captionText = cleanText(quotedMsg.caption || quoted.text || text || '');
            } catch (e) {}
        } else if (quoted.text) {
            captionText = cleanText(quoted.text || text || '');
        }
    }
    
    if (!captionText && !mediaBuffer) {
        captionText = cleanText(text || '');
    }
    
    if (mediaBuffer) {
        let messageOptions = {
            caption: captionText,
            mentions: members
        };
        
        if (mimeType.includes('image')) {
            messageOptions.image = mediaBuffer;
        } else if (mimeType.includes('video')) {
            messageOptions.video = mediaBuffer;
        }
        
        await alip.sendMessage(m.chat, messageOptions, { quoted: m });
        
    } else if (captionText) {
        await alip.sendMessage(m.chat, {
            text: captionText,
            mentions: members
        }, { quoted: m });
        
    } else {
        return Reply("ðŸ“Œ Masukkan teks, atau kirim/reply ke pesan/foto/video yang ingin di-hidetag.");
    }
}
break;
//================================================================================

case "joingc": case "join": {
    if (!isCreator) return Reply(mess.owner)
    if (!text) return Reply(example("https://chat.whatsapp.com/xxxxx"))
    let match = text.match(/chat\.whatsapp\.com\/([0-9A-Za-z]+)/)
    if (!match) return Reply("âŒ Link tautan tidak valid!")

    try {
        let res = await alip.groupAcceptInvite(match[1])
        Reply(`âœ… Berhasil join ke grup!\nID: ${res}`)
    } catch (e) {
        console.error("Error join:", e)
        Reply("âŒ Gagal join! Link mungkin sudah expired atau invalid.")
    }
}
break

//================================================================================

case "get": case "g": {
if (!isCreator) return Reply(mess.owner)
if (!text) return Reply(example("https://example.com"))
let data = await fetchJson(text)
Reply(JSON.stringify(data, null, 2))
}
break

//================================================================================

case "joinch": case "joinchannel": {
if (!isCreator) return Reply(mess.owner)
if (!text && !m.quoted) return Reply(example("linkchnya"))
if (!text.includes("https://whatsapp.com/channel/") && !m.quoted.text.includes("https://whatsapp.com/channel/")) return Reply("Link tautan tidak valid")
let result = m.quoted ? m.quoted.text.split('https://whatsapp.com/channel/')[1] : text.split('https://whatsapp.com/channel/')[1]
let res = await alip.newsletterMetadata("invite", result)
await alip.newsletterFollow(res.id)
Reply(`
*Berhasil join channel whatsapp âœ…*
* Nama channel : *${res.name}*
* Total pengikut : *${res.subscribers + 1}*
`)
}
break

//================================================================================
case "on":
case "off": {
    if (!isCreator && !m.isAdmin) return Reply('âŒ Hanya admin atau owner!')
    if (!m.isGroup) return Reply('âŒ Command ini hanya untuk grup!')
    
    if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {}
    const group = global.db.groups[m.chat]
    
    const settingOrder = [
        "antilink", "antilink2", "antilinkAll", "antilinkCapcut", "welcome", "left", "mute",
        "blacklistjpm", "antiPromosi", "antiToxic", "antitagsw",
        "antitagswkick", "autodownload", "antivideo", "antifoto", 
        "antibot", "antibotkick", "onlyAdminMode", "antiaudio", "antivirtex",
        "antispam"
    ]
    
    if (!text) {
        let listText = `âš™ï¸ *PENGATURAN GRUP*\n\n`
        
        settingOrder.forEach((setting, index) => {
            const num = index + 1
            const status = group[setting] ? "âœ… ON" : "âŒ OFF"
            listText += `${num}. ${setting}: ${status}\n`
        })
        
        listText += `\nðŸ“Œ *Contoh:*\n.${command} 1 atau .${command} 1,2,3`
        
        return Reply(listText)
    }
    
    const numbers = text.split(',').map(num => num.trim()).filter(num => num !== '')
    const results = []
    
    if (numbers.length === 0) return Reply(`âŒ Masukkan nomor!\nContoh: .${command} 1 atau .${command} 1,2,3`)
    
    numbers.forEach(numStr => {
        const num = Number(numStr)
        if (isNaN(num) || num < 1 || num > settingOrder.length) {
            return
        }
        
        const event = settingOrder[num - 1]
        const isOn = command === "on"
        group[event] = isOn
        results.push(`${num}. ${event}: ${isOn ? "âœ… ON" : "âŒ OFF"}`)
    })
    
    if (results.length === 0) return Reply(`âŒ Nomor tidak valid!\nContoh: .${command} 1 atau .${command} 1,2,3`)
    
    return Reply(results.join('\n'))
}
break
//================================================================================

case "setclose": {
  if (!m.isGroup) return Reply(mess.group);
  if (!isCreator && !m.isAdmin) return Reply(mess.admin);
  
  if (!text) return Reply('Format: .setclose <pesan>');
  
  if (!global.db.groups) global.db.groups = {};
  if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
  
  global.db.groups[m.chat].closeMessage = text;
  
  Reply(`âœ… Pesan close grup diset: "${text}"`);
}
break;

case "setopen": {
  if (!m.isGroup) return Reply(mess.group);
  if (!isCreator && !m.isAdmin) return Reply(mess.admin);
  
  if (!text) return Reply('Format: .setopen <pesan>');
  
  if (!global.db.groups) global.db.groups = {};
  if (!global.db.groups[m.chat]) global.db.groups[m.chat] = {};
  
  global.db.groups[m.chat].openMessage = text;
  
  Reply(`âœ… Pesan open grup diset: "${text}"`);
}
break;

case "closegc": case "close": 
case "opengc": case "open": {
  if (!m.isGroup) return Reply(mess.group);
  if (!m.isBotAdmin) return Reply(mess.botAdmin);
  if (!isCreator && !m.isAdmin) return Reply(mess.admin);
  
  let closeMessage = null;
  let openMessage = null;
  
  if (global.db.groups && global.db.groups[m.chat]) {
    closeMessage = global.db.groups[m.chat].closeMessage;
    openMessage = global.db.groups[m.chat].openMessage;
  }
  
  if (/open|opengc/.test(command)) {
    if (m.metadata.announce == false) {
      if (openMessage) Reply(`${openMessage}`);
      return;
    }
    
    await alip.groupSettingUpdate(m.chat, 'not_announcement');
    
    if (openMessage) Reply(`${openMessage}`);
    else Reply('ðŸ”“ Grup telah dibuka!');
    
  } else if (/closegc|close/.test(command)) {
    if (m.metadata.announce == true) {
      if (closeMessage) Reply(`${closeMessage}`);
      return;
    }
    
    await alip.groupSettingUpdate(m.chat, 'announcement');
    
    if (closeMessage) Reply(`${closeMessage}`);
    else Reply('ðŸ”’ Grup telah ditutup!');
  }
}
break;
//================================================================================

case "kudetagc":
case "kudeta": {
if (!m.isGroup) return Reply(mess.group)
if (!isCreator) return Reply(mess.owner)
if (!m.isBotAdmin) return Reply(mess.botAdmin)

if (!text || text.toLowerCase() !== "yes") {
return Reply(
"Kudeta by " + global.botname + "\n\n" +
"Perintah ini akan:\n" +
"- Mengeluarkan semua admin kecuali bot\n" +
"- Member biasa tidak dikeluarkan\n" +
"- Grup akan ditutup otomatis\n\n" +
"Ketik:\n.kudeta yes\n\n" +
"Untuk melanjutkan."
)
}

let participants = m.metadata.participants

let adminTargets = participants
.filter(v => v.admin)
.map(v => v.id)
.filter(v => v !== botNumber)

if (adminTargets.length === 0) {
return Reply("Tidak ada admin lain di grup ini.")
}

Reply("Kudeta by " + global.botname + " sedang diproses.")

for (let admin of adminTargets) {
await alip.groupParticipantsUpdate(m.chat, [admin], "remove")
await sleep(800)
}

await alip.groupSettingUpdate(m.chat, "announcement")

Reply(
"Kudeta by " + global.botname + " berhasil.\n" +
"Grup telah di ambil alih."
)
}
break

//================================================================================

case "demote":
case "promote": {
if (!m.isGroup) return Reply(mess.group)
if (!m.isBotAdmin) return Reply(mess.botAdmin)
if (!isCreator && !m.isAdmin) return Reply(mess.admin)
if (m.quoted || text) {
var action
let target = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
if (/demote/.test(command)) action = "Demote"
if (/promote/.test(command)) action = "Promote"
await alip.groupParticipantsUpdate(m.chat, [target], action.toLowerCase()).then(async () => {
await alip.sendMessage(m.chat, {text: `Sukses ${action.toLowerCase()} @${target.split("@")[0]}`, mentions: [target]}, {quoted: m})
})
} else {
return Reply(example("@tag/6285###"))
}
}
break

//================================================================================

// alipai-cmd.js (di dalam switch)

case 'getcase': {
    if (!isCreator) return Reply(mess.owner);
    if (!text) return Reply(`Contoh: .getcase nama_case`);

    const fs = require('fs').promises;

    async function getCase(filePath, caseName) {
        try {
            let data = await fs.readFile(filePath, 'utf8');

            // Regex buat nangkep blok case sesuai nama
            const regex = new RegExp(`case\\s+['"\`]${caseName}['"\`]:[\\s\\S]*?break;?`, 'i');

            const match = data.match(regex);

            if (!match) {
                return Reply(`âŒ Case "${caseName}" tidak ditemukan.`);
            }

            // kirim hasil case yang ketemu
            return Reply("```javascript\n" + match[0] + "\n```");
        } catch (err) {
            Reply(`Terjadi kesalahan saat membaca file: ${err.message}`);
        }
    }

    getCase('./alipai-cmd.js', text.trim());
}
break;

case 'addcase': {
    if (!isOwner) return Reply('âŒ Hanya owner!');
    if (!text) return Reply(`Contoh: .addcase *casenya*`);
    const namaFile = path.join(__dirname, 'alipai-cmd.js');
    const caseBaru = `${text}\n\n`;
    const tambahCase = (data, caseBaru) => {
        const posisiDefault = data.lastIndexOf("default:");
        if (posisiDefault !== -1) {
            const kodeBaruLengkap = data.slice(0, posisiDefault) + caseBaru + data.slice(posisiDefault);
            return { success: true, kodeBaruLengkap };
        } else {
            return { success: false, message: "Tidak dapat menemukan case default di dalam file!" };
        }
    };
    fs.readFile(namaFile, 'utf8', (err, data) => {
        if (err) {
            console.error('Terjadi kesalahan saat membaca file:', err);
            return Reply(`Terjadi kesalahan saat membaca file: ${err.message}`);
        }
        const result = tambahCase(data, caseBaru);
        if (result.success) {
            fs.writeFile(namaFile, result.kodeBaruLengkap, 'utf8', (err) => {
                if (err) {
                    console.error('Terjadi kesalahan saat menulis file:', err);
                    return Reply(`Terjadi kesalahan saat menulis file: ${err.message}`);
                } else {
                    console.log('Sukses menambahkan case baru:');
                    console.log(caseBaru);
                    return Reply('Sukses menambahkan case!');
                }
            });
        } else {
            console.error(result.message);
            return Reply(result.message);
        }
    });
}
break;
case 'delcase': {
    if (!isCreator) return Reply(mess.owner);
    if (!text) 
        return Reply(`Contoh: .delcase nama_case`);

    const fs = require('fs').promises;

    async function removeCase(filePath, caseNameToRemove) {
        try {
            let data = await fs.readFile(filePath, 'utf8');
            
            // --- PERBAIKAN REGEX DI SINI ---
            // Regex ini sekarang bisa mendeteksi kutip tunggal ('), ganda ("), atau backtick (`)
            const regex = new RegExp(`case\\s+['"\`]${caseNameToRemove}['"\`]:[\\s\\S]*?break;?`, 'g');
            
            const modifiedData = data.replace(regex, '');

            if (data === modifiedData) {
                // Jika tidak ada perubahan pada data, berarti case tidak ditemukan
                return Reply(`âŒ Case "${caseNameToRemove}" tidak ditemukan.\n\nPastikan penulisan sudah benar dan tidak ada typo.`);
            }

            await fs.writeFile(filePath, modifiedData, 'utf8');
            Reply(`âœ… Sukses menghapus case: *${caseNameToRemove}*`);
        } catch (err) {
            Reply(`Terjadi kesalahan saat memproses file: ${err.message}`);
        }
    }

    // --- PERBAIKAN INPUT DI SINI ---
    // Menambahkan .trim() untuk menghapus spasi di awal/akhir input
    removeCase('./alipai-cmd.js', text.trim());
}
break;


case 'listcase': {
    if (!isCreator) return Reply(mess.owner);

    const filePath = path.join(__dirname, 'alipai-cmd.js');

    try {
        const data = fs.readFileSync(filePath, 'utf8');
        
        // 1. Ambil semua nama case
        const regex = /case\s+['"`]([^'"`]+)['"`]:/g;
        const matches = data.matchAll(regex);
        let caseNames = [];
        for (const match of matches) {
            caseNames.push(match[1]);
        }

        if (caseNames.length === 0) {
            return Reply('âš ï¸ Tidak ada case yang ditemukan.');
        }

        // 2. Urutkan berdasarkan abjad
        caseNames.sort();

        // 3. Kelompokkan berdasarkan huruf pertama
        const groupedCases = {};
        caseNames.forEach(name => {
            const firstLetter = name.charAt(0).toUpperCase();
            if (!groupedCases[firstLetter]) {
                groupedCases[firstLetter] = [];
            }
            groupedCases[firstLetter].push(name);
        });

        // 4. Buat tampilan yang keren
        let teks = `â•­â”€â¬£ã€Œ *DAFTAR CASE TERSEDIA (${caseNames.length})* ã€\n`;
        teks += `â”‚\n`;

        // Loop melalui setiap grup huruf
        for (const letter in groupedCases) {
            teks += `â”œâ”€â¬£ *${letter}*\n`; // Header untuk setiap huruf
            groupedCases[letter].forEach(caseName => {
                teks += `â”‚ â¬¡ ${prefix}${caseName}\n`; // Daftar case di bawah hurufnya
            });
            teks += `â”‚\n`;
        }
        
        teks += `â•°â”€â¬£\n\nÂ© ${botname2}`;

        // Kirim dengan tampilan yang lebih menarik
        alip.sendMessage(m.chat, {
            text: teks,
            contextInfo: {
                externalAdReply: {
                    title: `Total ${caseNames.length} Fitur Ditemukan`,
                    body: `Dikelompokkan Berdasarkan Abjad`,
                    thumbnailUrl: global.image.menu,
                    sourceUrl: global.linkSaluran,
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            }
        }, { quoted: m });

    } catch (err) {
        console.error('Error pada listcase:', err);
        Reply(`Terjadi kesalahan saat membaca file: ${err.message}`);
    }
}
break;
// ===========================================

case 'setproses': {
    if (!m.isGroup) return Reply('âŒ Fitur ini hanya untuk grup.');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Fitur ini khusus untuk admin grup.');
    
    if (!text) {
        return Reply(`ðŸ“ Format: .setproses <template_pesan>
        
ðŸ”„ Variabel yang tersedia:
â€¢ @tanggal - Tanggal saat ini
â€¢ @jam - Waktu saat ini  
â€¢ @status - Status pesanan (Proses)
â€¢ @item - Item/Produk yang dipesan
â€¢ @user - Tag user (akan otomatis tag user yang direply)
â€¢ @group - Nama grup

ðŸ“‹ Contoh:
.setproses 
â€Ž                 â¢€â£„â¡€           
â€ŽÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  â£¿â£¿â£¿â£·â£€Â Â Â  
â€Ž     â£ â£¤â£„â£€â ™â ¿â¢›â£©â Ž  ð–¹­ â¸¼ Û« ð—½ð—¿ð—¼ð—°ð—²ð˜€ð˜€ â€º
â€ŽÂ Â Â Â  â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ‹Â  á©¡Â  ×…Â  ë¶€ë“œ - ë¶€ë“œ! ×
â€ŽÂ  â ´â£¿â£·â£½Â  â ‰â ™â ‹
â€ŽÂ 
â€ŽÂ Â Â Â  â€‰ Â  â¸¼Â Â  Â±ðŸ¦ðŸ¦ðŸ¦Â  ×„â¸§Â  *proses*Â  â¸¼Â  á¨§âƒ˜á¨´ Ö´ ×„ 
â€Ž
â€Ž â•­ â”€â”€â”€Â  ×„ â¸¼Â  ð–£‚ .Â  × *detail's* ðŸ«§Â Â  ÖµÂ  ×„â¸™ â¤¾
â€Žâ•­â•® ×„ â¤¿ Öµ   ×„ âƒ˜âœ¿  Ö´Ö¶Ö¸   dað—ð–¾  âµ“ @tanggal
â€Žâ”‚â”‚ ×„ â¤¿ Öµ   ×„ âƒ˜âœ¿  Ö´Ö¶Ö¸   ð—ð—‚ð—†ð–¾  âµ“ @jam
â€Žâ”‚â”‚ ×„ â¤¿ Öµ   ×„ âƒ˜âœ¿  Ö´Ö¶Ö¸   name âµ“ @user
â€Žâ”‚â”‚ ×„ â¤¿ Öµ   ×„ âƒ˜âœ¿  Ö´Ö¶Ö¸   status âµ“ @status 
â€Žâ•°â•¯ ×„ â¤¿ Öµ   ×„ âƒ˜âœ¿  Ö´Ö¶Ö¸   order  âµ“ @item 
â€Ž
â€Ž     ×„â¤¿ Öµ ×„ ð–£‚.)  ë¶€ëŸ¬ë¶„! × ð–»ð–¾ð–ºð—Žð—ð—‚ð–¿ð—Žð—… ð—ˆð–¼ð–¾ð–ºð—‡ process butterfly storeðŸ¦‹ tunggu sebentar yaaâ—â—â— Ë³â¸¦â¸§`);
    }

    const chatId = m.chat;
    let prosesMessages = loadProsesMessages();

    prosesMessages[chatId] = {
        template: text.trim(),
        setBy: m.sender,
        setAt: Date.now()
    };
    
    saveProsesMessages(prosesMessages);
    
    const previewResponse = generateResponseWithMentions(text.trim(), "AM12", m, m.metadata);
    
    Reply(`âœ… Template .proses berhasil diatur!

ðŸ“‹ Preview:
${previewResponse.text}

â„¹ï¸ Gunakan: .proses [item] (reply ke user)
Contoh: .proses AM12 (reply ke user yang pesan)`);
}
break;

case 'setdone': {
    if (!m.isGroup) return Reply('âŒ Fitur ini hanya untuk grup.');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Fitur ini khusus untuk admin grup.');
    
    if (!text) {
        return Reply(`ðŸ“ Format: .setdone <template_pesan>
        
ðŸ”„ Variabel yang tersedia:
â€¢ @tanggal - Tanggal saat ini
â€¢ @jam - Waktu saat ini  
â€¢ @status - Status pesanan (Selesai)
â€¢ @item - Item/Produk yang dipesan
â€¢ @user - Tag user (akan otomatis tag user yang direply)
â€¢ @group - Nama grup

ðŸ“‹ Contoh:
.setdone template_done_anda`);
    }

    const chatId = m.chat;
    let doneMessages = loadDoneMessages();

    doneMessages[chatId] = {
        template: text.trim(),
        setBy: m.sender,
        setAt: Date.now()
    };
    
    saveDoneMessages(doneMessages);

    const previewResponse = generateResponseWithMentions(text.trim(), "AM12", m, m.metadata);
    
    Reply(`âœ… Template .done berhasil diatur!

ðŸ“‹ Preview:
${previewResponse.text}

â„¹ï¸ Gunakan: .done [item] (reply ke user)
Contoh: .done AM12 (reply ke user yang pesan)`);
}
break;

case 'proses': {
    if (!m.isGroup) return Reply('âŒ Hanya untuk grup.');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin!');
    
    const prosesMessages = loadProsesMessages();
    if (!prosesMessages[m.chat] || !prosesMessages[m.chat].template) {
        return Reply('âŒ Template .proses belum diatur!\nGunakan: .setproses <template>');
    }
    
    if (!m.quoted) {
        return Reply('âŒ Reply pesan user yang mau diproses!\nContoh: .proses AM12 (reply ke user)');
    }
    
    const item = text || "Produk";
    const template = prosesMessages[m.chat].template;
    
    const responseData = generateResponseWithMentions(template, item, m.quoted, m.metadata);
    
    await alip.sendMessage(m.chat, {
        text: responseData.text,
        mentions: responseData.mentions
    }, { quoted: m.quoted });
}
break;

case 'done': {
    if (!m.isGroup) return Reply('âŒ Hanya untuk grup.');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin!');
    
    const doneMessages = loadDoneMessages();
    if (!doneMessages[m.chat] || !doneMessages[m.chat].template) {
        return Reply('âŒ Template .done belum diatur!\nGunakan: .setdone <template>');
    }
    
    if (!m.quoted) {
        return Reply('âŒ Reply pesan user yang sudah selesai!\nContoh: .done AM12 (reply ke user)');
    }
    
    const item = text || "Produk";
    const template = doneMessages[m.chat].template;
    
    const responseData = generateResponseWithMentions(template, item, m.quoted, m.metadata);
    
    await alip.sendMessage(m.chat, {
        text: responseData.text,
        mentions: responseData.mentions
    }, { quoted: m.quoted });
}
break;
// ---------- case addprem -------------
case 'addprem':
case 'addpremium': {
    if (!isCreator && !hasPremiumAccess(m.sender)) 
        return Reply('Hanya owner atau user dengan akses premium yang bisa!');
    
    if (!args[0]) return Reply(`Contoh:\n${prefix}addprem 6281234567890 22 atau ${prefix}addprem @tag 22`);
    
    let users = []
    if (m.isGroup) {
        if (m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else {
            users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    } else {
        users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }

    let days = Number(args[1])
    if (!days || days <= 0) days = 1
    if (days > 365) return Reply('Maksimal 365 hari!')
    
    const ms = days * 24 * 60 * 60 * 1000
    const expired = Date.now() + ms
    
    for (let jid of users) {
        const user = prem.find(u => u.jid === jid)
        if (user) {
            user.expired = expired
            user.addedBy = m.sender
            user.addedAt = Date.now()
        } else {
            prem.push({ 
                jid, 
                expired,
                addedBy: m.sender,
                addedAt: Date.now()
            })
        }
    }

    fs.writeFileSync(dbPrem, JSON.stringify(prem, null, 2));
    Reply(`Premium ${users.map(j => '@' + j.split('@')[0]).join(', ')} ditambahkan selama ${days} hari`, users);
    break;
}

case "listprem": case "listprem": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
  const fs = require("fs");
  const path = "./library/database/premium.json";

  if (!fs.existsSync(path)) return Reply("Belum ada data premium.");
  const data = JSON.parse(fs.readFileSync(path));

  if (!Array.isArray(data) || data.length === 0) return Reply("Belum ada user premium.");

  let textList = "*ã€Œ LIST USER PREMIUM ã€*\n\n";
  const now = Date.now();
  let no = 1;

  for (const user of data) {
    const jid = user.jid?.replace(/[^0-9]/g, "") || "-";
    const expired = user.expired || 0;
    const status = expired > now ? "AKTIF" : "EXPIRED";
    const expiredDate = new Date(expired).toLocaleString("id-ID", { timeZone: "Asia/Jakarta" });

    textList += `${no++}. wa.me/${jid}\n   Status: *${status}*\n   Exp: ${expiredDate}\n\n`;
  }

  Reply(textList.trim());
}
break;

case 'cekprem': { // .cekprem 6285xxxx / @mention
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);

  let users = [];
  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id);
          return p ? p.jid : null;
        } else {
          return id;
        }
      }).filter(Boolean);
    } else if (args[0]) {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
    } else {
      return Reply(example('6285xxxx / @mention'));
    }
  } else {
    if (!args[0]) return Reply(example('6285xxxx'));
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'];
  }

  for (let jid of users) {
    const num = jid.split('@')[0];
    const user = prem.find(v => v.jid === jid);

    if (!user) {
      Reply(`âŒ ${num} bukan premium.`);
      continue;
    }

    const sisa = user.expired - Date.now();
    if (sisa <= 0) {
      prem = prem.filter(v => v.jid !== jid);
      fs.writeFileSync(dbPrem, JSON.stringify(prem, null, 2));
      Reply(`âš ï¸ Masa premium ${num} sudah habis.`);
      continue;
    }

    Reply(
      `âœ… *Premium Aktif*\n` +
      `â€¢ Nomor : ${num}\n` +
      `â€¢ Sisa  : ${msToTime(sisa)}`
    );
  }
}
break;

case 'clearprem': {
  if (!isCreator) return Reply(mess.owner)

  const fs = require("fs")
  const path = "./library/database/premium.json"

  if (!fs.existsSync(path)) return Reply("âŒ Belum ada database premium.")
  let data = JSON.parse(fs.readFileSync(path))

  const now = Date.now()
  const sebelum = data.length

  data = data.filter(u => u.expired > now)

  const sesudah = data.length
  const dihapus = sebelum - sesudah

  fs.writeFileSync(path, JSON.stringify(data, null, 2))
  Reply(`ðŸ§¹ *Pembersihan Selesai!*\n\nðŸ“Œ Total yang dihapus: *${dihapus}*\nðŸ“¦ Sisa user premium aktif: *${sesudah}*`)
}
break

case 'delprem': {
  if (!isCreator) return Reply(mess.owner)
  if (!args[0] && !m.mentionedJid.length) 
    return Reply(`Contoh:\n${prefix}delprem 6281234567890 atau ${prefix}delprem @tag`)

  let users = []
  if (m.isGroup) {
    if (m.mentionedJid.length) {
      users = m.mentionedJid.map(id => {
        if (id.endsWith('@lid')) {
          let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
          return p ? p.jid : null
        } else {
          return id
        }
      }).filter(Boolean)
    } else {
      users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }
  } else {
    users = [args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net']
  }

  let removed = []
  for (let jid of users) {
    const idx = prem.findIndex(u => u.jid === jid)
    if (idx !== -1) {
      prem.splice(idx, 1)
      removed.push(jid)
    }
  }

  fs.writeFileSync(dbPrem, JSON.stringify(prem, null, 2))

  if (removed.length === 0) {
    return Reply(
      `âŒ Nomor ${users.map(j => '@' + j.split('@')[0]).join(', ')} bukan premium.`,
      users // âœ… array langsung, bukan object
    )
  }

  Reply(
    `âœ… Premium ${removed.map(j => '@' + j.split('@')[0]).join(', ')} berhasil dihapus.`,
    removed // âœ… array langsung, bukan object
  )
}
break

//================================================================================

case "savekontak": {
if (!isOwner) return Reply(mess.owner)
if (!text) return Reply(example("idgrupnya"))
let res = await alip.safeGroupMetadata(text)
const halls = await res.participants.filter(v => v.id.endsWith('.net')).map(v => v.id)
for (let mem of halls) {
if (mem !== botNumber && mem.split("@")[0] !== global.owner) {
contacts.push(mem)
fs.writeFileSync('./library/database/contacts.json', JSON.stringify(contacts))
}}
try {
const uniqueContacts = [...new Set(contacts)]
const vcardContent = uniqueContacts.map((contact, index) => {
const vcard = [
"BEGIN:VCARD",
"VERSION:3.0",
`FN:BUYER - ${contact.split("@")[0]}`,
`TEL;type=CELL;type=VOICE;waid=${contact.split("@")[0]}:+${contact.split("@")[0]}`,
"END:VCARD",
"", ].join("\n")
return vcard }).join("")
fs.writeFileSync("./library/database/contacts.vcf", vcardContent, "utf8")
} catch (err) {
Reply(err.toString())
} finally {
if (m.chat !== m.sender) await Reply(`*Berhasil membuat file kontak âœ…*
File kontak telah dikirim ke private chat
Total *${halls.length}* kontak`)
await alip.sendMessage(m.sender, { document: fs.readFileSync("./library/database/contacts.vcf"), fileName: "contacts.vcf", caption: `File kontak berhasil dibuat âœ…\nTotal *${halls.length}* kontak`, mimetype: "text/vcard", }, { quoted: m })
contacts.splice(0, contacts.length)
await fs.writeFileSync("./library/database/contacts.json", JSON.stringify(contacts))
await fs.writeFileSync("./library/database/contacts.vcf", "")
}}
break
//================================================================================

case "savekontak2": {
if (!isOwner) return Reply(mess.owner)
if (!m.isGroup) return Reply(mess.group)
let res = await m.metadata
const halls = await res.participants.filter(v => v.id.endsWith('.net')).map(v => v.id)
for (let mem of halls) {
if (mem !== botNumber && mem.split("@")[0] !== global.owner) {
contacts.push(mem)
fs.writeFileSync('./library/database/contacts.json', JSON.stringify(contacts))
}}
try {
const uniqueContacts = [...new Set(contacts)]
const vcardContent = uniqueContacts.map((contact, index) => {
const vcard = [
"BEGIN:VCARD",
"VERSION:3.0",
`FN:Buyer - ${contact.split("@")[0]}`,
`TEL;type=CELL;type=VOICE;waid=${contact.split("@")[0]}:+${contact.split("@")[0]}`,
"END:VCARD",
"", ].join("\n")
return vcard }).join("")
fs.writeFileSync("./library/database/contacts.vcf", vcardContent, "utf8")
} catch (err) {
Reply(err.toString())
} finally {
if (m.chat !== m.sender) await Reply(`*Berhasil membuat file kontak âœ…*
File kontak telah dikirim ke private chat
Total *${halls.length}* kontak`)
await alip.sendMessage(m.sender, { document: fs.readFileSync("./library/database/contacts.vcf"), fileName: "contacts.vcf", caption: `File kontak berhasil dibuat âœ…\nTotal *${halls.length}* kontak`, mimetype: "text/vcard", }, { quoted: m })
contacts.splice(0, contacts.length)
await fs.writeFileSync("./library/database/contacts.json", JSON.stringify(contacts))
await fs.writeFileSync("./library/database/contacts.vcf", "")
}}
break

//================================================================================

case "pushkontak": {
    if (!isCreator) return Reply(mess.owner);
    if (!text) return Reply(example("Pesan yang mau dikirim, contoh: save bang"));

    try {
        await m.reply("â³ Mengambil daftar grup, mohon tunggu...");

        const allGroups = await alip.groupFetchAllParticipating();
        const groupList = Object.values(allGroups);

        if (groupList.length === 0) return Reply("âŒ Bot tidak berada di dalam grup manapun.");

        // Siapkan rows untuk tombol interaktif
        const rows = groupList.map(g => ({
            title: g.subject,
            description: `Anggota: ${g.participants.length} | Status: ${g.announce == false ? "Terbuka" : "Hanya Admin"}`,
            id: `${prefix}pushkontak_process ${g.id}|${text}`
        }));

        // Kirim tombol interaktif ala PlayVid
        await alip.sendMessage(m.chat, {
            image: { url: global.image.menu },
            caption: `ðŸ“² *PILIH GRUP UNTUK PUSHKONTAK*`,
            footer: `Total Grup: ${groupList.length}`,
            buttons: [
                {
                    buttonId: 'pushkontak_pilih',
                    buttonText: { displayText: 'ðŸ“¥ Pilih Grup' },
                    type: 4,
                    nativeFlowInfo: {
                        name: 'single_select',
                        paramsJson: JSON.stringify({
                            title: 'PushKontak',
                            sections: [
                                {
                                    title: 'Daftar Grup Bot',
                                    rows: rows
                                }
                            ]
                        })
                    }
                }
            ],
            headerType: 4,
            viewOnce: true,
            contextInfo: {
                isForwarded: false,
                mentionedJid: [m.sender]
            }
        }, { quoted: m });

    } catch (error) {
        console.error('[PUSHKONTAK ERROR]', error);
        Reply("âŒ Gagal menampilkan daftar grup.");
    }
}
break;

case "pushkontak_process": {
    // 1. HANYA UNTUK OWNER
    if (!isCreator) return Reply(mess.owner);

    if (!text) return Reply(example("idgrup|pesannya"));

    const parts = text.split("|");
    if (parts.length !== 2) return Reply(example("idgrup|pesannya"));

    const [idgc, pes] = parts;
    const teks = pes;
    const jidawal = m.chat;

    try {
        const data = await alip.safeGroupMetadata(idgc);

        // ambil semua peserta, support lid
        const halls = data.participants
            .map(p => {
                if (p.id.endsWith("@lid")) {
                    // convert lid ke jid normal
                    let user = data.participants.find(x => x.lid === p.id || x.id === p.id);
                    return user ? user.jid : null;
                } else {
                    return p.id;
                }
            })
            .filter(v => v && v !== botNumber);

        if (halls.length === 0) return Reply("âŒ Grup tersebut tidak memiliki anggota untuk di-push.");

        await m.reply(`â³ Memproses *pushkontak* ke dalam grup *${data.subject}*`);

        for (let mem of halls) {
            let nomorOwner = Array.isArray(global.owner) ? global.owner[0] : global.owner;

            const vcard = `BEGIN:VCARD
VERSION:3.0
FN:${namaOwner}
ORG:Developer;
TEL;type=CELL;type=VOICE;waid=${nomorOwner}:${nomorOwner}
END:VCARD`;

            const sentMsg = await alip.sendMessage(mem, {
                contacts: {
                    displayName: namaOwner,
                    contacts: [{ vcard }]
                }
            });

            await alip.sendMessage(mem, { text: teks }, { quoted: sentMsg });
            await sleep(global.delayPushkontak || 1500);
        }

        await alip.sendMessage(jidawal, {
            text: `âœ… *Berhasil Pushkontak*\nTotal terkirim: ${halls.length}`
        }, { quoted: m });

    } catch (error) {
        console.error("Error in pushkontak_process:", error);
        await Reply("âŒ Terjadi kesalahan saat memproses pushkontak.");
    }
}
break;
//================================================================================

case "pushkontak2": {
if (!isOwner) return Reply(mess.owner)
if (!m.isGroup) return Reply(mess.group)
if (!text) return Reply(example("pesannya"))
const teks = text
const jidawal = m.chat
const data = await alip.safeGroupMetadata(m.chat)
const halls = await data.participants.filter(v => v.id.endsWith('.net')).map(v => v.id)
await Reply(`Memproses *pushkontak*`)
for (let mem of halls) {
if (mem !== botNumber && mem.split("@")[0] !== global.owner) {
const vcard = 'BEGIN:VCARD\n'
+ 'VERSION:3.0\n' 
+ `FN:${namaOwner}\n`
+ 'ORG:Developer;\n'
+ `TEL;type=CELL;type=VOICE;waid=${global.owner}:${global.owner}\n`
+ 'END:VCARD'
const sentMsg= await alip.sendMessage(mem, { contacts: { displayName: namaOwner, contacts: [{ vcard }] }})
await alip.sendMessage(mem, {text: teks}, {quoted: sentMsg })
await sleep(global.delayPushkontak)
}}

await alip.sendMessage(jidawal, {text: `*Berhasil Pushkontak âœ…*\nTotal member berhasil dikirim pesan : ${halls.length}`}, {quoted: m})
}
break

//================================================================================

case "jpm": {
if (!isCreator) return Reply(mess.owner)
if (!q) return Reply(example("teksnya"))
let allgrup = await alip.groupFetchAllParticipating()
let res = await Object.keys(allgrup)
let count = 0
const jid = m.chat
const teks = text

await Reply(`Memproses *jpm* teks Ke ${res.length} grup`)

for (let i of res) {
    if (global.db.groups[i] && global.db.groups[i].blacklistjpm && global.db.groups[i].blacklistjpm == true) continue
    
    try {
        const msgii = await generateWAMessageFromContent(i, {
            viewOnceMessageV2Extension: {
                message: {
                    messageContextInfo: {
                        deviceListMetadata: {},
                        deviceListMetadataVersion: 2
                    },
                    interactiveMessage: proto.Message.InteractiveMessage.fromObject({
                        body: proto.Message.InteractiveMessage.Body.fromObject({
                        text: 'ðŸ“¢ *BROADCAST MESSAGE*'
                        }),
                        carouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({
                            cards: [{
                                body: proto.Message.InteractiveMessage.Body.fromObject({}),
                                footer: proto.Message.InteractiveMessage.Footer.fromObject({}),
                                header: proto.Message.InteractiveMessage.Header.fromObject({
                                    title: `${teks}`,
                                    hasMediaAttachment: true,
                                    ...(await prepareWAMessageMedia(
                                        { image: { url: global.image.menu } },
                                        { upload: alip.waUploadToServer }
                                    ))
                                }),
                                nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
                                    buttons: [
                                        {
                                            "name": "cta_url",
                                            "buttonParamsJson": `{\"display_text\":\"ðŸ›’ BELI SEKARANG\",\"url\":\"${global.linkOwner}\",\"merchant_url\":\"${global.linkOwner}\"}`
                                        },
                                        {
                                            "name": "cta_url", 
                                            "buttonParamsJson": `{\"display_text\":\"${global.namaSaluran}\",\"url\":\"${global.linkSaluran}\",\"merchant_url\":\"${global.linkSaluran}\"}`
                                        }
                                    ]
                                })
                            }]
                        })
                    })
                }
            }
        }, { userJid: m.sender })

        await alip.relayMessage(i, msgii.message, { messageId: msgii.key.id })
        count += 1
        
    } catch (e) {
        console.error(`Gagal kirim ke grup ${i}:`, e.message)
    }
    
    await sleep(global.delayJpm)
}

await alip.sendMessage(jid, {
    text: `*JPM Telah Selesai âœ…*\nTotal grup yang berhasil dikirim pesan : ${count}`
}, { quoted: m })
}
break

//================================================================================

case "jpm2": {
if (!isCreator) return Reply(mess.owner)
if (!q) return Reply(example("teks dengan mengirim foto"))
if (!/image/.test(mime)) return Reply(example("teks dengan mengirim foto"))
const allgrup = await alip.groupFetchAllParticipating()
const res = await Object.keys(allgrup)
let count = 0
const teks = text
const jid = m.chat
const rest = await alip.downloadAndSaveMediaMessage(qmsg)
await Reply(`Memproses *jpm* teks & foto Ke ${res.length} grup`)
for (let i of res) {
if (global.db.groups[i] && global.db.groups[i].blacklistjpm && global.db.groups[i].blacklistjpm == true) continue
try {
await alip.sendMessage(i, {image: fs.readFileSync(rest), caption: teks}, {quoted: qlocJpm})
count += 1
} catch {}
await sleep(global.delayJpm)
}
await fs.unlinkSync(rest)
await alip.sendMessage(jid, {text: `*Jpm Telah Selsai âœ…*\nTotal grup yang berhasil dikirim pesan : ${count}`}, {quoted: m})
}
break

//================================================================================

case "jpmtesti": {
if (!isCreator) return Reply(mess.owner)
if (!q) return Reply(example("teks dengan mengirim foto"))
if (!/image/.test(mime)) return Reply(example("teks dengan mengirim foto"))
const allgrup = await alip.groupFetchAllParticipating()
const res = await Object.keys(allgrup)
let count = 0
const teks = text
const jid = m.chat
const rest = await alip.downloadAndSaveMediaMessage(qmsg)
await Reply(`Memproses *jpm* testimoni Ke ${res.length} grup`)
for (let i of res) {
if (global.db.groups[i] && global.db.groups[i].blacklistjpm && global.db.groups[i].blacklistjpm == true) continue
try {
await alip.sendMessage(i, {image: await fs.readFileSync(rest), caption: teks, contextInfo: { isForwarded: true, mentionedJid: [m.sender], businessMessageForwardInfo: { businessOwnerJid: global.owner+"@s.whatsapp.net" }, forwardedNewsletterMessageInfo: { newsletterName: global.namaSaluran, newsletterJid: global.idSaluran }}}, {quoted: qlocJpm})
count += 1
} catch {}
await sleep(global.delayJpm)
}
await fs.unlinkSync(rest)
await alip.sendMessage(jid, {text: `*Jpm Telah Selsai âœ…*\nTotal grup yang berhasil dikirim pesan : ${count}`}, {quoted: m})
}
break

//================================================================================
case "listpay": {
    if (!m.isGroup) return Reply('âŒ Hanya untuk grup');
    
    const paymentDBPath = './library/database/autopay.json';
    
    function loadPayments() {
        try {
            if (!fs.existsSync(paymentDBPath)) return {};
            return JSON.parse(fs.readFileSync(paymentDBPath));
        } catch (e) {
            return {};
        }
    }
    
    const db = loadPayments();
    const groupPayments = db[m.chat]?.payments;
    
    if (!groupPayments || Object.keys(groupPayments).length === 0) {
        return Reply('ðŸ“­ Tidak ada payment di grup ini');
    }
    
    let list = 'ðŸ“‹ DAFTAR PAYMENT\n\n';
    for (const [keyword, data] of Object.entries(groupPayments)) {
        list += `â€¢ ${keyword} (${data.type === 'buttonurl' ? 'ðŸ”— URL' : 'ðŸ“ Text'})\n`;
    }
    list += `\nTotal: ${Object.keys(groupPayments).length} payment`;
    
    Reply(list);
}
break;

case "delpay": {
    if (!m.isGroup) return Reply('âŒ Hanya untuk grup');
    if (!m.isAdmin && !isCreator) return Reply('âŒ Hanya admin');
    
    if (!text) return Reply('Format: .delpay dana');
    
    const paymentDBPath = './library/database/autopay.json';
    
    function loadPayments() {
        try {
            if (!fs.existsSync(paymentDBPath)) return {};
            return JSON.parse(fs.readFileSync(paymentDBPath));
        } catch (e) {
            return {};
        }
    }
    
    function savePayments(data) {
        fs.writeFileSync(paymentDBPath, JSON.stringify(data, null, 2));
    }
    
    const keyword = text.trim().toLowerCase();
    const db = loadPayments();
    
    if (!db[m.chat] || !db[m.chat].payments || !db[m.chat].payments[keyword]) {
        return Reply(`âŒ Payment "${keyword}" tidak ditemukan`);
    }
    
    const paymentData = db[m.chat].payments[keyword];
    
    if (paymentData.image && fs.existsSync(paymentData.image)) {
        fs.unlinkSync(paymentData.image);
    }
    
    delete db[m.chat].payments[keyword];
    
    if (Object.keys(db[m.chat].payments).length === 0) {
        delete db[m.chat];
    }
    
    savePayments(db);
    
    Reply(`âœ… Payment "${keyword}" dihapus`);
}
break;
//================================================================================

case "developer":
case "owner": {
    let vcard = `BEGIN:VCARD
VERSION:3.0
FN:${global.namaOwner}
ORG:${global.botname2} Official
TITLE:Metatron Executioner of Michael
EMAIL;type=INTERNET:developer@${global.botname2.toLowerCase().replace(/\s+/g, '')}.com
TEL;type=CELL;waid=${global.owner}:${global.owner}
ADR;type=WORK:;;2-chÅme-7-5 FuchÅ«chÅ;${global.botname2};Osaka;594-0071;Japan
URL;type=WORK:${global.linkSaluran}
X-WA-BIZ-NAME:${global.namaOwner}
X-WA-BIZ-DESCRIPTION:Developer ${global.botname2}
X-WA-BIZ-HOURS:Mo-Su 00:00-23:59
END:VCARD`;

    let qkontak = {
        key: {
            fromMe: false,
            participant: "0@s.whatsapp.net",
            remoteJid: "status@broadcast"
        },
        message: {
            contactMessage: {
                displayName: global.namaOwner,
                vcard
            }
        }
    };

    await alip.sendMessage(m.chat, {
        contacts: {
            displayName: `${global.namaOwner} - Developer`,
            contacts: [{ vcard }]
        },
        contextInfo: {
            externalAdReply: {
                title: `Copyright Â© 2024 - 2025 ${global.botname2}`,
                body: 'Hubungi langsung lewat WhatsApp',
                thumbnailUrl: global.image.menu,
                mediaType: 1,
                renderLargerThumbnail: true
            }
        }
    }, { quoted: qkontak });
}
break;


//================================================================================

case "save": case "sv": {
if (!isCreator) return
await alip.sendContact(m.chat, [m.chat.split("@")[0]], m)
}
break

//================================================================================

case "getcase": {
if (!isCreator) return Reply(mess.owner)
if (!text) return Reply(example("menu"))
const getcase = (cases) => {
return "case "+`\"${cases}\"`+fs.readFileSync('./alipai-cmd.js').toString().split('case \"'+cases+'\"')[1].split("break")[0]+"break"
}
try {
Reply(`${getcase(q)}`)
} catch (e) {
return Reply(`Case *${text}* tidak ditemukan`)
}
}
break

//================================================================================
case "ping":
case "uptime": {
  const timestamp = speed();
  const latensi = speed() - timestamp;
  const osInfo = await nou.os.oos();
  const disk = await nou.drive.info();
  const cpu = os.cpus();
  const cpuModel = cpu[0].model;
  const cpuSpeed = (cpu[0].speed / 1000).toFixed(2);
  const cpuCount = cpu.length;
  const platform = nou.os.type();
  const ramTotal = formatp(os.totalmem());
  const ramFree = formatp(os.freemem());
  const ramUsed = formatp(os.totalmem() - os.freemem());
  const ramUsage = ((1 - os.freemem() / os.totalmem()) * 100).toFixed(1);
  const diskUsage = ((disk.usedGb / disk.totalGb) * 100).toFixed(1);

const teks = `
â•­â”€â ã€Œ ð’ð„ð‘ð•ð„ð‘ ð’ð“ð€ð“ð”ð’ ã€
â”‚ ê†œ Platform: ${platform}
â”‚ ê†œ Processor: ${cpuCount} Core @ ${cpuSpeed}GHz
â”‚ ê†œ CPU Model: ${cpuModel}
â”‚
â”‚ ê†œ Memory: ${ramUsed} / ${ramTotal}
â”‚ ê†œ Memory Usage: ${ramUsage}%
â”‚
â”‚ ê†œ Storage: ${disk.usedGb}GB / ${disk.totalGb}GB
â”‚ ê†œ Storage Usage: ${diskUsage}%
â”‚
â”‚ ê†œ Server Uptime: ${runtime(os.uptime())}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â

â•­â”€â ã€Œ ððŽð“ ð’ð“ð€ð“ð”ð’ ã€
â”‚ ê†œ Response Speed: ${latensi.toFixed(2)} ms
â”‚ ê†œ Bot Uptime: ${runtime(process.uptime())}
â”‚ ê†œ Bot Mode: ${alip.public ? "Public" : "Self"}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â

*Powered by ${namaOwner}*`.trim();

  await alip.sendMessage(m.chat, {
    text: teks,
    mentions: [global.owner + "@s.whatsapp.net"],
    contextInfo: {
      mentionedJid: [m.sender],
      isForwarded: true,
      forwardingScore: 9999,
      businessMessageForwardInfo: { businessOwnerJid: global.owner + "@s.whatsapp.net" },
      forwardedNewsletterMessageInfo: { newsletterName: namaSaluran, newsletterJid: global.idSaluran },
      externalAdReply: {
        title: `âš¡ ${botname} v${versi}`,
        body: `Speed: ${latensi.toFixed(2)}ms | Uptime: ${runtime(process.uptime())}`,
        thumbnailUrl: global.image.reply,
        sourceUrl: global.linkMenu,
        mediaType: 1,
        renderLargerThumbnail: true
      }
    }
  }, { quoted: qtext });
}
break;

//================================================================================

// Cari case "self" dan ubah menjadi seperti ini
case "self": {
    if (!isCreator) return
    alip.public = false
    global.db.settings.isPublic = false; // <-- TAMBAHKAN INI
    Reply("Berhasil mengganti ke mode *self*")
}
break

// Cari case "public" dan ubah menjadi seperti ini
case "public": {
    if (!isCreator) return
    alip.public = true
    global.db.settings.isPublic = true; // <-- TAMBAHKAN INI
    Reply("Berhasil mengganti ke mode *public*")
}
break


//================================================================================
case "restart":
case "rst": {
if (!isCreator) return Reply(mess.owner)
await Reply("Memproses _restart server_ . . .")

try {
    var file = await fs.readdirSync("./session")
    var anu = await file.filter(i => i !== "creds.json")
    for (let t of anu) {
        try {
            await fs.unlinkSync(`./session/${t}`)
        } catch {}
    }
    
    if (typeof process.send === 'function') {
        await process.send('reset')
    } else {
        await Reply("âœ… Session dibersihkan! Bot restart...")
        setTimeout(() => {
            process.exit(1)
        }, 2000)
    }
    
} catch (e) {
    await Reply(`âŒ Error: ${e.message}`)
}
}
break
//================================================================================

case "upchannel": case "upch": {
if (!isCreator) return Reply(mess.owner)
if (!text) return Reply(example("teksnya"))
await alip.sendMessage(idSaluran, {text: text})
Reply("Berhasil mengirim pesan *teks* ke dalam channel whatsapp")
}
break

//================================================================================

case "upchannel2": case "upch2": {
if (!isCreator) return Reply(mess.owner)
if (!text) return Reply(example("teksnya dengan mengirim foto"))
if (!/image/.test(mime)) return Reply(example("teksnya dengan mengirim foto"))
let img = await alip.downloadAndSaveMediaMessage(qmsg)
await alip.sendMessage(idSaluran, {image: await fs.readFileSync(img), caption: text})
Reply("Berhasil mengirim pesan *teks & foto* ke dalam channel whatsapp")
await fs.unlinkSync(img)
}
break

//================================================================================

case "getsc": {
    const owner = global.owner + '@s.whatsapp.net';
    if (!areJidsSameUser(m.sender, owner)) return Reply(`âŒ Hanya ${global.namaOwner} yang bisa akses command ini.`);
    
    let dir = await fs.readdirSync("./library/database/sampah");
    if (dir.length >= 2) {
        let res = dir.filter(e => e !== "A");
        for (let i of res) {
            await fs.unlinkSync(`./library/database/sampah/${i}`);
        }
    }
    await m.reply("Memproses backup script bot");
    const name = `${botname2}`;
    const ls = (await execSync("ls"))
        .toString()
        .split("\n")
        .filter(
            (pe) =>
                pe != "node_modules" &&
                pe != "session" &&
                pe != "package-lock.json" &&
                pe != "yarn.lock" &&
                pe != ""
        );
    const anu = await execSync(`zip -r "${name}.zip" ${ls.join(" ")}`);

    await alip.sendMessage(m.sender, {
        document: await fs.readFileSync(`./${name}.zip`),
        fileName: `${name}.zip`,
        mimetype: "application/zip"
    }, { quoted: m });
    await execSync(`rm -rf "${name}.zip"`);
    
    if (m.chat !== m.sender) return Reply("Script bot berhasil dikirim ke private chatâœ…");
}
break;
//================================================================================

case "resetdb":
case "rstdb": {
    if (!isCreator) return Reply(mess.owner);
    
    try {
        for (let i of Object.keys(global.db)) {
            global.db[i] = {};
        }
        
        const dbFiles = [
            './library/database/user.json',
            './library/database/sewagrup.json',
            './library/database/welcome.json',
            './library/database/level.json'
        ];
        
        dbFiles.forEach(filePath => {
            try {
                if (fs.existsSync(filePath)) {
                    let defaultData = {};
                    
                    if (filePath.includes('user.json')) {
                        defaultData = [];
                    } else if (filePath.includes('sewagrup.json')) {
                        defaultData = [];
                    } else if (filePath.includes('welcome.json')) {
                        defaultData = {};
                    } else if (filePath.includes('level.json')) {
                        defaultData = {};
                    }
                    
                    fs.writeFileSync(filePath, JSON.stringify(defaultData, null, 2));
                }
            } catch (fileError) {
                console.error(`Error resetting ${filePath}:`, fileError);
            }
        });
        
        Reply("âœ”ï¸ Database berhasil direset.");
        
    } catch (error) {
        console.error('Reset DB Error:', error);
        Reply("âŒ Gagal mereset database.");
    }
}
break;

//================================================================================

case 'setbotpp':
case 'setppbot': {
    if (!isOwner) return Reply(global.mess.owner)
    if (!quoted) return Reply(`Kirim/kutip gambar dengan caption ${command}`)
    if (!/image/.test(mime)) return Reply(`Kirim/kutip gambar dengan caption ${command}`)
    if (/webp/.test(mime)) return Reply(`Kirim/kutip gambar dengan caption ${command}`)
    
    let mediaBuffer = await downloadContentFromMessage(quoted.msg || quoted, 'image')
    let bufferArray = []
    for await (const chunk of mediaBuffer) {
        bufferArray.push(chunk)
    }
    const imageBuffer = Buffer.concat(bufferArray)
    
    await alip.updateProfilePicture(botNumber, imageBuffer)
    .then(() => Reply('Sukses mengganti pp bot!'))
    .catch((err) => Reply('Gagal mengganti pp bot: ' + err.message))
}
break

//================================================================================

case "clearchat": case "clc": {
if (!isCreator) return Reply(mess.owner)
alip.chatModify({ delete: true, lastMessages: [{ key: m.key, messageTimestamp: m.timestamp }]}, m.chat)
}
break

//================================================================================

case "listowner": case "listown": {
if (owners.length < 1) return Reply("Tidak ada owner tambahan")
let teks = `\n *ä¹‚ List all owner tambahan*\n`
for (let i of owners) {
teks += `\n* ${i.split("@")[0]}
* *Tag :* @${i.split("@")[0]}\n`
}
alip.sendMessage(m.chat, {text: teks, mentions: owners}, {quoted: m})
}
break

//================================================================================
case 'ytcomment': {
  if (!isRegistered(m.sender)) return Reply(mess.verifikasi);
  if (!text) return Reply(`Contoh : ${prefix + command} hello world`);
  if (checkLimit(m.sender, isPrem(m.sender), isCreator)) 
    return Reply(global.mess.limit);

  
  addLimit(m.sender, isPrem(m.sender), isCreator);

  await alip.sendMessage(m.chat, {
    react: { text: "â±ï¸", key: m.key }
  });

  try {
    let avatar;
    try {
      avatar = await alip.profilePictureUrl(m.sender, "image");
    } catch {
      avatar = 'https://telegra.ph/file/c3f3d2c2548cbefef1604.jpg';
    }

    const buffer = await getBuffer(
      `https://some-random-api.com/canvas/misc/youtube-comment?comment=${encodeURIComponent(text)}&avatar=${encodeURIComponent(avatar)}&username=${m.pushName}`
    );

    await alip.sendMessage(
      m.chat,
      { image: buffer, caption: `*YouTube Comment ðŸŸ*` },
      { quoted: m }
    );
  } catch (e) {
    Reply('Gagal!');
  }
}
break;

case 'qc': {
  if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

  if (!text) return Reply(`ðŸ“Œ Contoh: ${prefix + command} Hai kak`);

  const safeText = typeof text === 'string' ? text : String(text || '');
  if (safeText.length > 100)
    return Reply(`âš ï¸ Maksimal 100 karakter.`);
  return alip.sendMessage(m.chat, {
    text: `ðŸ”˜ Pilih jenis qc`,
    buttons: [
      { buttonId: `.qc1 ${safeText}`, buttonText: { displayText: 'Hitam' }, type: 1 },
      { buttonId: `.qc2 ${safeText}`, buttonText: { displayText: 'Putih' }, type: 1 },
    ],
    headerType: 1
  }, { quoted: m });
}
break;

case "qc1": {
if (!isRegistered(m.sender) && !['daftar', 'register'].includes(command) && !isCreator)
        return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

addLimit(m.sender, isPrem(m.sender), isCreator);

if (!text) return m.reply(example('teksnya'));
m.reply('â³ Loading...');

let warna = ["#000000", "#ff2414", "#22b4f2", "#eb13f2"];
var ppuser;
try {
  ppuser = await alip.profilePictureUrl(m.sender, 'image');
} catch (err) {
  ppuser = 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg';
}

const json = {
  "type": "quote",
  "format": "png",
  "backgroundColor": "#000000",
  "width": 812,
  "height": 968,
  "scale": 2,
  "messages": [{
    "entities": [],
    "avatar": true,
    "from": {
      "id": 1,
      "name": m.pushName,
      "photo": {
        "url": ppuser
      }
    },
    "text": text,
    "replyMessage": {}
  }]
};

const response = axios.post('https://bot.lyo.su/quote/generate', json, {
  headers: { 'Content-Type': 'application/json' }
}).then(async (res) => {
  const buffer = Buffer.from(res.data.result.image, 'base64');
  let tempnya = "./library/database/sampah/" + m.sender + ".png";
  await fs.writeFile(tempnya, buffer, async (err) => {
    if (err) return m.reply("Error");
    await alip.sendAsSticker(m.chat, tempnya, m, { packname: global.packname });
    await fs.unlinkSync(`${tempnya}`);
  });
});
}
break;

//================================================================================

case "qc2": {
if (!isRegistered(m.sender) && !['daftar', 'register'].includes(command) && !isCreator)
        return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

addLimit(m.sender, isPrem(m.sender), isCreator);

if (!text) return m.reply(example('teksnya'));
m.reply('â³ Loading...');

let warna = ["#000000", "#ff2414", "#22b4f2", "#eb13f2"];
var ppuser;
try {
  ppuser = await alip.profilePictureUrl(m.sender, 'image');
} catch (err) {
  ppuser = 'https://telegra.ph/file/a059a6a734ed202c879d3.jpg';
}

const json = {
  "type": "quote",
  "format": "png",
  "backgroundColor": "#ffffff",
  "width": 812,
  "height": 968,
  "scale": 2,
  "messages": [{
    "entities": [],
    "avatar": true,
    "from": {
      "id": 1,
      "name": m.pushName,
      "photo": {
        "url": ppuser
      }
    },
    "text": text,
    "replyMessage": {}
  }]
};

const response = axios.post('https://bot.lyo.su/quote/generate', json, {
  headers: { 'Content-Type': 'application/json' }
}).then(async (res) => {
  const buffer = Buffer.from(res.data.result.image, 'base64');
  let tempnya = "./library/database/sampah/" + m.sender + ".png";
  await fs.writeFile(tempnya, buffer, async (err) => {
    if (err) return m.reply("Error");
    await alip.sendAsSticker(m.chat, tempnya, m, { packname: global.packname });
    await fs.unlinkSync(`${tempnya}`);
  });
});
}
break;

case "delowner": 
case "delown": {
    if (!isCreator) return Reply(mess.owner)
    if (!m.quoted && !text && !m.mentionedJid?.length) return Reply(example("6285xxx / tag"))

    let users = []
    if (m.isGroup) {
        if (m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else {
            users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    } else {
        users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }

    for (let input of users) {
        const input2 = input.split("@")[0]
        if (input2 === global.owner || input === botNumber) {
            Reply(`Tidak bisa menghapus owner utama!`)
            continue
        }
        if (!owners.includes(input)) {
            Reply(`Nomor ${input2} bukan owner bot!`)
            continue
        }
        owners.splice(owners.indexOf(input), 1)
    }

    fs.writeFileSync("./library/database/owner.json", JSON.stringify(owners, null, 2))
    Reply(`Berhasil menghapus owner âœ…`)
}
break

//================================================================================
case "addowner": 
case "addown": {
    const owner = global.owner + '@s.whatsapp.net';
    if (!areJidsSameUser(m.sender, owner)) return Reply(`âŒ Hanya ${global.namaOwner} yang bisa menambah owner.`);
    
    if (!m.quoted && !text && !m.mentionedJid?.length) return Reply(example("6285xxx / tag"))

    let users = []
    if (m.isGroup) {
        if (m.mentionedJid.length) {
            users = m.mentionedJid.map(id => {
                if (id.endsWith('@lid')) {
                    let p = m.metadata.participants.find(x => x.lid === id || x.id === id)
                    return p ? p.jid : null
                } else {
                    return id
                }
            }).filter(Boolean)
        } else {
            users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
        }
    } else {
        users = [text.replace(/[^0-9]/g, '') + '@s.whatsapp.net']
    }

    for (let input of users) {
        const input2 = input.split("@")[0]
        if (input2 === global.owner || owners.includes(input) || input === botNumber) {
            Reply(`Nomor ${input2} sudah menjadi owner bot!`)
            continue
        }
        owners.push(input)
    }

    fs.writeFileSync("./library/database/owner.json", JSON.stringify(owners, null, 2))
    Reply(`Berhasil menambah owner âœ…`)
}
break

//================================================================================

case "tts": {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);

    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    
    if (!text) {
        return Reply(`ðŸš€ *Text to speech*

Gunakan:
â€¢ .tts <suara>|<teks> 
_______________________
Suara tersedia:
â€¢ jokowi, prabowo, megawati
â€¢ bella, echilling, adam
â€¢ thomas_shelby, michi_jkt48
â€¢ nokotan, boboiboy, yanzgpt
â€¢ keqing, yanami_anna`);
    }
    
    if (!text.includes("|")) {
        return Reply(`âŒ *Format salah!*

Gunakan: .tts <suara>|<teks>

Contoh:
â€¢ .tts jokowi|Halo semuanya
â€¢ .tts bella|Hello world`);
    }
    
    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });
    
    try {
        const parts = text.split("|");
        const voice = parts[0].trim().toLowerCase();
        const ttsText = parts.slice(1).join("|").trim();
        
        if (!ttsText) {
            return Reply(`âŒ *Teks kosong!*

Contoh: .tts jokowi|Halo semuanya
â€¢ Pilih suara: ${voice}
â€¢ Masukkan teks setelah |`);
        }
        
        async function generateVN(text, voice = "bella") {
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const response = await axios.get(`${global.termai}/api/text2speech/elevenlabs`, {
                        params: {
                            text,
                            voice,
                            key: `${global.apitermai}`
                        },
                        responseType: "arraybuffer"
                    });
                    
                    return Buffer.from(response.data);
                    
                } catch (e) {
                    if (attempt === 3) {
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
            return null;
        }
        
        const audioBuffer = await generateVN(ttsText, voice);
        
        if (!audioBuffer) {
            await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
            return Reply("âŒ Gagal membuat voice note. Coba lagi.");
        }
        
        await alip.sendMessage(m.chat, {
            audio: audioBuffer,
            mimetype: 'audio/mpeg',
            ptt: true,
            contextInfo: {
                externalAdReply: {
                    title: `${voice}`,
                    body: "",
                    thumbnailUrl: "https://raw.githubusercontent.com/alifalfarel25-commits/dat1/main/uploads/alip-clutch-1769826260043.jpg",
                    mediaType: 1
                }
            }
        }, { quoted: m });
        
        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        
    } catch (error) {
        await alip.sendMessage(m.chat, { react: { text: "âŒ", key: m.key } });
        return Reply(`âŒ Error: ${error.message}`);
    }
}
break;

case "asupan": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
 Reply(mess.wait);
 let url = `https://api.agatz.xyz/api/asupan`//Api
 let res = await fetch(url);
 let response = await res.json();
 try {
 alip.sendMessage(m.chat,{ 
 video: { 
 url: response.data 
 }, 
 mimeType: 'video/mp4', 
 caption: 'Done' }, 
 { quoted: m })
 } catch (e) {
 console.log(e);//Kalo Ada Yh Error Akan Di Tampilkan Di Console
 Reply(e);//Reply Pesan Yg Error
 }
}
break

case "cekcuaca": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
 if(!text) return Reply('*Example Comand*\n*.cekcuaca* Nama kota / desa');
 Reply("Memproses pencarian")
 let url = `https://api.diioffc.web.id/api/tools/cekcuaca?query=${encodeURIComponent(text)}`;
 const res = await fetch(url);
 const response = await res.json();
 let teks = `*ðŸ Nama Kota / Desa :* ${response.result.name}\n- *_Zona Waktu:_* ${response.result.timezone}\n- *_Description:_* ${response.result.weather[0].description}\n- *_Suhu:_* ${response.result.main.temp}\n- *_Suhu Minus:_* ${response.result.main.temp_min}\n- *_Suhu Maks:_* ${response.result.main.temp_max}\n- *_Tekanan:_* ${response.result.main.preesure}\n- *_Kelembapan:_* ${response.result.main.humidity}\n- *_Kecepatan Angin:_* ${response.result.wind.speed}`
 try {
 alip.sendMessage(m.chat, {image: {url: `https://tse4.mm.bing.net/th?id=OIP.XC9RLrV4cN8oAQCFcvkvwgHaEJ&pid=Api&P=0&h=180`}, caption: teks}, {quoted: m})
 } catch (err) {
 console.log(err);
 await Reply("Not Found")
 }
 }
 break

case 'calendar':
case 'cekkalender': {
    if (!isRegistered(m.sender) && !isCreator) return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, isPrem(m.sender), isCreator)) return Reply(global.mess.limit);

    await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

    try {
        const moment = require("moment-timezone");
        const tgl = moment.tz('Asia/Jakarta').format('DD');
        const bln = moment.tz('Asia/Jakarta').format('MM');
        const thn = moment.tz('Asia/Jakarta').format('YYYY');

        const api_url = `https://fgsi.dpdns.org/api/maker/calendar?apikey=fgsiapi-2ef6382d-6d&date=${tgl}&month=${bln}&year=${thn}`;

        await alip.sendMessage(m.chat, { 
            image: { url: api_url }, 
            caption: `âœ… *CALENDAR GENERATOR*\n\nðŸ“… Tanggal: ${tgl}-${bln}-${thn}\nðŸ“ Timezone: Asia/Jakarta` 
        }, { quoted: m });

        await alip.sendMessage(m.chat, { react: { text: "âœ…", key: m.key } });
        addLimit(m.sender, isPrem(m.sender), isCreator);

    } catch (e) {
        console.error(e);
        Reply("âŒ Terjadi kesalahan pada server API Kalender.");
    }
}
break;

case 'ambilsw': case "sw": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
 const quotedMessage = m.message?.extendedTextMessage?.contextInfo?.quotedMessage;
 if (!quotedMessage) return Reply("ðŸ“Œ Balas pesan gambar/video yang ingin diambil!");

 if (quotedMessage.imageMessage) {
 let imageUrl = await alip.downloadAndSaveMediaMessage(quotedMessage.imageMessage);
 return alip.sendMessage(m.chat, { image: { url: imageUrl } }, { quoted: m });
 }

 if (quotedMessage.videoMessage) {
 let videoUrl = await alip.downloadAndSaveMediaMessage(quotedMessage.videoMessage);
 return alip.sendMessage(m.chat, { video: { url: videoUrl } }, { quoted: m });
 }

 return Reply("âŒ Hanya bisa mengambil gambar atau video dari pesan yang dikutip!");
}
break

case 'struk': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);


addLimit(m.sender, global.isPrem(m.sender), isCreator);
 if (!text) return alip.sendMessage(m.chat, { text: 
 "Format salah!\nGunakan: .struk toko|nama_penjual|kontak_penjual|items|metode_pembayaran|info_tambahan\n\n" +
 "Contoh:\n.struk TOKO BIYU|Yubi|6285776461481|Es Teh-5000-2,Nasi Goreng-15000-1|Cash|Terima kasih sudah datang!"
 }, { quoted: m })

 let [toko, namaPenjual, kontakPenjual, items, metodePembayaran, infoTambahan] = text.split('|')
 if (!toko || !namaPenjual || !kontakPenjual || !items || !metodePembayaran) {
 return alip.sendMessage(m.chat, { text: '*Format tidak lengkap!*' }, { quoted: m })
 }

 // parse daftar barang
 let daftarBarang = items.split(',').map((it, i) => {
 let [nama, harga, jumlah] = it.split('-')
 harga = parseInt(harga)
 jumlah = parseInt(jumlah)
 return { nomor: i+1, nama, harga, jumlah, total: harga * jumlah }
 })

 // gambar canvas
 const { createCanvas } = require('canvas')
 const fs = require('fs')
 const path = require('path')
 let cw = 600, ch = 600 + daftarBarang.length*30
 const canvas = createCanvas(cw, ch)
 const ctx = canvas.getContext('2d')
 // background
 ctx.fillStyle = '#fff'
 ctx.fillRect(0,0,cw,ch)
 // header
 ctx.fillStyle = '#000'
 ctx.font = 'bold 22px monospace'
 ctx.textAlign = 'center'
 ctx.fillText(toko.toUpperCase(), cw/2, 40)
 ctx.font = '14px monospace'
 ctx.fillText(`Kontak Penjual: ${kontakPenjual}`, cw/2, 65)
 // transaksi info
 let trxNo = Math.floor(Math.random()*1e15)
 let now = new Date().toLocaleString('id-ID',{timeZone:'Asia/Jakarta'})
 ctx.textAlign = 'left'
 ctx.fillText(`No Transaksi: ${trxNo}`, 20, 100)
 ctx.fillText(`Tanggal: ${now}`, 20, 125)
 ctx.beginPath()
 ctx.moveTo(20,150); ctx.lineTo(cw-20,150); ctx.stroke()
 // list barang
 let startY = 175
 daftarBarang.forEach((b,i) => {
 let y = startY + i*30
 ctx.fillText(
 `${b.nomor}. ${b.nama} - Rp${b.harga.toLocaleString()} x${b.jumlah} = Rp${b.total.toLocaleString()}`,
 20, y
 )
 })
 // garis bawah
 let lastY = startY + daftarBarang.length*30 + 10
 ctx.beginPath()
 ctx.moveTo(20,lastY); ctx.lineTo(cw-20,lastY); ctx.stroke()
 // total
 let subtotal = daftarBarang.reduce((a,b)=>a+b.total,0)
 let pajak = Math.floor(subtotal*0.1)
 let totalBayar = subtotal + pajak
 ctx.fillText(`Subtotal: Rp${subtotal.toLocaleString()}`, 20, lastY+25)
 ctx.fillText(`Pajak (10%): Rp${pajak.toLocaleString()}`, 20, lastY+50)
 ctx.fillText(`Total Bayar: Rp${totalBayar.toLocaleString()}`, 20, lastY+75)
 ctx.fillText(`Metode: ${metodePembayaran}`, 20, lastY+100)
 if (infoTambahan) ctx.fillText(`Info: ${infoTambahan}`, 20, lastY+125)
 // footer
 ctx.font = 'bold 14px monospace'
 ctx.textAlign = 'center'
 ctx.fillText('TERIMA KASIH TELAH BERBELANJA', cw/2, lastY+160)
 ctx.fillText(namaPenjual.toUpperCase(), cw/2, lastY+180)
 // simpan & kirim
 const tmp = path.join(__dirname, './tmp')
 if (!fs.existsSync(tmp)) fs.mkdirSync(tmp)
 const file = path.join(tmp, `struk_${trxNo}.png`)
 fs.writeFileSync(file, canvas.toBuffer('image/png'))
 await alip.sendMessage(m.chat, {
 image: { url: file },
 caption: `*Ini Struk nya*\n\nðŸ“ Pesan: Amanah Selalu :v\n~ ${namaPenjual}`
 }, { quoted: m })
 fs.unlinkSync(file)
}
break

case "cekgempa": {
 Reply("Sedang mengambil data gempa terkini...");
 
 try {
 const response = await fetch("https://data.bmkg.go.id/DataMKG/TEWS/autogempa.json");
 const data = await response.json();
 
 if (!data || !data.Infogempa || !data.Infogempa.gempa) {
 return Reply("Gagal mendapatkan data gempa dari BMKG.");
 }
 
 const gempa = data.Infogempa.gempa;
 
 let caption = `*ðŸ“ˆ INFO GEMPA TERKINI*\n\n`;
 caption += `*Tanggal:* ${gempa.Tanggal}\n`;
 caption += `*Waktu:* ${gempa.Jam}\n`;
 caption += `*Magnitudo:* ${gempa.Magnitude}\n`;
 caption += `*Kedalaman:* ${gempa.Kedalaman}\n`;
 caption += `*Lokasi:* ${gempa.Wilayah}\n`;
 caption += `*Koordinat:* ${gempa.Lintang} ${gempa.Bujur}\n`;
 caption += `*Potensi:* ${gempa.Potensi}\n`;
 caption += `*Dirasakan:* ${gempa.Dirasakan}\n\n`;
 caption += `Sumber: BMKG (https://www.bmkg.go.id/)`;
 
 if (gempa.Shakemap) {
 const shakemapUrl = `https://data.bmkg.go.id/DataMKG/TEWS/${gempa.Shakemap}`;
 await alip.sendMessage(m.chat, {
 image: { url: shakemapUrl },
 caption: caption
 }, { quoted: m });
 } else {
 alip.sendMessage(m.chat, { text: caption }, { quoted: m });
 }
 } catch (error) {
 console.log(error);
 Reply("Terjadi kesalahan saat mengambil data gempa.");
 }
}
break

case 'totalfitur': {
  const fs = require('fs');
  const path = require('path');

  const caseFile = path.join(__dirname, './alipai-cmd.js');
  const pluginsDir = path.join(__dirname, './plugins');

  let totalCase = 0;
  let totalPlugin = 0;

  if (fs.existsSync(caseFile)) {
    const content = fs.readFileSync(caseFile, 'utf8');
    totalCase = (content.match(/case\s+['"`]/g) || []).length;
  }

  const countJsFiles = (dir) => {
    let count = 0;
    const files = fs.readdirSync(dir);
    for (const file of files) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        count += countJsFiles(fullPath);
      } else if (file.endsWith('.js')) {
        count++;
      }
    }
    return count;
  };

  if (fs.existsSync(pluginsDir)) {
    totalPlugin = countJsFiles(pluginsDir);
  }

  const totalFitur = totalCase + totalPlugin;

  alip.sendMessage(m.chat, {
    text: `ðŸ¤– *Total Fitur Bot: ${totalFitur}*`,
    contextInfo: {
      externalAdReply: {
        title: `ðŸ“¦ Total Fitur Bot ${botname2}`,
        body: `Case: ${totalCase} | Plugin: ${totalPlugin} | Total: ${totalFitur}`,
        thumbnailUrl: global.image.menu, // â† Pastikan global.image.menu udah diatur
        sourceUrl: `https://wa.me/${m.sender.split('@')[0]}`,
        mediaType: 1,
        renderLargerThumbnail: true,
        showAdAttribution: false
      }
    }
  }, { quoted: m });
}
break;

case "carigrupwa": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
return Reply(global.mess.limit);
addLimit(m.sender, global.isPrem(m.sender), isCreator);
  if (!text) return Reply(`âŒ Masukin kata kunci!\n\nContoh: ${prefix + command} anime`);
  try {
    let res = await fetch(`${global.btc}/api/search/linkgroupwa?apikey=${global.apikeyalip}&text1=${encodeURIComponent(text)}`);
    let data = await res.json();
    if (!data.status || !data.result || data.result.length < 1) return Reply("âš ï¸ Grup gak ketemu!");

    let list = data.result.slice(0, 3);
    let descText = list.map((g, i) => 
      `${i+1}. *${g.title}*\n${g.desc?.substring(0, 80) || "-"}\nðŸ”— ${g.link}`
    ).join("\n\n");

    let caption = `ðŸ“Œ Hasil Pencarian Grup WA\n\n${descText}`;

    await alip.sendMessage(m.chat, {
      text: caption,
      contextInfo: {
        externalAdReply: {
          title: `ðŸ” Hasil Grup WA`,
          body: `Kata Kunci: ${text}`,
          thumbnailUrl: global.image.menu,
          sourceUrl: `https://wa.me/${m.sender.split('@')[0]}`,
          mediaType: 1,
          renderLargerThumbnail: true,
          showAdAttribution: false
        }
      }
    }, { quoted: m });

  } catch (e) {
    console.error(e);
    Reply("âŒ Error, coba lagi nanti.");
  }
}
break;
case "bratgura": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
if (!text)
    return Reply('âŒ Contoh penggunaan: .bratgura alip ai nih boss');
addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
    const response = await axios.get(
        'https://raw.githubusercontent.com/alifalfarel25-commits/dat4/main/uploads/alip-clutch-1770001033541.jpg',
        { responseType: 'arraybuffer' }
    );
    const buffer = Buffer.from(response.data);

    const img = await loadImage(buffer);
    const canvas = createCanvas(img.width, img.height);
    const ctx = canvas.getContext('2d');

    ctx.drawImage(img, 0, 0, img.width, img.height);

    const areaX = img.width * 0.56;
    const areaY = img.height * 0.28;
    const areaWidth = img.width * 0.36;
    const areaHeight = img.height * 0.32;

    let fontSize = img.height * 0.11;
    ctx.font = `${fontSize}px Arial`;
    ctx.fillStyle = '#000';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    const words = text.split(' ');
    let lines = [];
    let line = '';

    for (let word of words) {
        const testLine = line ? `${line} ${word}` : word;
        const testWidth = ctx.measureText(testLine).width;

        if (testWidth > areaWidth && line) {
            lines.push(line);
            line = word;
        } else {
            line = testLine;
        }
    }
    if (line) lines.push(line);

    while (lines.length * fontSize * 1.25 > areaHeight) {
        fontSize -= 2;
        ctx.font = `${fontSize}px Arial`;

        let tmpLines = [];
        let tmpLine = '';
        for (let word of words) {
            const testLine = tmpLine ? `${tmpLine} ${word}` : word;
            const testWidth = ctx.measureText(testLine).width;

            if (testWidth > areaWidth && tmpLine) {
                tmpLines.push(tmpLine);
                tmpLine = word;
            } else {
                tmpLine = testLine;
            }
        }
        if (tmpLine) tmpLines.push(tmpLine);
        lines = tmpLines;
    }

    const lineHeight = fontSize * 1.25;

    ctx.shadowColor = 'rgba(0,0,0,0.22)';
    ctx.shadowBlur = 2;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    ctx.globalAlpha = 0.95;

    for (let i = 0; i < lines.length; i++) {
        ctx.fillText(
            lines[i],
            areaX,
            areaY + i * lineHeight
        );
    }

    ctx.globalAlpha = 1;

    const imageBuffer = canvas.toBuffer('image/png');

    const { Sticker } = require('wa-sticker-formatter');
    const sticker = new Sticker(imageBuffer, {
        pack: global.packname,
        author: global.author || global.namaOwner || "alip AI",
        type: 'full',
        quality: 100
    });

    await alip.sendMessage(m.chat, { sticker: await sticker.toBuffer() }, { quoted: m });
    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

} catch (e) {
    Reply('âŒ Gagal membuat sticker bratgura. Coba lagi nanti.');
}
}
break;
case "bratanime": {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);
if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
    return Reply(global.mess.limit);
if (!text) 
    return Reply('âŒ Contoh penggunaan: .bratanime Hello World');
addLimit(m.sender, global.isPrem(m.sender), isCreator);

await alip.sendMessage(m.chat, { react: { text: "â³", key: m.key } });

try {
    const response = await axios.get('https://files.catbox.moe/19c4n5.png', { 
        responseType: 'arraybuffer' 
    });
    const templateBuffer = Buffer.from(response.data);
    
    const img = await loadImage(templateBuffer);
    const canvas = createCanvas(img.width, img.height);
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0, img.width, img.height);
    
    const paperX = img.width * 0.285;
    const paperY = img.height * 0.42;
    const paperWidth = img.width * 0.30;
    const paperHeight = img.height * 0.28;
    
    let fontSize = Math.min(paperWidth / 5.5, paperHeight / 2.8);
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.fillStyle = 'black';
    
    const maxWidth = paperWidth * 0.88;
    let words = text.split(' ');
    let lines = [];
    let line = '';
    
    for (let word of words) {
        let testLine = line + (line ? ' ' : '') + word;
        let testWidth = ctx.measureText(testLine).width;
        
        if (testWidth > maxWidth && line) {
            lines.push(line);
            line = word;
        } else {
            line = testLine;
        }
    }
    if (line) lines.push(line);
    
    while (lines.length * fontSize > paperHeight * 0.80) {
        fontSize -= 1;
        ctx.font = `bold ${fontSize}px Arial`;
        
        let tempLines = [];
        let tempLine = '';
        for (let word of words) {
            let testLine = tempLine + (tempLine ? ' ' : '') + word;
            let testWidth = ctx.measureText(testLine).width;
            
            if (testWidth > maxWidth && tempLine) {
                tempLines.push(tempLine);
                tempLine = word;
            } else {
                tempLine = testLine;
            }
        }
        if (tempLine) tempLines.push(tempLine);
        lines = tempLines;
    }
    
    let lineHeight = fontSize * 1.25;
    let textHeight = lines.length * lineHeight;
    
    let textStartY = paperY + (paperHeight - textHeight) / 2 + 268;
    
    ctx.save();
    ctx.translate(paperX + paperWidth / 2 + 300, textStartY + 12);
    ctx.rotate(0.06);
    
    ctx.textAlign = 'center';
    
    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], 0, i * lineHeight);
    }
    ctx.restore();
    
    const imageBuffer = canvas.toBuffer('image/png');
    
    const { Sticker } = require('wa-sticker-formatter');
    const sticker = new Sticker(imageBuffer, {
        pack: global.packname,
        author: global.author || global.namaOwner || "alip AI",
        type: 'full',
        quality: 100
    });
    
    const stickerBuffer = await sticker.toBuffer();
    await alip.sendMessage(m.chat, {
        sticker: stickerBuffer,
        contextInfo: {
            isForwarded: true, 
            forwardingScore: 999,
            forwardedNewsletterMessageInfo: {
                newsletterJid: global.idSaluran,
                newsletterName: global.namaSaluran,
                serverMessageId: -1
            }
        }
    }, { quoted: m });
    
    await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

} catch (e) {
    Reply('âŒ Gagal membuat sticker bratanime. Coba lagi nanti.');
}
}
break;

case 'ghibli': {
if (!isRegistered(m.sender) && !isCreator)
    return Reply(global.mess.verifikasi);

if (!global.isPrem(m.sender) && !isCreator) 
        return Reply(mess.prem);

    const q = m.quoted || m;
    const mime = (q.msg || q).mimetype || '';
    if (!mime.startsWith('image/')) return m.reply('âŒ Kirim gambar dulu.');

    const buffer = await q.download().catch(() => null);
    if (!buffer) return m.reply('âŒ Gagal download gambar.');
    if (buffer.length > 5 * 1024 * 1024) return m.reply('âš ï¸ Ukuran gambar maksimal 5MB.');

    addLimit(m.sender, global.isPrem(m.sender), isCreator);
    m.reply('â³ Proses sedang berjalan...');

    try {
        const fetchModule = await import('node-fetch');
        const fetch = fetchModule.default;
        const FormData = (await import('form-data')).default;

        // default studio
        const studios = [
            'ghibli-spirited-away-anime',
            'ghibli-my-neighbor-totoro-anime',
            'ghibli-ponyo-anime',
            'ghibli-princess-mononoke-anime'
        ];

        // random studio biar beda-beda
        const studioId = studios[Math.floor(Math.random() * studios.length)];

        // bikin form-data
        let form = new FormData();
        form.append('studio', studioId);
        form.append('file', buffer, { filename: "image.jpg", contentType: mime });

        // ambil token
        const appId = 'DKTECH_GHIBLI_Dktechinc';
        const secretKey = 'r0R5EKF4seRwqUIB8gLPdFvNmPm8rN63';
        const baseUrl = 'https://api.code12.cloud';

        const tokenRes = await fetch(`${baseUrl}/app/paygate-oauth/token`, {
            method: "POST",
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ appId, secretKey })
        });

        if (!tokenRes.ok) return Reply('âŒ Gagal ambil token API Ghibli!');
        const tokenData = await tokenRes.json();
        const token = tokenData?.data?.token;
        if (!token) return Reply('âŒ Token Ghibli tidak valid!');

        // kirim ke API Ghibli
        const res = await fetch(`${baseUrl}/app/v2/ghibli/user-image/edit-theme?uuid=1212`, {
            method: "POST",
            headers: { 
                'authorization': `Bearer ${token}`, 
                ...form.getHeaders()
            },
            body: form
        });

        if (!res.ok) {
            const errMsg = await res.text();
            console.log("âŒ API Error:", errMsg);
            return Reply("âŒ Gagal mengubah gambar (API error)!");
        }

        const data = await res.json();
        if (data?.status?.code !== '200') return Reply("âŒ API Ghibli error!");

        const imageUrl = data?.data?.imageUrl;
        if (!imageUrl) return Reply("âŒ Gagal mendapatkan hasil Ghibli!");

        // kirim hasil ke chat
        await alip.sendMessage(m.chat, { image: { url: imageUrl }, caption: `âœ… Ghibli Style Done!\nðŸŽ¨ Studio: ${studioId}` }, { quoted: m });

    } catch (err) {
        console.error(err);
        Reply(`âŒ Terjadi error saat proses.\n\nError: ${err.message}`);
    }
}
break;

case 'report': {
 if (!text) 
 return Reply(`ðŸš¨ *Contoh:* .report fitur .menu error kak, gak muncul balasan\n\nðŸ“ Jelaskan dengan detail ya, biar owner gampang cek!`)

 if (!global.owner || global.owner.length === 0) 
 return Reply("âŒ Nomor owner belum diatur di global.owner")

 const senderJid = m.sender
 const nomorPengirim = senderJid.split('@')[0]
 const waktu = new Date().toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })

 const laporan = `â•­â”€â *LAPORAN FITUR DARI USER*
â”‚
â”‚ðŸ‘¤ *Pengirim:* @${nomorPengirim}
â”‚ðŸ”— *Nomor:* wa.me/${nomorPengirim}
â”‚ðŸ•’ *Waktu:* ${waktu}
â”‚
â”‚ðŸ§© *Isi Laporan:*
â”‚${text.split('\n').map(line => 'â”‚ ' + line).join('\n')}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â`

 // Support global.owner string atau array
 let owners = []
 if (typeof global.owner === 'string') owners = [global.owner]
 else if (Array.isArray(global.owner)) owners = global.owner
 else return Reply("âŒ Format global.owner tidak valid!")

 let sukses = 0
 for (let ownerNum of owners) {
 try {
 let jid = ownerNum.replace(/\D/g, '') + '@s.whatsapp.net'
 await alip.sendMessage(jid, {
 text: laporan,
 mentions: [senderJid]
 })
 sukses++
 } catch (e) {
 console.log(`âŒ Gagal kirim laporan ke ${ownerNum}:`, e)
 }
 }

 if (sukses === 0) 
 return Reply('âŒ Gagal kirim laporan. Mungkin owner belum pernah chat bot?')

 Reply(`âœ… *Laporan kamu udah dikirim ke owner!*\nTerima kasih sudah bantu improve bot ini ðŸ™Œ`)
}
break

case 'req': {
 if (!text) 
 return Reply(`ðŸš¨ *Contoh:* .request fitur stiker pepek item\n\nðŸ“ Jelaskan dengan detail ya, biar owner gampang cek!`)

 if (!global.owner || global.owner.length === 0) 
 return Reply("âŒ Nomor owner belum diatur di global.owner")

 const senderJid = m.sender
 const nomorPengirim = senderJid.split('@')[0]
 const waktu = new Date().toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })

 const laporan = `â•­â”€â *REQUEST FITUR DARI USER*
â”‚
â”‚ðŸ‘¤ *Pengirim:* @${nomorPengirim}
â”‚ðŸ”— *Nomor:* wa.me/${nomorPengirim}
â”‚ðŸ•’ *Waktu:* ${waktu}
â”‚
â”‚ðŸ§© *Isi request:*
â”‚${text.split('\n').map(line => 'â”‚ ' + line).join('\n')}
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â`

 // Support global.owner string atau array
 let owners = []
 if (typeof global.owner === 'string') owners = [global.owner]
 else if (Array.isArray(global.owner)) owners = global.owner
 else return Reply("âŒ Format global.owner tidak valid!")

 let sukses = 0
 for (let ownerNum of owners) {
 try {
 let jid = ownerNum.replace(/\D/g, '') + '@s.whatsapp.net'
 await alip.sendMessage(jid, {
 text: laporan,
 mentions: [senderJid]
 })
 sukses++
 } catch (e) {
 console.log(`âŒ Gagal kirim request ke ${ownerNum}:`, e)
 }
 }

 if (sukses === 0) 
 return Reply('âŒ Gagal kirim request. Mungkin owner belum pernah chat bot?')

 Reply(`âœ… *Request kamu udah dikirim ke owner!*\nTerima kasih sudah bantu improve bot ini ðŸ™Œ`)
}
break

case 'clearreseller':
case 'resetreseller':
case 'hapussemuareseller': {
 if (!isCreator) return Reply(mess.owner);
 
 let reseller = loadReseller();
 
 if (reseller.length === 0) {
 return Reply('âš ï¸ *Database Reseller sudah kosong!* Tidak ada data yang perlu dihapus.');
 }
 
 const totalReseller = reseller.length;
 const resellerList = reseller.map(jid => `@${jid.split('@')[0]}`).slice(0, 10).join(', ');
 
 // Langsung hapus tanpa konfirmasi
 reseller = []; // Kosongkan array
 saveReseller(reseller);
 
 Reply(`ðŸ—‘ï¸ *BERHASIL MENGHAPUS SEMUA RESELLER!*

ðŸ“Š *Statistik Penghapusan:*
âœ… Total Reseller Dihapus: *${totalReseller} user*
ðŸ—‚ï¸ Database Reseller: **DIKOSONGKAN**
ðŸ”„ Status: **SEMUA DATA TERHAPUS**

ðŸ‘¥ *Daftar Reseller yang Dihapus:*
${resellerList}${totalReseller > 10 ? `\n...dan ${totalReseller - 10} user lainnya` : ''}

*Semua hak akses reseller telah dicabut.*`);
}
break;

case 'togif': {
    if (!isRegistered(m.sender) && !isCreator)
        return Reply(global.mess.verifikasi);
    if (checkLimit(m.sender, global.isPrem(m.sender), isCreator))
        return Reply(global.mess.limit);
    
    const q = m.quoted ? m.quoted : m;
    const mime = (q.msg || q).mimetype || '';
    if (!/webp|image|video/i.test(mime))
        return Reply('Reply stiker, gambar, atau video untuk diubah ke GIF');

    addLimit(m.sender, global.isPrem(m.sender), isCreator);

    try {
        await alip.sendMessage(m.chat, { react: { text: 'â³', key: m.key } });

        if (/webp/i.test(mime) && q.isAnimated) {
            const uploadFile = async (buffer, filename) => {
                const FormData = require('form-data');
                const form = new FormData();
                form.append('files[]', buffer, { filename });
                const response = await axios.post('https://uguu.se/upload.php', form, {
                    headers: { ...form.getHeaders() },
                    maxContentLength: Infinity,
                    maxBodyLength: Infinity,
                });
                const fileUrl = response.data?.files?.[0]?.url;
                if (fileUrl) return fileUrl;
                throw new Error('Gagal mengunggah media ke server sementara.');
            };
            
            const media = await q.download();
            const tempUrl = await uploadFile(media, 'sticker.webp');
            
            const apiUrl = `${global.btc}/api/tools/webp2mp4?url=${tempUrl}&apikey=${global.apikeyalip}`;
            const response = await fetchJson(apiUrl); 

            if (!response.status || !response.result) {
                throw new Error('API gagal mengonversi stiker.');
            }

            await alip.sendMessage(m.chat, { 
                video: { url: response.result }, 
                caption: 'âœ… Stiker animasi berhasil diubah ke GIF!',
                gifPlayback: true
            });

        } else if (/video/i.test(mime)) {
            const media = await q.download();
            
            await alip.sendMessage(m.chat, { 
                video: media, 
                caption: 'âœ… Video berhasil diubah ke GIF!',
                gifPlayback: true
            });

        } else if (/image/i.test(mime) || /webp/i.test(mime)) {
            const media = await q.download();
            let imageBuffer = media;
            if (/webp/i.test(mime)) {
                const webpPath = await alip.downloadAndSaveMediaMessage(q);
                const { exec } = require('child_process');
                const fs = require('fs');
                const outPath = webpPath + '.jpg';
                await new Promise((res, rej) =>
                    exec(`ffmpeg -i "${webpPath}" -vframes 1 "${outPath}"`, (err) => (err ? rej(err) : res()))
                );
                imageBuffer = fs.readFileSync(outPath);
                fs.unlinkSync(webpPath);
                fs.unlinkSync(outPath);
            }
            await alip.sendMessage(m.chat, { 
                video: imageBuffer, 
                caption: 'âœ… Gambar berhasil diubah ke GIF!',
                gifPlayback: true
            });
        }

        await alip.sendMessage(m.chat, { react: { text: 'âœ…', key: m.key } });

    } catch (e) {
        console.error("TOGIF Error:", e);
        await alip.sendMessage(m.chat, { react: { text: 'âŒ', key: m.key } });
        Reply(`âŒ Gagal mengonversi ke GIF: ${e.message}`);
    }
}
break;

default:
if (budy.startsWith('>')) {
if (!isCreator) return
try {
let evaled = await eval(budy.slice(2))
if (typeof evaled !== 'string') evaled = require('util').inspect(evaled)
await Reply(evaled)
} catch (err) {
await Reply(String(err))
}}

//================================================================================

if (m.text.toLowerCase() === "bot") {
    try {
        const text = `${global.botname} online`;
        
        const response = await axios.get(
            'https://raw.githubusercontent.com/alifalfarel25-commits/dat4/main/uploads/alip-clutch-1770001033541.jpg',
            { responseType: 'arraybuffer' }
        );
        const buffer = Buffer.from(response.data);

        const img = await loadImage(buffer);
        const canvas = createCanvas(img.width, img.height);
        const ctx = canvas.getContext('2d');

        ctx.drawImage(img, 0, 0, img.width, img.height);

        const areaX = img.width * 0.56;
        const areaY = img.height * 0.28;
        const areaWidth = img.width * 0.36;
        const areaHeight = img.height * 0.32;

        let fontSize = img.height * 0.11;
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = '#000';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';

        const words = text.split(' ');
        let lines = [];
        let line = '';

        for (let word of words) {
            const testLine = line ? `${line} ${word}` : word;
            const testWidth = ctx.measureText(testLine).width;

            if (testWidth > areaWidth && line) {
                lines.push(line);
                line = word;
            } else {
                line = testLine;
            }
        }
        if (line) lines.push(line);

        while (lines.length * fontSize * 1.25 > areaHeight) {
            fontSize -= 2;
            ctx.font = `${fontSize}px Arial`;

            let tmpLines = [];
            let tmpLine = '';
            for (let word of words) {
                const testLine = tmpLine ? `${tmpLine} ${word}` : word;
                const testWidth = ctx.measureText(testLine).width;

                if (testWidth > areaWidth && tmpLine) {
                    tmpLines.push(tmpLine);
                    tmpLine = word;
                } else {
                    tmpLine = testLine;
                }
            }
            if (tmpLine) tmpLines.push(tmpLine);
            lines = tmpLines;
        }

        const lineHeight = fontSize * 1.25;

        ctx.shadowColor = 'rgba(0,0,0,0.22)';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.globalAlpha = 0.95;

        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(
                lines[i],
                areaX,
                areaY + i * lineHeight
            );
        }

        ctx.globalAlpha = 1;

        const imageBuffer = canvas.toBuffer('image/png');

        const { Sticker } = require('wa-sticker-formatter');
        const sticker = new Sticker(imageBuffer, {
            pack: global.packname,
            author: global.author || global.namaOwner || "alip AI",
            type: 'full',
            quality: 100
        });

        await alip.sendMessage(m.chat, { 
            sticker: await sticker.toBuffer(),
            contextInfo: {
                isForwarded: true,
                forwardingScore: 999,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: global.idSaluran,
                    newsletterName: global.namaSaluran,
                    serverMessageId: -1
                }
            }
        }, { quoted: m });

    } catch (e) {
        Reply(`ðŸŸ¢ *${global.botname} Online!*`);
    }
}
//================================================================================

if (budy.startsWith('=>')) {
if (!isCreator) return
try {
let evaled = await eval(`(async () => { ${budy.slice(2)} })()`)
if (typeof evaled !== 'string') evaled = require('util').inspect(evaled)
await Reply(evaled)
} catch (err) {
await Reply(String(err))
}}

//================================================================================

if (budy.startsWith('$')) {
if (!isCreator) return
if (!text) return
exec(budy.slice(2), (err, stdout) => {
if (err) return Reply(`${err}`)
if (stdout) return Reply(stdout)
})
}

//================================================================================
}
} catch (err) {
    console.log(util.format(err));
    let Obj = global.owner
    alip.sendMessage(Obj + "@s.whatsapp.net", { 
        text: `
*ERROR TERDETEKSI :*\n\n` + util.format(err), 
        contextInfo: { isForwarded: true } 
    }, { quoted: m })
}}

//================================================================================

if (!global.dbSaveInterval) {
    global.dbSaveInterval = setInterval(() => {
        try {
            if (global.db && global.db.groups) {
                const dbDir = './library/database';
                if (!fs.existsSync(dbDir)) fs.mkdirSync(dbDir, true);
                
                fs.writeFileSync('./library/database/groups_db.json', JSON.stringify(global.db.groups, null, 2));
            }
        } catch (e) {
        }
    }, 30000);
}

let file = require.resolve(__filename)
fs.watchFile(file, () => {
	fs.unwatchFile(file)
	console.log(chalk.redBright(`Update ${__filename}`))
	delete require.cache[file]
	require(file)
});